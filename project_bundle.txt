# BUNDLE OF PROJECT: /Users/39apple.ru/Documents/Gemeni/kaliningrad_guide_bot

--------------------------------------------------------------------------------
--- FILE: project_bundle.txt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--- FILE: run.py
--------------------------------------------------------------------------------
import os

# --- Настройки ---
# Папки и файлы, которые нужно исключить из сборки
EXCLUDE_DIRS = {'.git', '.idea', '.vscode', '__pycache__', '.venv', 'venv'}
EXCLUDE_FILES = {'.gitignore', 'project_archive.zip', 'bundle_for_ai.py'}
# Имя выходного файла
OUTPUT_FILE = 'project_bundle.txt'
# --- Конец настроек ---

def bundle_project(project_path='.'):
    """Собирает все текстовые файлы проекта в один .txt файл."""
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f_out:
        f_out.write(f"# BUNDLE OF PROJECT: {os.path.abspath(project_path)}\n\n")
        for root, dirs, files in os.walk(project_path):
            # Исключаем ненужные директории
            dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]

            for file in files:
                if file in EXCLUDE_FILES:
                    continue

                file_path = os.path.join(root, file)
                relative_path = os.path.relpath(file_path, project_path)

                try:
                    with open(file_path, 'r', encoding='utf-8') as f_in:
                        content = f_in.read()
                    
                    f_out.write("-" * 80 + "\n")
                    f_out.write(f"--- FILE: {relative_path.replace(os.sep, '/')}\n")
                    f_out.write("-" * 80 + "\n")
                    f_out.write(content)
                    f_out.write("\n\n")
                    print(f"[+] Added: {relative_path}")

                except Exception as e:
                    # Пропускаем бинарные файлы или файлы с проблемами кодировки
                    f_out.write("-" * 80 + "\n")
                    f_out.write(f"--- SKIPPED (binary or error): {relative_path.replace(os.sep, '/')} | Reason: {e}\n")
                    f_out.write("-" * 80 + "\n\n")
                    print(f"[-] Skipped: {relative_path} ({e})")

    print(f"\nProject bundled into: {OUTPUT_FILE}")

if __name__ == '__main__':
    bundle_project()

--------------------------------------------------------------------------------
--- SKIPPED (binary or error): .DS_Store | Reason: 'utf-8' codec can't decode byte 0x80 in position 3131: invalid start byte
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- FILE: requirements.txt
--------------------------------------------------------------------------------
# Фреймворк для бота
aiogram==3.10.0

# Работа с базой данных PostgreSQL
sqlalchemy==2.0.31
alembic==1.13.2
asyncpg==0.29.0
psycopg2-binary==2.9.9

# Работа с Redis (для машины состояний FSM)
redis==5.0.7

# Загрузка переменных окружения из .env файла
python-dotenv==1.0.1

# Для типизации и валидации настроек (лучшая практика)
pydantic==2.8.2
pydantic-settings==2.4.0

# Планировщик фоновых задач
apscheduler==3.10.4

# Календарь для aiogram 3
aiogram_calendar==0.6.0

# Веб-сервер
aiohttp

# --- НОВАЯ ЗАВИСИМОСТЬ ---
# Для настройки CORS (Cross-Origin Resource Sharing)
aiohttp-cors==0.7.0


--------------------------------------------------------------------------------
--- FILE: пушка.txt
--------------------------------------------------------------------------------
Концепция лучшего Telegram-бота для посуточной аренды квартир: Анализ и рекомендации
Задача по анализу миллионов Telegram-ботов для посуточной аренды квартир и выработке концепции лучшего из них является масштабной и требует глубокого понимания как технологических возможностей платформы Telegram, так и динамики рынка краткосрочной аренды. Настоящий отчет представляет собой синтез ключевых данных и углубленный анализ, направленный на формирование всеобъемлющего видения такого бота.

I. Анализ текущего ландшафта Telegram-ботов для аренды квартир
A. Обзор существующих решений и их функционала

Существующий ландшафт Telegram-ботов для аренды квартир демонстрирует широкий спектр функциональных возможностей, от базовых до весьма продвинутых. Многие боты предлагают основные функции, такие как автоматизированный поиск жилья. Пользователи могут задавать параметры, включая тип аренды (долгосрочная или краткосрочная), город, район, диапазон цен, и количество комнат. Эти базовые фильтры позволяют пользователям эффективно сужать круг поиска, что является фундаментальным требованием для любого бота по аренде.   

Помимо основных возможностей, многие боты включают более продвинутые функции, значительно повышающие их ценность. К ним относятся уведомления о новых объявлениях и отслеживание изменений цен, что крайне важно на быстро меняющемся рынке аренды. Например, бот Letify уделяет особое внимание комплексным уведомлениям, содержащим полную информацию, такую как адрес, цена, год постройки, энергетический класс, количество комнат, площадь, этаж и тип объекта, что обеспечивает быстрое принятие решений. Такая полнота информации прямо противостоит проблемам, связанным с отсутствием данных или расхождениями в ценах, о которых сообщалось в отзывах пользователей о других ботах.   

Некоторые боты предлагают инновационные функции, направленные на решение специфических проблем рынка. Функция поиска «только от собственника» и обнаружение дубликатов, как это реализовано в боте АренДом, напрямую борются с распространенными проблемами, такими как спам от риелторов и мошеннические объявления, что значительно повышает доверие пользователей к платформе. Фильтры по наличию фотографий и ежедневная статистика цен также улучшают качество поиска. Способность ботов поддерживать несколько одновременных поисков и отображать прямую контактную информацию арендодателя без необходимости перехода на исходный сайт значительно упрощает процесс для пользователя. Более того, некоторые боты уже включают функции виртуальных туров и персонализированных рекомендаций, используя искусственный интеллект для анализа предпочтений пользователя и предоставления наиболее подходящих вариантов. Автоматизированная помощь в подаче заявок, такая как генерация предварительных сообщений для связи с арендодателями, также способствует повышению эффективности для пользователей.   

Интересно, что многие функции, изначально разработанные для ботов в других доменных областях, таких как коммунальные услуги, могут быть успешно перенесены в сферу аренды. Примером является бот MyHome24, который предлагает обработку платежей, просмотр финансовой информации (баланс, задолженность, история платежей), передачу показаний счетчиков, подачу заявок и запросов (например, на обслуживание), а также сегментированные уведомления и опросы. Эти возможности могут быть напрямую применены для управления краткосрочной арендой, охватывая весь жизненный цикл взаимодействия с объектом — от первоначального поиска до бронирования, оплаты и даже послеарендной поддержки, например, для запросов на техническое обслуживание или напоминаний о платежах. Это позволяет боту стать не просто инструментом поиска, а комплексным помощником по управлению арендой.   

B. Анализ пользовательского опыта и обратной связи

Анализ пользовательского опыта и обратной связи выявляет как сильные стороны, так и критические недостатки существующих Telegram-ботов для аренды. Пользователи высоко ценят удобство, мгновенные обновления и функции автоматического поиска, которые позволяют им оперативно получать информацию о новых объявлениях и отслеживать изменения цен. Например, функция отслеживания изменений цен была отмечена как очень полезная, демонстрируя, что пользователи ценят не только новые объявления, но и актуальность информации по уже существующим.   

Однако, несмотря на положительные отзывы, существуют серьезные проблемы, которые подрывают доверие и юзабилити. Одной из наиболее частых жалоб является нестабильная работа ботов, когда они "не работают" или предоставляют устаревшие данные. Например, бот, обсуждаемый на форуме Onliner.by, получал положительные отзывы за отслеживание цен, но также и сообщения о том, что он "не работает". Аналогично, бот АренДом, несмотря на свои инновационные функции, часто сталкивался с отзывами о неработоспособности и расхождениях в ценах, вызванных некорректными данными из исходных источников. Это подчеркивает, что даже самый функциональный бот бесполезен, если он ненадежен, и указывает на необходимость постоянного обслуживания, мониторинга и надежной инфраструктуры.   

Еще одной критической проблемой является распространенность мошенничества на каналах Telegram, связанных с арендой. Пользователи сталкиваются с фальшивыми объявлениями, повторно размещенными объявлениями и запросами на оплату несуществующих квартир. Это серьезно подрывает доверие к платформе и является ключевым препятствием для широкого внедрения. Бот Leo, ориентированный на знакомства, также столкнулся с проблемами мошенничества, что указывает на общую уязвимость Telegram-среды, если не предпринять надлежащих мер безопасности. Отсутствие изображений в объявлениях или расхождения в ценах между ботом и исходным сайтом также являются источником разочарования для пользователей.   

Пользователи также активно делятся предложениями по улучшению, которые предоставляют ценные указания для разработки лучшего бота. Среди них — интеграция карт с возможностью выбора районов по метро или рисования полигонов для поиска, что значительно улучшит интуитивность географического поиска. Запросы на быстрые команды и возможность отправки всех найденных вариантов на электронную почту также указывают на потребность в более гибких и эффективных способах взаимодействия с результатами поиска. Расширение функционала на другие города или даже на покупку жилья также является частым пожеланием, что говорит о потенциале для масштабирования и расширения услуг. Эти предложения напрямую влияют на разработку функций поиска и вывода информации в будущем боте.   

II. Концепция лучшего Telegram-бота для посуточной аренды
A. Общая концепция и позиционирование

Концепция лучшего Telegram-бота для посуточной аренды выходит за рамки простого инструмента поиска, стремясь стать комплексной, доверенной и интеллектуальной платформой, обслуживающей весь жизненный цикл аренды.

Во-первых, бот должен функционировать как двусторонняя платформа, одинаково эффективно обслуживая как арендаторов, так и арендодателей/агентов. Такой подход позволяет создать самоподдерживающуюся экосистему, где бот не только помогает людям найти жилье, но и предоставляет арендодателям инструменты для управления объявлениями, квалификации лидов и взаимодействия с потенциальными клиентами. Это максимизирует ценность для всех участников рынка, превращая бота в полноценный маркетплейс.   

Во-вторых, ключевым аспектом является комплексное управление жизненным циклом аренды. Бот должен сопровождать пользователя от первоначального поиска до бронирования, оплаты и даже послеарендной поддержки, такой как подача запросов на обслуживание или получение напоминаний о платежах. Интеграция этих этапов обеспечивает бесшовный пользовательский опыт, снижает трение и повышает вовлеченность. Например, автоматические подтверждения бронирования, напоминания об оплате и инструкции по заселению могут значительно упростить процесс для обеих сторон.   

В-третьих, фокус на доверии и безопасности является абсолютным приоритетом. Учитывая распространенность мошенничества на каналах Telegram, бот должен активно бороться с мошенническими схемами, обеспечивать целостность данных и максимальную прозрачность. Это включает в себя использование искусственного интеллекта для обнаружения подозрительных объявлений и поведения, механизмы верификации арендодателей и, возможно, интегрированные системы рейтинга и отзывов. Внедрение функций эскроу для платежей может стать решающим фактором для обеспечения безопасности транзакций и укрепления доверия пользователей. Официальные платежные API Telegram, которые не хранят конфиденциальные данные, также способствуют повышению безопасности.   

Наконец, для достижения статуса "лучшего в мире" бот должен обладать глобальной применимостью. Это подразумевает не только мультиязычную поддержку для обслуживания разнообразной пользовательской базы, но и адаптацию к региональным особенностям рынка и законодательству. Способность работать в различных языковых и культурных контекстах значительно расширит его потенциальный охват и привлекательность.   

B. Поиск

Функционал поиска в лучшем Telegram-боте для посуточной аренды должен быть значительно превосходящим текущие решения, обеспечивая всеобъемлющий охват, высокую точность и интуитивное взаимодействие.

Источники данных должны быть максимально широкими. Бот будет агрегировать информацию из множества источников, включая крупные порталы по аренде недвижимости, специализированные сайты, а также менее структурированные источники, такие как местные группы в Facebook и каналы Telegram. Это потребует использования продвинутых методов веб-скрейпинга, которые способны обходить ограничения и извлекать данные из различных форматов, а также интеграции через API, где это возможно. Для работы с неструктурированными данными из социальных сетей и чатов потребуется применение обработки естественного языка (NLP) для извлечения релевантной информации. Масштабирование этой системы сбора данных до миллионов объявлений потребует надежной прокси-инфраструктуры и эффективных механизмов обработки данных.   

Расширенные критерии поиска должны предоставлять пользователям беспрецедентный уровень детализации и гибкости. Помимо стандартных фильтров, таких как район, цена, количество комнат и тип недвижимости, бот должен поддерживать интуитивный геотаргетинг. Это включает возможность выбора объявлений по близости к станциям метро или путем рисования произвольных полигонов на интерактивной карте. Использование API Google Maps позволит интегрировать информацию о транспортной доступности, рассчитывать расстояния и находить объекты рядом с определенными достопримечательностями или рабочими местами. Дополнительные фильтры, такие как наличие высококачественных фотографий или статус "от собственника", значительно улучшат качество результатов и повысят доверие.   

AI-улучшенный поиск является краеугольным камнем превосходства. Использование обработки естественного языка (NLP) позволит боту понимать сложные и нюансированные запросы пользователей, сформулированные на естественном языке, а не только по ключевым словам. Например, пользователь сможет запросить "уютную квартиру, где разрешены домашние животные, с хорошим естественным освещением недалеко от парка". Искусственный интеллект также будет анализировать изображения и описания объявлений для семантического поиска, выходя за рамки простых ключевых слов. Это позволит боту распознавать качественные характеристики, такие как "современная кухня" или "просторная ванная комната", даже если эти термины явно не указаны в тексте. Более того, предиктивная аналитика на основе ИИ позволит боту прогнозировать предпочтения пользователей и рыночные тенденции, предлагая объявления, которые, скорее всего, заинтересуют пользователя, и помогая арендодателям понять спрос. Например, бот сможет рекомендовать квартиры, основываясь на предыдущих просмотрах пользователя или даже на его стиле жизни, который ИИ может вывести из его запросов.   

C. Вывод информации

Вывод информации в лучшем Telegram-боте должен быть не просто информативным, но и максимально удобным для принятия решений, обеспечивая скорость, полноту и интерактивность.

Комплексные уведомления являются критически важным элементом. Бот должен отправлять мгновенные оповещения о новых объявлениях и изменениях цен, поскольку рынок аренды часто является высококонкурентным и быстро меняющимся. Эти уведомления должны содержать максимально полную информацию об объекте: адрес, точную цену, год постройки, энергетический класс, количество комнат, площадь, этаж, тип недвижимости и, что особенно важно, высококачественные изображения. Предоставление всей необходимой информации непосредственно в уведомлении позволяет пользователям быстро оценить предложение и принять решение, не тратя время на переход по ссылкам и поиск деталей. Высокая скорость доставки уведомлений (в идеале, в течение 1-40 секунд после появления объявления) является конкурентным преимуществом.   

Мобильно-оптимизированный и интерактивный вывод обеспечит превосходный пользовательский опыт. Вместо простого текста, объявления должны быть представлены в виде визуально привлекательных карточек с фотографиями, что соответствует современным стандартам UX/UI. Карточки могут включать интерактивные ссылки, позволяющие пользователям мгновенно перейти к полным деталям объявления на исходном сайте или открыть местоположение на Google Картах. Функции "добавить в избранное" и возможность отправки всех найденных вариантов на электронную почту (как это предлагали пользователи для других ботов) также повысят удобство использования. Использование формата Telegram Mini App позволит создать полноценный, похожий на нативное приложение интерфейс внутри Telegram, с полноэкранным режимом и богатыми визуальными элементами.   

Персонализированные рекомендации будут постоянно улучшаться на основе анализа поведения пользователя и его предпочтений. Бот будет не просто фильтровать по заданным параметрам, но и учиться на каждом взаимодействии, предлагая более релевантные варианты с течением времени. Эта адаптивная персонализация сделает поиск жилья более эффективным и приятным.   

Наконец, бот может предоставлять статистику и аналитику рынка, превращаясь из простого поисковика в платформу рыночной аналитики. Это может включать ежедневные отчеты о средних ценах по районам, тенденциях на рынке аренды и аналитику по конкретным типам недвижимости. Такая информация ценна как для арендаторов, помогая им принимать обоснованные решения, так и для арендодателей, предоставляя им данные для оптимизации своих предложений.   

D. Внешний вид (Appearance) и UI/UX

Внешний вид и пользовательский опыт (UI/UX) лучшего Telegram-бота для посуточной аренды являются ключевыми факторами его успеха, поскольку они напрямую влияют на удовлетворенность, удержание и доверие пользователей.

Интуитивный и адаптивный дизайн является основой. Интерфейс должен быть максимально простым и понятным, позволяя пользователям легко ориентироваться без необходимости чтения инструкций. Это достигается за счет использования знакомых элементов управления, таких как кнопки, иконки и меню, которые органично вписываются в стиль Telegram. Адаптивный дизайн гарантирует корректное отображение и функциональность на различных устройствах, включая смартфоны и планшеты с разными размерами экранов и разрешениями, обеспечивая плавный и приятный опыт независимо от устройства. Использование Telegram Mini Apps позволяет создать полноценное веб-приложение внутри мессенджера, предоставляя богатый и гибкий интерфейс, который ощущается как нативное приложение.   

Скорость и производительность не менее важны. Пользователи ожидают мгновенных ответов, и медленно работающее приложение может привести к разочарованию и отказу от использования. Оптимизация производительности мини-приложения, минимизация времени загрузки и задержек, а также обеспечение высокой пропускной способности (способность обрабатывать до 10 000 запросов в секунду, как у некоторых продвинутых ботов) являются критически важными. Это требует оптимизации кода, использования кэширования данных и эффективного взаимодействия с сервером. Возможность доступа к базовой информации об аппаратном обеспечении устройства пользователя позволяет боту автоматически настраивать параметры для обеспечения максимально плавной работы.   

Четкие уведомления и подтверждения помогают пользователям понимать, что происходит в приложении. Сообщения должны быть простыми и ясными, четко объясняя результат действия пользователя, предотвращая недопонимания и улучшая общую юзабилити. Например, при успешной подаче заявки или бронировании, бот должен предоставить недвусмысленное подтверждение.   

Персонализация интерфейса делает приложение более привлекательным и удобным. Предоставление пользователям возможности настраивать бот под свои предпочтения, например, выбирать темы или языки, дает им ощущение контроля и адаптирует опыт под их нужды. Это не только улучшает взаимодействие, но и повышает лояльность пользователей.   

Наконец, визуальная насыщенность является обязательной для бота по аренде недвижимости. Использование карточек объявлений с высококачественными фотографиями, возможность просмотра виртуальных туров и применение анимаций сделают процесс поиска более увлекательным и информативным. Telegram Mini Apps предоставляют широкие возможности для создания такого богатого визуального опыта, который превосходит возможности простых текстовых ботов.   

E. Уникальные особенности (Unique Features) / Фишки

Лучший Telegram-бот для посуточной аренды будет отличаться набором уникальных и инновационных особенностей, которые значительно повысят его ценность для пользователей и выделят его на рынке.

Одной из ключевых "фишек" будет AI-анализ изображений и описаний. Использование искусственного интеллекта для анализа фотографий и текстовых описаний объявлений позволит боту выходить за рамки простого сопоставления ключевых слов. Например, ИИ сможет распознавать "современную кухню" на изображении или "уютную атмосферу" из описания, предоставляя семантический поиск, который точно соответствует невысказанным предпочтениям пользователя. Пользователи смогут даже загружать фотографии желаемого интерьера и просить бота найти похожие варианты.   

Предиктивная аналитика для арендаторов и арендодателей станет мощным инструментом. Бот будет использовать ИИ для прогнозирования предпочтений арендаторов, предсказания рыночных тенденций и даже оценки стоимости аренды недвижимости. Это позволит арендаторам быстрее находить идеальные варианты, а арендодателям — оптимизировать свои стратегии ценообразования и маркетинга, предоставляя им ценную информацию о рынке.   

Учитывая проблемы мошенничества, функции борьбы со мошенничеством будут интегрированы на всех уровнях. Это включает автоматическое обнаружение дубликатов объявлений, выявление подозрительно низких цен, а также продвинутые механизмы верификации арендодателей. Возможно, будет реализована система рейтинга и отзывов, которая позволит пользователям оценивать арендодателей и сообщать о недобросовестных практиках, что создаст более безопасную и прозрачную среду.   

Интегрированная система платежей и эскроу станет значительным преимуществом. Бот будет поддерживать безопасные транзакции напрямую внутри Telegram, используя официальные API платформы (например, Telegram Stars для цифровых услуг) и сторонние платежные шлюзы (например, Stripe) для фиатных валют. Самое главное, будет предложена функция эскроу, которая будет выступать в качестве доверенной третьей стороны, удерживающей средства до тех пор, пока обе стороны не подтвердят выполнение условий сделки. Это обеспечит беспрецедентный уровень безопасности и доверия для посуточной аренды.   

AI-помощь в юридических вопросах является высокоинновационной функцией. Бот сможет генерировать стандартные договоры аренды на основе ответов пользователя и анализировать загруженные тексты договоров с использованием GPT-4, выделяя потенциально спорные или опасные пункты. Это значительно упростит юридический аспект аренды для обеих сторон, особенно для краткосрочных сделок, где условия могут быть менее стандартизированы.   

Для арендодателей будет предусмотрена автоматизация взаимодействия, включая квалификацию лидов, автоматические ответы на часто задаваемые вопросы, планирование показов и управление заявками на обслуживание. Это позволит арендодателям значительно сократить административную нагрузку и повысить эффективность работы с клиентами. ИИ сможет даже определять уровень заинтересованности потенциального клиента и направлять его по соответствующему пути.   

Наконец, голосовое управление и взаимодействие повысят доступность и удобство использования. Пользователи смогут формулировать поисковые запросы и задавать вопросы с помощью голосовых сообщений, а бот будет отвечать текстом или синтезированной речью, используя технологии преобразования речи в текст и текста в речь. Это сделает взаимодействие с ботом более естественным и интуитивным.   

F. Монетизация

Монетизация лучшего Telegram-бота для посуточной аренды будет осуществляться через многогранную стратегию, сочетающую различные модели для максимизации дохода и обеспечения устойчивого развития.

Модель подписки будет основной для арендаторов, предлагая различные уровни доступа к премиум-функциям. Это может включать расширенные возможности поиска, приоритетные уведомления о новых объявлениях, доступ к эксклюзивным или "офф-маркет" предложениям, а также углубленную аналитику рынка. Например, студенческая подписка может предлагать скидки на доступ к базовым функциям, в то время как стандартная подписка предоставит полный спектр возможностей.   

Модель "плата за использование" будет применяться для специфических, высокоценных услуг. Это может включать плату за генерацию юридических договоров аренды, автоматизированную подачу заявок на несколько объектов одновременно, или продвижение объявлений для арендодателей. Такая модель позволяет пользователям платить только за те функции, которые им действительно нужны, обеспечивая гибкость.   

B2B-модели значительно расширят потоки доходов. Бот может выступать в качестве мощного инструмента лидогенерации для агентств недвижимости и частных арендодателей, предоставляя им квалифицированных потенциальных клиентов, заинтересованных в аренде. Кроме того, возможно размещение таргетированной рекламы сопутствующих услуг, таких как ремонтные работы, услуги по уборке, мебельные магазины, страхование или даже услуги по переезду. Это позволяет монетизировать широкую аудиторию, не взимая прямую плату с каждого пользователя за базовый функционал.   

Наконец, если бот успешно позиционируется как платформа для прямых бронирований, он может взимать комиссию с транзакций. Такая модель позволяет арендодателям снизить зависимость от дорогостоящих сторонних платформ (OTA), предлагая им более выгодные условия и сохраняя прямой контакт с клиентами. Интеграция с системами управления недвижимостью (PMS) для получения информации о ценах и доступности в реальном времени сделает эту модель особенно привлекательной для арендодателей.   

III. Стратегическая реализация и перспективы
A. Фазированная разработка

Реализация такого амбициозного проекта, как лучший Telegram-бот для посуточной аренды, требует стратегического подхода к разработке. Рекомендуется начать с фазированной разработки, начиная с минимально жизнеспособного продукта (MVP). MVP должен включать основные функции поиска, вывода информации и уведомлений, а также базовые механизмы безопасности. Это позволит быстро выйти на рынок, собрать раннюю обратную связь от реальных пользователей и проверить ключевые гипотезы. После этого, на основе полученных данных и отзывов, можно постепенно добавлять более сложные функции, такие как AI-анализ изображений, эскроу-сервисы и юридическая помощь. Такой подход позволяет управлять сложностью проекта и снижать риски, обеспечивая, что каждый последующий этап разработки соответствует реальным потребностям пользователей.   

B. Непрерывное улучшение

Для поддержания статуса "лучшего в мире" бот не может быть статичным; он должен постоянно развиваться. Это требует непрерывного улучшения, основанного на данных и обратной связи. Регулярное тестирование с реальными пользователями поможет выявлять и устранять проблемы, а также улучшать функциональность. Сбор и анализ детальных данных о поведении пользователей и производительности бота (например, с помощью отчетов о производительности бота и данных о вовлеченности) являются критически важными для принятия обоснованных решений по оптимизации. A/B-тестирование различных функций и элементов интерфейса позволит определить наиболее эффективные решения. Кроме того, бот должен быть способен обучаться на предпочтениях пользователей с течением времени, делая свои рекомендации более точными и персонализированными с каждой новой итерацией. Такой динамичный подход гарантирует, что продукт будет постоянно адаптироваться к изменяющимся потребностям рынка и ожиданиям пользователей.   

C. Масштабируемость и надежность

Учитывая цель обработки миллионов объявлений и запросов, масштабируемость и надежность являются фундаментальными требованиями к архитектуре бота. Для обеспечения высокой производительности и стабильной работы необходимо использовать облачные сервисы, которые предлагают гибкое масштабирование ресурсов в зависимости от нагрузки. Это позволит обрабатывать пиковые нагрузки без снижения скорости отклика, что критически важно на быстро меняющемся рынке аренды. Выбор современных фреймворков и технологий, таких как TypeScript и MongoDB, обеспечит прочную основу для разработки и хранения данных. Для эффективного сбора данных из множества источников потребуется надежная прокси-инфраструктура, способная обходить ограничения и обеспечивать непрерывный поток информации. Проактивный мониторинг системы и планирование обслуживания помогут предотвратить сбои, подобные тем, что приводили к неработоспособности других ботов. Надежность и стабильность работы являются основой доверия пользователей.   

D. Построение сообщества и экосистемы

Для долгосрочного успеха и устойчивого роста, лучший Telegram-бот должен стремиться к построению сообщества и экосистемы вокруг себя. Это включает в себя активное вовлечение пользователей, поощрение их к обмену опытом и отзывами, а также создание каналов для прямого взаимодействия. В перспективе можно рассмотреть возможность внедрения элементов децентрализованного управления (DAO), где пользователи могут голосовать за новые функции или развитие платформы, а также участвовать в распределении доходов. Такой подход может значительно повысить лояльность и создать ощущение сопричастности. Кроме того, для максимального охвата и удобства пользователей, в будущем можно рассмотреть возможность расширения функционала бота на другие популярные мессенджеры, такие как WhatsApp, хотя это и потребует анализа их API и потенциальных ограничений. Создание такой широкой экосистемы позволит боту стать неотъемлемой частью цифровой жизни своих пользователей.   

Выводы и рекомендации
Анализ существующего ландшафта Telegram-ботов для посуточной аренды квартир выявляет как значительный потенциал, так и серьезные проблемы, которые необходимо решить для создания по-настоящему лучшего продукта. Ключевой вывод заключается в том, что идеальный бот не может быть просто инструментом поиска; он должен представлять собой комплексную, интеллектуальную, безопасную и ориентированную на пользователя платформу, охватывающую весь жизненный цикл аренды.

Основные рекомендации по созданию лучшего Telegram-бота:

Приоритет доверия и безопасности: Это фундаментальное требование. Необходимо внедрить многоуровневые механизмы борьбы со мошенничеством, включая AI-обнаружение подозрительных объявлений, верификацию арендодателей и, критически важно, интегрированную систему эскроу для безопасных платежей. Прозрачность в обработке данных и платежей, с четким указанием на то, что конфиденциальная финансовая информация не хранится ботом, укрепит доверие пользователей.

AI-центричный подход: Искусственный интеллект должен быть интегрирован на всех этапах взаимодействия. Это включает NLP для понимания сложных поисковых запросов на естественном языке, AI-анализ изображений и описаний для семантического поиска, предиктивную аналитику для персонализированных рекомендаций и рыночных прогнозов, а также AI-помощь в юридических вопросах, таких как генерация и анализ договоров аренды.

Комплексное управление жизненным циклом: Бот должен поддерживать пользователя от момента поиска до бронирования, оплаты и даже послеарендного обслуживания. Это подразумевает автоматизацию уведомлений о бронировании, напоминаний о платежах, возможность подачи заявок на обслуживание и интеграцию с системами управления недвижимостью (PMS) для арендодателей.

Превосходный UI/UX и производительность: Использование формата Telegram Mini App позволит создать визуально насыщенный, интуитивно понятный и адаптивный интерфейс, который ощущается как нативное приложение. При этом критически важна высокая скорость отклика и стабильная работа, обеспечиваемая оптимизированной архитектурой и масштабируемой облачной инфраструктурой. Голосовое управление также повысит удобство использования.

Гибкая и многогранная модель монетизации: Для обеспечения устойчивости проекта следует рассмотреть гибридную модель, включающую подписки на премиум-функции для арендаторов, плату за использование специфических услуг (например, юридическую помощь) и B2B-модели, такие как лидогенерация и таргетированная реклама для арендодателей и сопутствующих бизнесов. Возможность взимания комиссии с прямых бронирований также является привлекательной перспективой.

Стратегия непрерывного развития: Проект должен быть построен на принципах фазированной разработки, начиная с MVP, и постоянно улучшаться на основе сбора и анализа данных о поведении пользователей, A/B-тестирования и регулярных обновлений.

Реализация этих рекомендаций позволит создать Telegram-бот для посуточной аренды, который не только превзойдет существующие решения по функционалу и удобству, но и станет надежной, безопасной и интеллектуальной платформой, способной изменить рынок краткосрочно

--------------------------------------------------------------------------------
--- FILE: alembic.ini
--------------------------------------------------------------------------------
# A generic, single database configuration.

[alembic]
# path to migration scripts
# Use forward slashes (/) also on windows to provide an os agnostic path
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to alembic/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:alembic/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
version_path_separator = os  # Use os.pathsep. Default configuration used for new projects.

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = driver://user:pass@localhost/dbname


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S


--------------------------------------------------------------------------------
--- FILE: Dockerfile
--------------------------------------------------------------------------------
# 1. Используем официальный образ Python как основу
FROM python:3.11-slim

# 2. Устанавливаем рабочую директорию внутри контейнера
WORKDIR /app

# 3. Копируем файл с зависимостями в контейнер
COPY requirements.txt .

# 4. Устанавливаем зависимости
RUN pip install --no-cache-dir -r requirements.txt

# 5. Копируем весь код нашего приложения в контейнер
COPY . .

# 6. Команда, которая будет запускать бота при старте контейнера
CMD ["python", "main.py"]

--------------------------------------------------------------------------------
--- FILE: project_structure.txt
--------------------------------------------------------------------------------
.
├── alembic
│   ├── __pycache__
│   │   └── env.cpython-311.pyc
│   ├── env.py
│   ├── README
│   ├── script.py.mako
│   └── versions
│       ├── __pycache__
│       │   └── e511f78981e8_add_district_and_rooms_update_fsm.cpython-311.pyc
│       └── e511f78981e8_add_district_and_rooms_update_fsm.py
├── alembic.ini
├── app
│   ├── core
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-311.pyc
│   │   │   ├── commands.cpython-311.pyc
│   │   │   ├── constants.cpython-311.pyc
│   │   │   └── settings.cpython-311.pyc
│   │   ├── commands.py
│   │   ├── constants.py
│   │   └── settings.py
│   ├── handlers
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-311.pyc
│   │   │   ├── admin_handlers.cpython-311.pyc
│   │   │   ├── owner_handlers.cpython-311.pyc
│   │   │   └── user_handlers.cpython-311.pyc
│   │   ├── admin_handlers.py
│   │   ├── owner_handlers.py
│   │   └── user_handlers.py
│   ├── keyboards
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-311.pyc
│   │   │   └── inline_keyboards.cpython-311.pyc
│   │   └── inline_keyboards.py
│   ├── models
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-311.pyc
│   │   │   ├── base.cpython-311.pyc
│   │   │   └── models.cpython-311.pyc
│   │   ├── base.py
│   │   └── models.py
│   ├── services
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-311.pyc
│   │   │   └── repository.cpython-311.pyc
│   │   └── repository.py
│   └── utils
│       ├── __init__.py
│       ├── __pycache__
│       │   ├── __init__.cpython-311.pyc
│       │   └── states.cpython-311.pyc
│       └── states.py
├── docker-compose.yml
├── Dockerfile
├── main.py
├── project_structure.txt
├── requirements.txt
└── tests

19 directories, 46 files


--------------------------------------------------------------------------------
--- FILE: .env
--------------------------------------------------------------------------------
# Telegram Bot Token
BOT_TOKEN=8088668796:AAFvLtI83X8dmcwyxuKQDGy9z35emtg4irI

# PostgreSQL Settings
POSTGRES_USER=myuser
POSTGRES_PASSWORD=mypassword
POSTGRES_DB=rent_bot_db
POSTGRES_HOST=db
POSTGRES_PORT=5432

# Redis Settings
REDIS_HOST=redis
REDIS_PORT=6379

# ID администраторов через запятую, без пробелов
ADMIN_IDS='[6180797700]'

--------------------------------------------------------------------------------
--- FILE: docker-compose.yml
--------------------------------------------------------------------------------
services:
  bot:
    build: .
    env_file: .env
    volumes:
      - .:/app
    # --- ИСПРАВЛЕНИЕ: Открываем порт для веб-сервера ---
    ports:
      - "8080:8080"
    depends_on:
      - db
      - redis
    restart: always

  db:
    image: postgres:16-alpine
    env_file: .env
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    ports:
      - "5433:5432"
    restart: always

  redis:
    image: redis:7-alpine
    restart: always

volumes:
  postgres_data:



--------------------------------------------------------------------------------
--- FILE: .env.example
--------------------------------------------------------------------------------
# Telegram Bot Token
BOT_TOKEN=ВАШ_ТЕЛЕГРАМ_ТОКЕН_ЗДЕСЬ

# PostgreSQL Settings
POSTGRES_USER=myuser
POSTGRES_PASSWORD=mypassword
POSTGRES_DB=rent_bot_db
POSTGRES_HOST=db
POSTGRES_PORT=5432

# Redis Settings
REDIS_HOST=redis
REDIS_PORT=6379

--------------------------------------------------------------------------------
--- FILE: main.py
--------------------------------------------------------------------------------
import asyncio
import logging
import sys

from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiohttp import web

from src.core.settings import settings
from src.core.commands import set_commands
from src.core.scheduler import scheduler
from src.handlers import main_router
from src.web.routes import setup_routes  # <-- Наш новый импорт

async def start_bot(dp: Dispatcher, bot: Bot):
    """Запускает процесс поллинга бота."""
    await set_commands(bot)
    dp.include_router(main_router)
    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(bot)

async def start_web_server():
    """Запускает веб-сервер для API."""
    app = web.Application()
    setup_routes(app) # Настраиваем роуты для API
    runner = web.AppRunner(app)
    await runner.setup()
    # Запускаем на порту 8080, как требует большинство хостингов
    site = web.TCPSite(runner, '0.0.0.0', 8080) 
    await site.start()
    logging.info("Web server started on http://0.0.0.0:8080")
    # Бесконечно ждем, пока сервер работает
    while True:
        await asyncio.sleep(3600)

async def main():
    bot = Bot(
        token=settings.BOT_TOKEN.get_secret_value(),
        default=DefaultBotProperties(parse_mode=ParseMode.HTML)
    )
    dp = Dispatcher()
    
    # Запускаем планировщик
    scheduler.start()
    
    # Запускаем бота и веб-сервер параллельно
    await asyncio.gather(
        start_bot(dp, bot),
        start_web_server()
    )

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, stream=sys.stdout)
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logging.info("App stopped by admin.")



--------------------------------------------------------------------------------
--- FILE: gitignore
--------------------------------------------------------------------------------
# Файлы кэша Python
__pycache__/
*.pyc
*.pyo
*.pyd

# Виртуальные окружения
venv/
env/
.venv/

# Файлы IDE и редакторов
.vscode/
.idea/

# Файлы операционной системы
.DS_Store
Thumbs.db

# Файлы с секретами и переменными окружения
# ВАЖНО: Никогда не добавляйте файлы с паролями, токенами, ключами API в Git!
.env
*.env

# Лог-файлы
*.log

--------------------------------------------------------------------------------
--- SKIPPED (binary or error): app/.DS_Store | Reason: 'utf-8' codec can't decode byte 0x80 in position 3131: invalid start byte
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- FILE: app/core/constants.py
--------------------------------------------------------------------------------
DISTRICTS = {
    "Калининград": [
        'Центральный (весь)',
        'мкр. Сельма',
        'Амалиенау / Центр',
        'Ленинградский (весь)',
        'Верхнее Озеро',
        'Московский (весь)',
        'Остров Канта'
    ],
    "Побережье": ['Зеленоградск', 'Светлогорск', 'Янтарный', 'Пионерский', 'Балтийск'],
    "Куршская коса": ["Куршская коса"],
    "Другие города": ['Черняховск', 'Советск', 'Гусев', 'Другой']
}

PROPERTY_TYPES = ['Квартира', 'Апартаменты', 'Дом', 'Кемпинг']
ROOM_OPTIONS = ['Студия', '1', '2', '3', '4', '5+']
GUEST_OPTIONS = ['1', '2', '3', '4', '5', '6', '7', '8+']

--------------------------------------------------------------------------------
--- FILE: app/core/__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--- FILE: app/core/settings.py
--------------------------------------------------------------------------------
from pydantic import SecretStr
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8')

    BOT_TOKEN: SecretStr

    # --- НАШЕ ИЗМЕНЕНИЕ ЗДЕСЬ ---
    # Pydantic автоматически преобразует строку "id1,id2" в список чисел
    ADMIN_IDS: list[int]

    POSTGRES_USER: str
    POSTGRES_PASSWORD: SecretStr
    POSTGRES_DB: str
    POSTGRES_HOST: str
    POSTGRES_PORT: int

    REDIS_HOST: str
    REDIS_PORT: int

    @property
    def DATABASE_URL_asyncpg(self) -> str:
        return (f"postgresql+asyncpg://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD.get_secret_value()}"
                f"@{self.POSTGRES_HOST}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}")

    @property
    def DATABASE_URL_psycopg(self) -> str:
        return (f"postgresql+psycopg2://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD.get_secret_value()}"
                f"@{self.POSTGRES_HOST}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}")

settings = Settings()

--------------------------------------------------------------------------------
--- FILE: app/core/scheduler.py
--------------------------------------------------------------------------------
from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from aiogram import Bot
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode

from src.core.settings import settings
# --- ИСПРАВЛЕНИЕ ЗДЕСЬ: Указываем новый, правильный путь к файлу ---
from src.keyboards.inline_keyboards import get_rating_keyboard

jobstores = {
    'default': SQLAlchemyJobStore(url=settings.DATABASE_URL_psycopg)
}
scheduler = AsyncIOScheduler(jobstores=jobstores, timezone="Europe/Kaliningrad")


async def request_review(bot_token: str, chat_id: int, booking_id: int, property_title: str):
    """
    Запрашивает у пользователя отзыв о проживании.
    """
    temp_bot = Bot(token=bot_token, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
    try:
        await temp_bot.send_message(
            chat_id=chat_id,
            text=(
                f"Надеемся, вам понравилось проживание в «{property_title}»!\n\n"
                f"Пожалуйста, оцените ваш опыт по пятизвездочной шкале. Это поможет другим путешественникам сделать правильный выбор."
            ),
            reply_markup=get_rating_keyboard(booking_id)
        )
    finally:
        await temp_bot.session.close()

--------------------------------------------------------------------------------
--- FILE: app/core/commands.py
--------------------------------------------------------------------------------
from aiogram import Bot
from aiogram.types import BotCommand, BotCommandScopeChat, BotCommandScopeDefault

from src.core.settings import settings

# Добавляем /help в список для всех пользователей
user_commands = [
    BotCommand(command="start", description="🚀 Перезапустить бота / Главное меню"),
    BotCommand(command="help", description="ℹ️ Справка по боту"),
    BotCommand(command="cancel", description="❌ Отменить текущее действие")
]

# Администраторы автоматически получат эту команду
admin_commands = user_commands + [
    BotCommand(command="myproperties", description="📋 Мои объекты"),
    BotCommand(command="addproperty", description="🏠 Добавить новый объект"),
    BotCommand(command="verify", description="✅ Верифицировать объект"),
    BotCommand(command="unverify", description="❌ Снять верификацию"),
    BotCommand(command="setrole", description="👤 Назначить роль")
]


async def set_commands(bot: Bot):
    await bot.set_my_commands(commands=user_commands, scope=BotCommandScopeDefault())
    
    # Убедимся, что у админов будет полный список
    for admin_id in settings.ADMIN_IDS:
        await bot.set_my_commands(commands=admin_commands, scope=BotCommandScopeChat(chat_id=admin_id))

--------------------------------------------------------------------------------
--- FILE: app/web/__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--- FILE: app/web/routes.py
--------------------------------------------------------------------------------
import calendar
from datetime import date, datetime
from aiohttp import web
import json
import aiohttp_cors

from src.services import availability_service, booking_service, pricing_service
from src.services.db import async_session_maker

async def get_calendar_data(request: web.Request) -> web.Response:
    """API для получения данных для календарей."""
    try:
        property_id = int(request.match_info['property_id'])
        year = int(request.query.get('year', date.today().year))
        month = int(request.query.get('month', date.today().month))
    except (ValueError, KeyError):
        return web.json_response({'error': 'Invalid or missing parameters'}, status=400)

    async with async_session_maker() as session:
        prop = await pricing_service.get_property_with_price_rules(session, property_id)
        if not prop:
            return web.json_response({'error': 'Property not found'}, status=404)
        base_price = prop.price_per_night

        manual_blocks = await availability_service.get_manual_blocks(property_id)
        manual_block_map = {block.date: block.comment for block in manual_blocks}
        
        booked_dates = await booking_service.get_booked_dates_for_property(property_id)
        
        days_data = []
        days_in_month = calendar.monthrange(year, month)[1]

        for day_num in range(1, days_in_month + 1):
            current_date = date(year, month, day_num)
            status = 'available'
            comment = None

            if current_date < date.today():
                status = 'past'
            elif current_date in booked_dates:
                status = 'booked'
            elif current_date in manual_block_map:
                status = 'manual_block'
                comment = manual_block_map[current_date]
            
            price = None
            if status == 'available':
                price = await pricing_service.get_price_for_date(session, property_id, current_date, base_price)
            
            days_data.append({
                'date': current_date.strftime('%Y-%m-%d'),
                'status': status,
                'price': price,
                'comment': comment
            })
            
    return web.json_response(days_data)

async def toggle_availability(request: web.Request) -> web.Response:
    """Блокирует или разблокирует дату."""
    try:
        data = await request.json()
        property_id = int(data['property_id'])
        target_date_str = data['date']
        target_date = datetime.strptime(target_date_str, '%Y-%m-%d').date()
        comment = data.get('comment')
    except Exception:
        return web.json_response({'error': 'Invalid request body'}, status=400)

    booked_dates = await booking_service.get_booked_dates_for_property(property_id)
    if target_date in booked_dates:
        return web.json_response({'error': 'Date is already booked by a client'}, status=409)

    await availability_service.toggle_manual_availability(property_id, target_date, comment)
    return web.json_response({'status': 'ok'})

async def add_price_rule(request: web.Request) -> web.Response:
    """Добавляет новое ценовое правило."""
    try:
        data = await request.json()
        property_id = int(data['property_id'])
        start_date = datetime.strptime(data['start_date'], '%Y-%m-%d').date()
        end_date = datetime.strptime(data['end_date'], '%Y-%m-%d').date()
        price = int(data['price'])
    except Exception:
        return web.json_response({'error': 'Invalid request body'}, status=400)
        
    await pricing_service.add_price_rule(property_id, start_date, end_date, price)
    return web.json_response({'status': 'ok'})

def setup_routes(app: web.Application):
    """Настраивает все веб-роуты с поддержкой CORS."""
    app.router.add_static('/static/', path='app/static', name='static')
    cors = aiohttp_cors.setup(app, defaults={
        "*": aiohttp_cors.ResourceOptions(
            allow_credentials=True, expose_headers="*",
            allow_headers="*", allow_methods="*",
        )
        
    })
    
    calendar_resource = cors.add(app.router.add_resource('/api/calendar_data/{property_id}'))
    cors.add(calendar_resource.add_route("GET", get_calendar_data))
    
    toggle_resource = cors.add(app.router.add_resource('/api/owner/toggle_availability'))
    cors.add(toggle_resource.add_route("POST", toggle_availability))
    
    pricing_resource = cors.add(app.router.add_resource('/api/owner/price_rule'))
    cors.add(pricing_resource.add_route("POST", add_price_rule))


--------------------------------------------------------------------------------
--- FILE: app/keyboards/__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--- FILE: app/keyboards/inline_keyboards.py
--------------------------------------------------------------------------------
from datetime import datetime, timedelta
from typing import List
from aiogram.types import InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.filters.callback_data import CallbackData
from aiogram_calendar import SimpleCalendar
from aiogram.types import WebAppInfo
from src.core.constants import DISTRICTS, PROPERTY_TYPES, ROOM_OPTIONS, GUEST_OPTIONS

# --- ОБЩИЕ КЛАВИАТУРЫ ---
def get_main_menu():
    builder = InlineKeyboardBuilder()
    builder.button(text="🔍 Найти жилье", callback_data="main_menu:search")
    builder.button(text="🏠 Добавить объект", callback_data="main_menu:add_property")
    builder.button(text="ℹ️ О сервисе", callback_data="main_menu:about")
    builder.adjust(1)
    return builder.as_markup()

# --- КЛАВИАТУРЫ ДЛЯ ПОЛЬЗОВАТЕЛЯ (АРЕНДАТОРА) ---
def get_property_card_keyboard(property_id: int, photos_count: int = 0, has_video: bool = False, reviews_count: int = 0):
    builder = InlineKeyboardBuilder()
    total_media_count = photos_count + (1 if has_video else 0)

    # Кнопки для медиа и отзывов, если они есть
    if has_video:
        builder.button(text=f"▶️ Видео и фото ({total_media_count})", callback_data=f"view_media:{property_id}")
    elif photos_count > 1:
        builder.button(text=f"📸 Все фото ({photos_count})", callback_data=f"view_photos:{property_id}")

    if reviews_count > 0:
        builder.button(text=f"💬 Читать отзывы ({reviews_count})", callback_data=f"view_reviews:{property_id}")
    
    # --- Кнопки для бронирования ---
    # ИСПРАВЛЕНИЕ: Вставляем новую ссылку
    web_app_url = f"https://zaebanec.github.io/telegram_bot/?property_id={property_id}"

    # Кнопка для нового Web App календаря
    builder.button(text="📅 Забронировать", web_app=WebAppInfo(url=web_app_url))
    
    builder.adjust(1)
    
    return builder.as_markup()

def get_rating_keyboard(booking_id: int):
    builder = InlineKeyboardBuilder()
    for i in range(1, 6):
        builder.button(text=f"⭐️ {i}", callback_data=f"review:{booking_id}:rating:{i}")
    builder.adjust(5)
    return builder.as_markup()

async def get_calendar():
    """
    Возвращает стандартный календарь. Этот подход самый надежный
    для навигации по месяцам.
    """
    calendar = SimpleCalendar()
    calendar.set_dates_range(datetime.now(), datetime.now() + timedelta(days=365))
    return await calendar.start_calendar()


# --- КЛАВИАТУРЫ ДЛЯ ВЛАДЕЛЬЦА И ОБЩИЕ ДЛЯ ДИАЛОГОВ ---
def get_region_keyboard():
    builder = InlineKeyboardBuilder()
    for region in DISTRICTS.keys():
        builder.button(text=region, callback_data=f"add_property_region:{region}")
    builder.adjust(2)
    return builder.as_markup()

def get_district_keyboard(region: str):
    builder = InlineKeyboardBuilder()
    builder.button(text=f"➡️ Все варианты в '{region}'", callback_data=f"search_all_in_region:{region}")
    for index, district_name in enumerate(DISTRICTS[region]):
        builder.button(text=district_name, callback_data=f"add_prop_dist:{region}:{index}")
    builder.button(text="🔙 Назад", callback_data="back_to_regions")
    builder.adjust(1)
    return builder.as_markup()

def get_rooms_keyboard():
    builder = InlineKeyboardBuilder()
    for option in ROOM_OPTIONS:
        builder.button(text=option, callback_data=f"add_property_rooms:{option}")
    builder.adjust(3)
    return builder.as_markup()

def get_guests_keyboard():
    builder = InlineKeyboardBuilder()
    for option in GUEST_OPTIONS:
        builder.button(text=option, callback_data=f"add_property_guests:{option}")
    builder.adjust(4)
    return builder.as_markup()

def get_property_types_keyboard():
    builder = InlineKeyboardBuilder()
    for prop_type in PROPERTY_TYPES:
        builder.button(text=prop_type, callback_data=f"add_property_type:{prop_type}")
    builder.adjust(2)
    return builder.as_markup()

def get_property_management_keyboard(property_id: int, is_active: bool):
    builder = InlineKeyboardBuilder()
    if is_active:
        builder.button(text="🔴 Скрыть", callback_data=f"manage:toggle:{property_id}")
    else:
        builder.button(text="🟢 Активировать", callback_data=f"manage:toggle:{property_id}")
    builder.button(text="✏️ Редактировать", callback_data=f"manage:edit:{property_id}")
    builder.button(text="🗑️ Удалить", callback_data=f"manage:delete:{property_id}")
    builder.adjust(2, 1)
    return builder.as_markup()

def get_delete_confirmation_keyboard(property_id: int):
    builder = InlineKeyboardBuilder()
    builder.button(text="✅ Да, удалить", callback_data=f"manage:delete_confirm:{property_id}")
    builder.button(text="❌ Отмена", callback_data=f"manage:delete_cancel")
    return builder.as_markup()

def get_edit_property_keyboard(property_id: int):
    builder = InlineKeyboardBuilder()
    builder.button(text="Название", callback_data=f"edit_prop:title:{property_id}")
    builder.button(text="Описание", callback_data=f"edit_prop:description:{property_id}")
    builder.button(text="Локацию", callback_data=f"edit_prop:location:{property_id}")
    builder.button(text="Адрес", callback_data=f"edit_prop:address:{property_id}")
    builder.button(text="Кол-во комнат", callback_data=f"edit_prop:rooms:{property_id}")
    builder.button(text="Цену", callback_data=f"edit_prop:price:{property_id}")
    builder.button(text="Кол-во гостей", callback_data=f"edit_prop:guests:{property_id}")
    builder.button(text="Тип объекта", callback_data=f"edit_prop:type:{property_id}")
    builder.button(text="📸 Управлять фото/видео", callback_data=f"edit_prop:media:{property_id}")
    
    # ИСПРАВЛЕНИЕ: Вставляем новую ссылку
    owner_web_app_url = f"https://zaebanec.github.io/telegram_bot/owner.html?property_id={property_id}"
    builder.button(text="🗓️ Управлять доступностью", web_app=WebAppInfo(url=owner_web_app_url))
    
    builder.button(text="🔙 Назад к списку", callback_data="back_to_my_properties")
    builder.adjust(2, 2, 2, 2, 2, 1)
    return builder.as_markup()

def get_delete_one_media_keyboard(media_id: int):
    builder = InlineKeyboardBuilder()
    builder.button(text="🗑️ Удалить это медиа", callback_data=f"edit_media:delete:{media_id}")
    return builder.as_markup()

def get_media_management_keyboard(property_id: int):
    builder = InlineKeyboardBuilder()
    builder.button(text="➕ Добавить еще фото/видео", callback_data=f"edit_media:add:{property_id}")
    builder.button(text="✅ Готово", callback_data=f"edit_media:done:{property_id}")
    builder.adjust(1)
    return builder.as_markup()

def get_finish_upload_keyboard():
    return ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="Завершить загрузку")], [KeyboardButton(text="Отмена")]], resize_keyboard=True)

def get_skip_video_keyboard():
    return ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="Пропустить этот шаг")], [KeyboardButton(text="Отмена")]], resize_keyboard=True, one_time_keyboard=True)

def get_booking_management_keyboard(booking_id: int):
    builder = InlineKeyboardBuilder()
    builder.button(text="✅ Принять", callback_data=f"booking:confirm:{booking_id}")
    builder.button(text="❌ Отклонить", callback_data=f"booking:reject:{booking_id}")
    builder.adjust(2)
    return builder.as_markup()


--------------------------------------------------------------------------------
--- FILE: app/utils/__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--- FILE: app/utils/states.py
--------------------------------------------------------------------------------
from aiogram.fsm.state import State, StatesGroup

class AddProperty(StatesGroup):
    title = State()
    description = State()
    region = State()
    district = State()
    address = State()
    rooms = State()
    price_per_night = State()
    max_guests = State()
    property_type = State()
    photos = State()
    video_note = State()
    
class SearchProperties(StatesGroup):
    region = State()
    district = State()
    price = State()
    guests = State()

class EditProperty(StatesGroup):
    choosing_field = State()
    editing_title = State()
    editing_description = State()
    editing_address = State()
    editing_region = State()
    editing_district = State()
    editing_rooms = State()
    editing_price = State()
    editing_guests = State()
    editing_type = State()
    managing_media = State()
    adding_photos = State()
    managing_availability = State() # Новое состояние

class LeaveReview(StatesGroup):
    waiting_for_rating = State()
    waiting_for_comment = State()

class BookingFlow(StatesGroup):
    choosing_checkin_date = State()
    choosing_checkout_date = State()

--------------------------------------------------------------------------------
--- FILE: app/models/models.py
--------------------------------------------------------------------------------
from datetime import datetime
from sqlalchemy import (BigInteger, Boolean, Column, DateTime, ForeignKey,
                        Integer, String, Text, func, Date)
from sqlalchemy.orm import relationship, Mapped
from .base import Base

class User(Base):
    __tablename__ = 'users'
    telegram_id = Column(BigInteger, primary_key=True)
    username = Column(String(32), unique=True, nullable=True)
    first_name = Column(String(64), nullable=False)
    created_at = Column(DateTime, server_default=func.now())
    role = Column(String(20), default='user', nullable=False)

    bookings = relationship('Booking', back_populates='user')
    properties = relationship('Property', back_populates='owner')
    reviews = relationship('Review', back_populates='user')

    __table_args__ = {'schema': 'public'}


class Property(Base):
    __tablename__ = 'properties'
    owner_id = Column(BigInteger, ForeignKey('public.users.telegram_id'), nullable=False)
    id = Column(Integer, primary_key=True)
    title = Column(String(100), nullable=False)
    description = Column(Text, nullable=True)
    address = Column(String(255), nullable=False)
    district = Column(String(50), nullable=False)
    rooms = Column(Integer, nullable=False)
    price_per_night = Column(Integer, nullable=False) 
    max_guests = Column(Integer, default=1, nullable=False)
    property_type = Column(String(50), nullable=False)
    is_verified = Column(Boolean, default=False, nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime, server_default=func.now())

    owner = relationship('User', back_populates='properties')
    media = relationship('PropertyMedia', back_populates='property', cascade="all, delete-orphan")
    bookings = relationship('Booking', back_populates='property', cascade="all, delete-orphan")
    reviews = relationship('Review', back_populates='property', cascade="all, delete-orphan")
    unavailable_dates = relationship('UnavailableDate', back_populates='property', cascade="all, delete-orphan")
    price_rules = relationship('PriceRule', back_populates='property', cascade="all, delete-orphan")

    __table_args__ = {'schema': 'public'}


class PropertyMedia(Base):
    __tablename__ = 'property_media'
    property_id = Column(Integer, ForeignKey('public.properties.id'), nullable=False)
    id = Column(Integer, primary_key=True)
    file_id = Column(String(255), nullable=False)
    media_type = Column(String(10), nullable=False)
    property = relationship('Property', back_populates='media')
    __table_args__ = {'schema': 'public'}


class Booking(Base):
    __tablename__ = 'bookings'
    id = Column(Integer, primary_key=True)
    property_id = Column(Integer, ForeignKey('public.properties.id'), nullable=False)
    user_id = Column(BigInteger, ForeignKey('public.users.telegram_id'), nullable=False)
    start_date = Column(DateTime, nullable=False)
    end_date = Column(DateTime, nullable=False)
    status = Column(String(20), default='pending', nullable=False)
    created_at = Column(DateTime, server_default=func.now())

    user = relationship('User', back_populates='bookings')
    property = relationship('Property', back_populates='bookings')
    review = relationship('Review', back_populates='booking', uselist=False, cascade="all, delete-orphan")

    __table_args__ = {'schema': 'public'}


class Review(Base):
    __tablename__ = 'reviews'
    id = Column(Integer, primary_key=True)
    property_id = Column(Integer, ForeignKey('public.properties.id'), nullable=False)
    user_id = Column(BigInteger, ForeignKey('public.users.telegram_id'), nullable=False)
    booking_id = Column(Integer, ForeignKey('public.bookings.id'), unique=True, nullable=False)
    rating = Column(Integer, nullable=False)
    text = Column(Text, nullable=True)
    created_at = Column(DateTime, server_default=func.now())

    property = relationship('Property', back_populates='reviews')
    user = relationship('User', back_populates='reviews')
    booking = relationship('Booking', back_populates='review')
    
    __table_args__ = {'schema': 'public'}


class UnavailableDate(Base):
    __tablename__ = 'unavailable_dates'
    id = Column(Integer, primary_key=True)
    property_id = Column(Integer, ForeignKey('public.properties.id'), nullable=False)
    date = Column(Date, nullable=False)
    comment = Column(String(100), nullable=True) # Поле для комментария

    property = relationship('Property', back_populates='unavailable_dates')

    __table_args__ = {'schema': 'public'}


class PriceRule(Base):
    __tablename__ = 'price_rules'
    id = Column(Integer, primary_key=True)
    property_id = Column(Integer, ForeignKey('public.properties.id'), nullable=False)
    start_date = Column(Date, nullable=False)
    end_date = Column(Date, nullable=False)
    price = Column(Integer, nullable=False)

    property = relationship('Property', back_populates='price_rules')
    __table_args__ = {'schema': 'public'}



--------------------------------------------------------------------------------
--- FILE: app/models/__init__.py
--------------------------------------------------------------------------------
# Этот файл собирает все модели из папки models
# Чтобы SQLAlchemy и Alembic могли их легко найти.

from .base import Base
from .models import User, Property, PropertyMedia, Booking

--------------------------------------------------------------------------------
--- FILE: app/models/base.py
--------------------------------------------------------------------------------
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    pass

--------------------------------------------------------------------------------
--- FILE: app/static/index.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Бронирование</title>
    <style>
        :root {
            --tg-bg: var(--tg-theme-bg-color, #ffffff);
            --tg-text: var(--tg-theme-text-color, #222222);
            --tg-hint: var(--tg-theme-hint-color, #999999);
            --tg-button: var(--tg-theme-button-color, #2481cc);
            --tg-button-text: var(--tg-theme-button-text-color, #ffffff);
            --tg-secondary-bg: var(--tg-theme-secondary-bg-color, #f1f1f1);
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--tg-bg);
            color: var(--tg-text);
            margin: 0;
            padding: 15px;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
            /* Разрешаем скроллинг для всего тела страницы */
        }
        .calendar-month-container {
            margin-bottom: 25px;
        }
        .calendar-header {
            text-align: center;
            padding: 10px 5px;
        }
        .calendar-month-year {
            font-weight: 600;
            font-size: 18px;
        }
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
        }
        .calendar-day, .calendar-weekday {
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            border-radius: 50%;
        }
        .calendar-weekday {
             height: 30px;
             color: var(--tg-hint);
             font-size: 12px;
        }
        .calendar-day {
            cursor: pointer;
            border: 1px solid transparent;
            transition: background-color 0.2s, color 0.2s;
            flex-direction: column;
            padding: 2px 0;
            height: 44px;
        }
        .day-number {
            font-size: 15px;
            font-weight: 500;
        }
        .day-price {
            font-size: 9px;
            color: var(--tg-hint);
        }
        .calendar-day:not(.disabled):hover {
            background-color: var(--tg-secondary-bg);
        }
        .calendar-day.selected, .calendar-day.start-range, .calendar-day.end-range {
            background-color: var(--tg-button);
            color: var(--tg-button-text);
            border-color: var(--tg-button);
        }
        .calendar-day.selected .day-price, .calendar-day.start-range .day-price, .calendar-day.end-range .day-price {
            color: var(--tg-button-text);
        }
        .calendar-day.in-range {
            background-color: var(--tg-secondary-bg);
            color: var(--tg-text);
            border-radius: 0;
        }
        .calendar-day.disabled {
            color: var(--tg-hint);
            cursor: not-allowed;
            opacity: 0.6;
        }
        .calendar-day.disabled .day-number {
            text-decoration: line-through;
        }
        .calendar-day.padding {
            visibility: hidden;
        }
        .sticky-footer {
            position: sticky;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 15px;
            background-color: var(--tg-bg);
            box-shadow: 0 -5px 15px -5px rgba(0,0,0,0.1);
        }
        .info-panel {
            text-align: center;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            background-color: var(--tg-secondary-bg);
            margin-bottom: 15px;
        }
        #confirm-button {
            font-family: inherit;
            font-weight: 600;
            font-size: 16px;
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background-color: var(--tg-button);
            color: var(--tg-button-text);
        }
        #confirm-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>

    <div id="calendar-body">
        <!-- Сюда будут добавляться месяцы -->
    </div>

    <div class="sticky-footer">
        <div class="info-panel" id="info-panel">Загрузка...</div>
        <button id="confirm-button" disabled>Подтвердить</button>
    </div>


    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const tg = window.Telegram.WebApp;
            tg.ready();
            tg.expand();

            const calendarBody = document.getElementById('calendar-body');
            const infoPanel = document.getElementById('info-panel');
            const confirmButton = document.getElementById('confirm-button');
            
            let currentMonth = new Date().getMonth();
            let currentYear = new Date().getFullYear();
            let calendarData = {}; 
            let checkinDate = null;
            let checkoutDate = null;
            let isLoading = false; // Флаг для предотвращения множественных загрузок

            const monthNames = ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"];
            const dayNames = ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"];

            function fetchAndRenderMonth(year, month) {
                if (isLoading) return;
                isLoading = true;

                const API_BASE_URL = "https://4ec5-162-19-62-155.ngrok-free.app";
                const urlParams = new URLSearchParams(window.location.search);
                const propertyId = urlParams.get('property_id');
                if (!propertyId) {
                    infoPanel.textContent = "Ошибка: не найден ID объекта.";
                    return;
                }

                const fetchUrl = `${API_BASE_URL}/api/calendar_data/${propertyId}?year=${year}&month=${month + 1}`;
                
                fetch(fetchUrl, { headers: { 'ngrok-skip-browser-warning': 'true' } })
                    .then(response => {
                        if (!response.ok) throw new Error('Ошибка сети');
                        return response.json();
                    })
                    .then(data => {
                        data.forEach(dayInfo => {
                            calendarData[dayInfo.date] = {
                                status: dayInfo.status,
                                price: dayInfo.price
                            };
                        });
                        renderMonth(year, month);
                        isLoading = false;
                        updateUI();
                    })
                    .catch(error => {
                        console.error('Fetch Error:', error);
                        infoPanel.textContent = "Ошибка загрузки данных.";
                        isLoading = false;
                    });
            }
            
            function renderMonth(year, month) {
                const monthContainer = document.createElement('div');
                monthContainer.className = 'calendar-month-container';

                // Заголовок месяца
                const header = document.createElement('div');
                header.className = 'calendar-header';
                const monthYearLabel = document.createElement('span');
                monthYearLabel.className = 'calendar-month-year';
                monthYearLabel.textContent = `${monthNames[month]} ${year}`;
                header.appendChild(monthYearLabel);
                monthContainer.appendChild(header);

                // Дни недели
                const weekdaysGrid = document.createElement('div');
                weekdaysGrid.className = 'calendar-grid';
                dayNames.forEach(day => {
                    const dayEl = document.createElement('div');
                    dayEl.className = 'calendar-weekday';
                    dayEl.textContent = day;
                    weekdaysGrid.appendChild(dayEl);
                });
                monthContainer.appendChild(weekdaysGrid);

                // Сетка дат
                const calendarGrid = document.createElement('div');
                calendarGrid.className = 'calendar-grid';
                
                const firstDayOfMonth = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                const startingDay = (firstDayOfMonth === 0) ? 6 : firstDayOfMonth - 1;

                for (let i = 0; i < startingDay; i++) {
                    const paddingDay = document.createElement('div');
                    paddingDay.className = 'calendar-day padding';
                    calendarGrid.appendChild(paddingDay);
                }

                for (let day = 1; day <= daysInMonth; day++) {
                    const dayEl = document.createElement('div');
                    dayEl.className = 'calendar-day';
                    
                    const dayNumber = document.createElement('div');
                    dayNumber.className = 'day-number';
                    dayNumber.textContent = day;
                    dayEl.appendChild(dayNumber);

                    const currentDate = new Date(year, month, day);
                    const currentDateStr = currentDate.toISOString().split('T')[0];
                    const dayData = calendarData[currentDateStr];

                    if (dayData) {
                        if (dayData.status !== 'available') {
                            dayEl.classList.add('disabled');
                        } else {
                            dayEl.dataset.date = currentDateStr;
                            dayEl.addEventListener('click', onDayClick);

                            const dayPrice = document.createElement('div');
                            dayPrice.className = 'day-price';
                            dayPrice.textContent = dayData.price ? `${dayData.price}` : '';
                            dayEl.appendChild(dayPrice);
                        }
                    }
                    
                    if (checkinDate && checkoutDate) {
                        const checkin = new Date(checkinDate);
                        const checkout = new Date(checkoutDate);
                        if (currentDate >= checkin && currentDate <= checkout) {
                            dayEl.classList.add('in-range');
                            if (currentDate.getTime() === checkin.getTime()) dayEl.classList.add('start-range');
                            if (currentDate.getTime() === checkout.getTime()) dayEl.classList.add('end-range');
                        }
                    } else if (checkinDate && currentDateStr === checkinDate) {
                        dayEl.classList.add('selected');
                    }
                    
                    calendarGrid.appendChild(dayEl);
                }
                monthContainer.appendChild(calendarGrid);
                calendarBody.appendChild(monthContainer);
            }
            
            function onDayClick(event) {
                const selectedDateStr = event.currentTarget.dataset.date;
                
                if (!checkinDate || (checkinDate && checkoutDate)) {
                    checkinDate = selectedDateStr;
                    checkoutDate = null;
                } else {
                    const selectedD = new Date(selectedDateStr);
                    const checkinD = new Date(checkinDate);
                    
                    if (selectedD > checkinD) {
                        checkoutDate = selectedDateStr;
                    } else {
                        checkinDate = selectedDateStr;
                        checkoutDate = null;
                    }
                }
                updateUI();
            }

            function updateAllRenderedMonths() {
                const existingMonths = calendarBody.querySelectorAll('.calendar-month-container');
                existingMonths.forEach(month => month.remove());
                
                // Перерисовываем все загруженные месяцы с обновленными стилями
                for (const dateStr in calendarData) {
                    const d = new Date(dateStr);
                    // Логика, чтобы не рисовать один и тот же месяц дважды
                    if (document.querySelector(`[data-year='${d.getFullYear()}'][data-month='${d.getMonth()}']`) === null) {
                         renderMonth(d.getFullYear(), d.getMonth());
                         const monthDiv = calendarBody.lastChild;
                         monthDiv.dataset.year = d.getFullYear();
                         monthDiv.dataset.month = d.getMonth();
                    }
                }
            }

            function updateUI() {
                updateAllRenderedMonths();
                if (!checkinDate) {
                    infoPanel.textContent = 'Выберите дату заезда';
                    confirmButton.disabled = true;
                } else if (!checkoutDate) {
                    infoPanel.textContent = `Заезд: ${formatDate(checkinDate)}. Выберите дату выезда.`;
                    confirmButton.disabled = true;
                } else {
                    const { total, nights } = calculateTotal();
                    infoPanel.textContent = `Итого за ${nights} ночей: ${total} руб.`;
                    confirmButton.disabled = false;
                }
            }
            
            function calculateTotal() {
                let total = 0;
                let nights = 0;
                const start = new Date(checkinDate);
                const end = new Date(checkoutDate);

                for (let d = new Date(start); d < end; d.setDate(d.getDate() + 1)) {
                    const dateStr = d.toISOString().split('T')[0];
                    if (calendarData[dateStr] && calendarData[dateStr].price) {
                        total += calendarData[dateStr].price;
                        nights++;
                    }
                }
                return { total, nights };
            }

            function formatDate(dateStr) {
                const [year, month, day] = dateStr.split('-');
                return `${day}.${month}`;
            }

            window.addEventListener('scroll', () => {
                if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - 100) {
                   currentMonth++;
                   if (currentMonth > 11) {
                       currentMonth = 0;
                       currentYear++;
                   }
                   fetchAndRenderMonth(currentYear, currentMonth);
                }
            });

            confirmButton.addEventListener('click', () => {
                if (checkinDate && checkoutDate) {
                    const { total } = calculateTotal();
                    const dataToSend = {
                        property_id: new URLSearchParams(window.location.search).get('property_id'),
                        checkin_date: checkinDate,
                        checkout_date: checkoutDate,
                        total_price: total
                    };
                    tg.sendData(JSON.stringify(dataToSend));
                    tg.close();
                }
            });

            function main() {
                // Загружаем первые 3 месяца при старте
                fetchAndRenderMonth(currentYear, currentMonth);
                let nextMonth = currentMonth + 1, nextYear = currentYear;
                if (nextMonth > 11) { nextMonth = 0; nextYear++; }
                fetchAndRenderMonth(nextYear, nextMonth);
            }

            main();
        });
    </script>
</body>
</html>

--------------------------------------------------------------------------------
--- FILE: app/static/owner.js
--------------------------------------------------------------------------------
document.addEventListener('DOMContentLoaded', () => {
    // Инициализация Telegram Web App
    const tg = window.Telegram.WebApp;
    tg.expand();

    // --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ И ЭЛЕМЕНТЫ DOM ---
    const calendarGrid = document.getElementById('calendar-grid');
    const monthYearHeader = document.getElementById('month-year');
    const prevMonthBtn = document.getElementById('prev-month');
    const nextMonthBtn = document.getElementById('next-month');
    const loader = document.getElementById('loader');

    // Извлекаем property_id из URL
    const urlParams = new URLSearchParams(window.location.search);
    const propertyId = urlParams.get('property_id');

    // Если ID объекта не найден, показываем ошибку
    if (!propertyId) {
        calendarGrid.innerHTML = '<p style="color: red; grid-column: 1 / 8;">Ошибка: ID объекта не указан в URL.</p>';
        return;
    }

    // Состояние приложения
    let current = new Date();
    let selection = { start: null, end: null };
    let isMouseDown = false;
    // URL вашего сервера (замените на реальный, если он отличается)
    const API_BASE_URL = 'https://9845-94-140-141-218.ngrok-free.app';


    // --- ОСНОВНЫЕ ФУНКЦИИ ---

    /**
     * Показывает или скрывает индикатор загрузки
     * @param {boolean} visible - Показать (true) или скрыть (false)
     */
    function setLoaderVisible(visible) {
        if (visible) {
            loader.classList.add('visible');
        } else {
            loader.classList.remove('visible');
        }
    }

    /**
     * Запрашивает данные календаря с сервера
     * @param {number} year - Год
     * @param {number} month - Месяц (1-12)
     */
    async function fetchAndRenderCalendar(year, month) {
        setLoaderVisible(true);
        try {
            const response = await fetch(`${API_BASE_URL}/api/calendar_data/${propertyId}?year=${year}&month=${month}`);
            if (!response.ok) {
                throw new Error(`Ошибка сети: ${response.statusText}`);
            }
            const data = await response.json();
            renderCalendar(year, month, data);
        } catch (error) {
            console.error('Не удалось загрузить данные календаря:', error);
            tg.showAlert(`Ошибка загрузки данных: ${error.message}`);
        } finally {
            setLoaderVisible(false);
        }
    }

    /**
     * Отрисовывает календарь на основе полученных данных
     * @param {number} year - Год
     * @param {number} month - Месяц (1-12)
     * @param {Array} daysData - Массив данных о днях
     */
    function renderCalendar(year, month, daysData) {
        monthYearHeader.textContent = new Date(year, month - 1).toLocaleString('ru-RU', { month: 'long', year: 'numeric' });
        
        // Очищаем предыдущие ячейки
        const dayCells = calendarGrid.querySelectorAll('.day-cell');
        dayCells.forEach(cell => cell.remove());

        const firstDayOfMonth = new Date(year, month - 1, 1).getDay();
        const daysInMonth = new Date(year, month, 0).getDate();
        // Корректируем, чтобы неделя начиналась с понедельника (0 = Пн, 6 = Вс)
        const dayOfWeekOffset = (firstDayOfMonth === 0) ? 6 : firstDayOfMonth - 1;

        // Добавляем пустые ячейки для дней предыдущего месяца
        for (let i = 0; i < dayOfWeekOffset; i++) {
            const emptyCell = document.createElement('div');
            emptyCell.className = 'day-cell empty';
            calendarGrid.appendChild(emptyCell);
        }

        // Добавляем ячейки для каждого дня месяца
        daysData.forEach(day => {
            const cell = document.createElement('div');
            cell.className = 'day-cell';
            cell.dataset.date = day.date; // e.g., "2024-12-25"

            // Номер дня
            const dayNumber = document.createElement('span');
            dayNumber.className = 'day-number';
            dayNumber.textContent = new Date(day.date).getDate();
            cell.appendChild(dayNumber);

            // Цена (если есть)
            if (day.price !== null) {
                const dayPrice = document.createElement('span');
                dayPrice.className = 'day-price';
                dayPrice.textContent = `${day.price}₽`;
                cell.appendChild(dayPrice);
            }
            
            // Комментарий (если есть)
            if (day.comment) {
                const dayComment = document.createElement('span');
                dayComment.className = 'day-comment';
                dayComment.textContent = '●';
                dayComment.title = day.comment; // Всплывающая подсказка
                cell.appendChild(dayComment);
            }

            // Добавляем классы в зависимости от статуса
            cell.classList.add(day.status);
            
            // Если дата уже выбрана, подсвечиваем ее
            if (isDateInSelection(new Date(day.date))) {
                 cell.classList.add('selected');
            }

            calendarGrid.appendChild(cell);
        });
    }

    /**
     * Проверяет, находится ли дата в текущем выделенном диапазоне
     */
    function isDateInSelection(date) {
        if (!selection.start) return false;
        const normalizedDate = new Date(date.setHours(0,0,0,0));
        const startDate = new Date(selection.start.setHours(0,0,0,0));
        const endDate = selection.end ? new Date(selection.end.setHours(0,0,0,0)) : startDate;

        return normalizedDate >= startDate && normalizedDate <= endDate;
    }
    
    /**
     * Обновляет подсветку выделенных ячеек
     */
    function updateSelectionHighlight() {
        document.querySelectorAll('.day-cell[data-date]').forEach(cell => {
            const cellDate = new Date(cell.dataset.date + 'T00:00:00'); // Устанавливаем время для корректного сравнения
            if (isDateInSelection(cellDate)) {
                cell.classList.add('selected');
            } else {
                cell.classList.remove('selected');
            }
        });
    }


    // --- ОБРАБОТЧИКИ СОБЫТИЙ ---

    // Клик на кнопку "Предыдущий месяц"
    prevMonthBtn.addEventListener('click', () => {
        current.setMonth(current.getMonth() - 1);
        fetchAndRenderCalendar(current.getFullYear(), current.getMonth() + 1);
    });

    // Клик на кнопку "Следующий месяц"
    nextMonthBtn.addEventListener('click', () => {
        current.setMonth(current.getMonth() + 1);
        fetchAndRenderCalendar(current.getFullYear(), current.getMonth() + 1);
    });

    // --- ЛОГИКА ВЫДЕЛЕНИЯ ДАТ ---

    calendarGrid.addEventListener('mousedown', (e) => {
        const cell = e.target.closest('.day-cell');
        if (!cell || !cell.dataset.date || cell.classList.contains('past') || cell.classList.contains('booked')) return;
        
        isMouseDown = true;
        const clickedDate = new Date(cell.dataset.date + 'T00:00:00');
        
        // Логика сброса/установки выделения
        if (selection.start && !selection.end && clickedDate.getTime() === selection.start.getTime()){
            // Клик на уже выделенную единственную дату - снимает выделение
            selection.start = null;
        } else if (selection.start && selection.end) {
             // Если был выделен диапазон, сбрасываем и начинаем новый
             selection.start = clickedDate;
             selection.end = null;
        } else {
            // Начинаем выделение
            selection.start = clickedDate;
            selection.end = null;
        }
        
        updateSelectionHighlight();
        showActionPopup();
    });

    calendarGrid.addEventListener('mouseover', (e) => {
        if (!isMouseDown || !selection.start) return;
        const cell = e.target.closest('.day-cell');
        if (!cell || !cell.dataset.date || cell.classList.contains('past') || cell.classList.contains('booked')) return;

        const hoverDate = new Date(cell.dataset.date + 'T00:00:00');
        
        // Устанавливаем конец диапазона, обеспечивая правильный порядок дат
        if (hoverDate >= selection.start) {
            selection.end = hoverDate;
        } else {
            // Если ведем мышь назад, начальная дата становится конечной
            selection.end = selection.start;
            selection.start = hoverDate;
        }
        updateSelectionHighlight();
    });
    
    // Отпускаем кнопку мыши в любом месте окна
    window.addEventListener('mouseup', () => {
        if (isMouseDown) {
            isMouseDown = false;
            // Если выделение не сброшено, показываем меню действий
            if (selection.start) {
                showActionPopup();
            }
        }
    });

    // --- ФУНКЦИИ ДЕЙСТВИЙ С ДАТАМИ ---
    
    /**
     * Показывает всплывающее окно с действиями для выделенных дат
     */
    function showActionPopup() {
        if (!selection.start) return;

        const isSingleDate = !selection.end || selection.start.getTime() === selection.end.getTime();
        const targetDate = selection.start;
        const dateString = targetDate.toLocaleDateString('ru-RU');
        
        const cell = document.querySelector(`.day-cell[data-date='${targetDate.toISOString().split('T')[0]}']`);
        const currentStatus = cell ? (cell.classList.contains('manual-block') ? 'manual_block' : 'available') : 'available';

        if (isSingleDate) {
            // --- Меню для одной даты ---
            const actionText = currentStatus === 'manual_block' ? `Разблокировать ${dateString}` : `Заблокировать ${dateString}`;
            const commentText = currentStatus === 'manual_block' ? ` (комментарий: ${cell.querySelector('.day-comment')?.title || 'нет'})` : '';

            tg.showPopup({
                title: 'Действие с датой',
                message: `Выбрана дата: ${dateString}${commentText}.`,
                buttons: [
                    { id: 'toggle_block', type: 'default', text: actionText },
                    { id: 'set_price', type: 'default', text: 'Установить цену' },
                    { type: 'cancel' },
                ]
            }, (buttonId) => handlePopupAction(buttonId));

        } else {
            // --- Меню для диапазона ---
            const startDateStr = selection.start.toLocaleDateString('ru-RU');
            const endDateStr = selection.end.toLocaleDateString('ru-RU');

            tg.showPopup({
                title: 'Действия с диапазоном',
                message: `Выбран диапазон: ${startDateStr} - ${endDateStr}.`,
                buttons: [
                    { id: 'set_price_range', type: 'default', text: 'Установить цену' },
                    { type: 'cancel' },
                ]
            }, (buttonId) => handlePopupAction(buttonId));
        }
    }
    
    /**
     * Обрабатывает выбор в кастомном popup
     */
    function handlePopupAction(buttonId) {
        if (!buttonId) { // Если закрыли popup без выбора
            selection.start = null;
            selection.end = null;
            updateSelectionHighlight();
            return;
        }
        
        switch (buttonId) {
            case 'toggle_block':
                handleToggleBlock();
                break;
            case 'set_price':
            case 'set_price_range':
                handleSetPrice();
                break;
        }
    }

    /**
     * Обрабатывает блокировку/разблокировку даты
     */
    async function handleToggleBlock() {
        const dateToToggle = selection.start.toISOString().split('T')[0];
        const cell = document.querySelector(`.day-cell[data-date='${dateToToggle}']`);
        const isBlocking = !cell.classList.contains('manual-block');
        let comment = null;

        if (isBlocking) {
            // Вместо showPopup используем нативный prompt, который работает везде
            comment = prompt("Введите причину блокировки (необязательно):", "");
        }

        setLoaderVisible(true);
        try {
            const response = await fetch(`${API_BASE_URL}/api/owner/toggle_availability`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ property_id: propertyId, date: dateToToggle, comment: comment })
            });
            if (!response.ok) throw new Error('Ошибка сервера при блокировке даты.');
            tg.showPopup({title: 'Успех', message: `Дата ${dateToToggle} успешно ${isBlocking ? 'заблокирована' : 'разблокирована'}.`});
        } catch (error) {
            tg.showAlert(`Ошибка: ${error.message}`);
        } finally {
            selection.start = null;
            selection.end = null;
            fetchAndRenderCalendar(current.getFullYear(), current.getMonth() + 1); // Перерисовываем календарь
        }
    }

    /**
     * Обрабатывает установку цены
     */
    async function handleSetPrice() {
        const price = prompt("Введите новую цену для выбранного периода:", "5000");
        if (price === null || isNaN(parseInt(price)) || parseInt(price) <= 0) {
            if (price !== null) tg.showAlert("Пожалуйста, введите корректное число больше нуля.");
            selection.start = null;
            selection.end = null;
            updateSelectionHighlight();
            return;
        }

        const startDate = selection.start.toISOString().split('T')[0];
        const endDate = (selection.end || selection.start).toISOString().split('T')[0];
        
        setLoaderVisible(true);
        try {
            const response = await fetch(`${API_BASE_URL}/api/owner/price_rule`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    property_id: propertyId,
                    start_date: startDate,
                    end_date: endDate,
                    price: parseInt(price)
                })
            });
            if (!response.ok) throw new Error('Ошибка сервера при установке цены.');
             tg.showPopup({title: 'Успех', message: `Цена ${price}₽ установлена для периода с ${startDate} по ${endDate}.`});
        } catch(error) {
            tg.showAlert(`Ошибка: ${error.message}`);
        } finally {
            selection.start = null;
            selection.end = null;
            fetchAndRenderCalendar(current.getFullYear(), current.getMonth() + 1);
        }
    }

    // --- ПЕРВЫЙ ЗАПУСК ---
    fetchAndRenderCalendar(current.getFullYear(), current.getMonth() + 1);
});



--------------------------------------------------------------------------------
--- FILE: app/static/owner.css
--------------------------------------------------------------------------------
/* --- ОБЩИЕ СТИЛИ --- */
:root {
    /* Цветовая палитра, основанная на теме Telegram */
    --tg-bg-color: var(--tg-theme-bg-color, #ffffff);
    --tg-text-color: var(--tg-theme-text-color, #000000);
    --tg-hint-color: var(--tg-theme-hint-color, #999999);
    --tg-link-color: var(--tg-theme-link-color, #2481cc);
    --tg-button-color: var(--tg-theme-button-color, #2481cc);
    --tg-button-text-color: var(--tg-theme-button-text-color, #ffffff);
    
    /* Дополнительные цвета для статусов */
    --color-available: #e0ffe0; /* Светло-зеленый */
    --color-booked: #f0f0f0; /* Серый */
    --color-manual-block: #ffe0e0; /* Светло-красный */
    --color-past: #e9e9e9; /* Светло-серый */
    --color-selected: #a0c4ff; /* Ярко-синий */
    --color-border: #dddddd;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    background-color: var(--tg-bg-color);
    color: var(--tg-text-color);
    margin: 0;
    padding: 15px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

/* --- КОНТЕЙНЕР ПРИЛОЖЕНИЯ --- */
#calendar-app {
    width: 100%;
    max-width: 500px;
    margin: 0 auto;
    background: var(--tg-bg-color);
    border-radius: 12px;
}

/* --- ЗАГОЛОВОК КАЛЕНДАРЯ --- */
.calendar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 0;
    margin-bottom: 10px;
}

#month-year {
    font-size: 1.2em;
    font-weight: 600;
    color: var(--tg-text-color);
}

.nav-button {
    background-color: transparent;
    border: none;
    color: var(--tg-link-color);
    font-size: 24px;
    font-weight: bold;
    cursor: pointer;
    padding: 5px 15px;
    border-radius: 8px;
    transition: background-color 0.2s;
}

.nav-button:hover {
    background-color: rgba(0, 0, 0, 0.1);
}

/* --- СЕТКА КАЛЕНДАРЯ --- */
.calendar-grid {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 5px;
}

.day-name {
    font-weight: 600;
    font-size: 0.9em;
    text-align: center;
    color: var(--tg-hint-color);
    padding-bottom: 10px;
}

.day-cell {
    position: relative;
    aspect-ratio: 1 / 1; /* Делает ячейки квадратными */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border: 1px solid var(--color-border);
    border-radius: 8px;
    cursor: pointer;
    transition: transform 0.1s, background-color 0.2s;
    overflow: hidden; /* Скрывает все, что выходит за пределы ячейки */
}

.day-cell:hover {
    transform: scale(1.05);
}

.day-number {
    font-size: 1em;
    font-weight: 500;
}

.day-price {
    font-size: 0.7em;
    color: var(--tg-hint-color);
    margin-top: 2px;
}

.day-comment {
    position: absolute;
    bottom: 2px;
    right: 4px;
    font-size: 12px;
    font-weight: bold;
    color: #db4437;
}

/* --- СТАТУСЫ ДНЕЙ --- */
.day-cell.available { background-color: var(--color-available); }
.day-cell.booked { background-color: var(--color-booked); color: var(--tg-hint-color); cursor: not-allowed; }
.day-cell.manual-block { background-color: var(--color-manual-block); }
.day-cell.past { background-color: var(--color-past); color: var(--tg-hint-color); cursor: not-allowed; }
.day-cell.selected { background-color: var(--color-selected); border-color: var(--tg-link-color); }
.day-cell.empty { background-color: transparent; border: none; cursor: default; }
.day-cell.empty:hover { transform: none; }

/* --- ЛЕГЕНДА --- */
.legend {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 15px;
    margin-top: 20px;
    font-size: 0.8em;
    color: var(--tg-hint-color);
}

.legend-item {
    display: flex;
    align-items: center;
}

.color-box {
    width: 12px;
    height: 12px;
    border-radius: 3px;
    margin-right: 5px;
    border: 1px solid var(--color-border);
}
.color-box.available { background-color: var(--color-available); }
.color-box.booked { background-color: var(--color-booked); }
.color-box.manual-block { background-color: var(--color-manual-block); }
.color-box.selected { background-color: var(--color-selected); }


/* --- ИНДИКАТОР ЗАГРУЗКИ --- */
.loader-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(128, 128, 128, 0.5); /* Полупрозрачный фон */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    visibility: hidden; /* Скрыт по умолчанию */
    opacity: 0;
    transition: opacity 0.3s, visibility 0.3s;
}

.loader-overlay.visible {
    visibility: visible;
    opacity: 1;
}

.loader-spinner {
    border: 5px solid #f3f3f3;
    border-top: 5px solid var(--tg-button-color);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}


--------------------------------------------------------------------------------
--- FILE: app/static/owner.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Управление Календарем</title>
    <!-- Подключаем файл со стилями -->
    <link rel="stylesheet" href="owner.css">
    <!-- Подключаем скрипт Telegram Web App -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>

    <!-- Основной контейнер приложения -->
    <div id="calendar-app">
        <!-- Заголовок с навигацией по месяцам -->
        <div class="calendar-header">
            <button id="prev-month" class="nav-button">&lt;</button>
            <h2 id="month-year"></h2>
            <button id="next-month" class="nav-button">&gt;</button>
        </div>

        <!-- Контейнер для самого календаря -->
        <div id="calendar-grid" class="calendar-grid">
            <!-- Дни недели -->
            <div class="day-name">Пн</div>
            <div class="day-name">Вт</div>
            <div class="day-name">Ср</div>
            <div class="day-name">Чт</div>
            <div class="day-name">Пт</div>
            <div class="day-name">Сб</div>
            <div class="day-name">Вс</div>
            <!-- Ячейки для дней будут генерироваться здесь -->
        </div>

        <!-- Легенда для статусов дней -->
        <div class="legend">
            <div class="legend-item"><span class="color-box available"></span> - Свободно</div>
            <div class="legend-item"><span class="color-box booked"></span> - Забронировано</div>
            <div class="legend-item"><span class="color-box manual-block"></span> - Заблокировано</div>
            <div class="legend-item"><span class="color-box selected"></span> - Выбрано</div>
        </div>
    </div>

    <!-- Индикатор загрузки -->
    <div id="loader" class="loader-overlay">
        <div class="loader-spinner"></div>
    </div>

    <!-- Подключаем основной файл с логикой -->
    <script src="owner.js"></script>
</body>
</html>


--------------------------------------------------------------------------------
--- SKIPPED (binary or error): app/handlers/.DS_Store | Reason: 'utf-8' codec can't decode byte 0xff in position 1082: invalid start byte
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- FILE: app/handlers/owner_handlers.py
--------------------------------------------------------------------------------
from aiogram import Router
from .owner import add_property, manage_property, edit_property

owner_router = Router()

owner_router.include_router(add_property.router)
owner_router.include_router(manage_property.router)
owner_router.include_router(edit_property.router)

--------------------------------------------------------------------------------
--- FILE: app/handlers/__init__.py
--------------------------------------------------------------------------------
from aiogram import Router

# Импортируем только три наших больших "агрегатора"
from .user_handlers import user_router
from .owner_handlers import owner_router
from .admin_handlers import router as admin_router

# Создаем главный роутер всего приложения
main_router = Router()

# Регистрируем в нем наши большие агрегаторы.
# Порядок важен: сначала админ, потом владелец, потом обычный пользователь.
main_router.include_router(admin_router)
main_router.include_router(owner_router)
main_router.include_router(user_router)

--------------------------------------------------------------------------------
--- FILE: app/handlers/user_handlers.py
--------------------------------------------------------------------------------
from aiogram import Router
from .user import common, search, booking, review

user_router = Router()

user_router.include_router(common.router)
user_router.include_router(search.router)
user_router.include_router(booking.router)
user_router.include_router(review.router)

--------------------------------------------------------------------------------
--- FILE: app/handlers/admin_handlers.py
--------------------------------------------------------------------------------
import logging
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo

from aiogram import Router, F, Bot
from aiogram.exceptions import TelegramAPIError
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery

# --- ИСПРАВЛЕНИЕ ЗДЕСЬ: Обновляем импорты ---
from src.services.property_service import set_property_verified
from src.services.booking_service import update_booking_status, get_booking_with_details
from src.services.user_service import set_user_role
from src.core.settings import settings
from src.core.scheduler import scheduler, request_review

router = Router()
# Фильтр гарантирует, что все обработчики в этом файле будут работать только для админов
router.message.filter(F.from_user.id.in_(settings.ADMIN_IDS))
router.callback_query.filter(F.from_user.id.in_(settings.ADMIN_IDS))


@router.message(Command("setrole"))
async def set_user_role_handler(message: Message):
    """
    Устанавливает роль пользователю.
    Формат: /setrole <user_id> <role>
    Роли: user, owner, admin
    """
    try:
        parts = message.text.split()
        if len(parts) != 3: raise ValueError()
        
        user_id = int(parts[1])
        role = parts[2].lower()

        if role not in ['user', 'owner', 'admin']:
            await message.answer("Неверная роль. Доступные роли: user, owner, admin.")
            return

        await set_user_role(user_id, role)
        await message.answer(f"Пользователю с ID {user_id} была успешно присвоена роль '{role}'.")

    except (IndexError, ValueError):
        await message.answer("Неверный формат команды. Используйте: /setrole <ID> <роль>")
    except Exception as e:
        await message.answer(f"Произошла ошибка: {e}")


@router.message(Command("verify"))
async def verify_property(message: Message):
    """
    Верифицирует объект по ID.
    Формат: /verify 123
    """
    try:
        property_id = int(message.text.split()[1])
        await set_property_verified(property_id, status=True)
        await message.answer(f"Объект с ID {property_id} был успешно верифицирован ✅.")
    except (IndexError, ValueError):
        await message.answer("Неверный формат команды. Используйте: /verify <ID объекта>")
    except Exception as e:
        await message.answer(f"Произошла ошибка: {e}")

@router.message(Command("unverify"))
async def unverify_property(message: Message):
    """
    Снимает верификацию с объекта по ID.
    Формат: /unverify 123
    """
    try:
        property_id = int(message.text.split()[1])
        await set_property_verified(property_id, status=False)
        await message.answer(f"С объекта с ID {property_id} была снята верификация.")
    except (IndexError, ValueError):
        await message.answer("Неверный формат команды. Используйте: /unverify <ID объекта>")


# --- Обработка заявок на бронирование ---

@router.callback_query(F.data.startswith("booking:confirm:"))
async def confirm_booking(callback: CallbackQuery, bot: Bot):
    """
    Обрабатывает нажатие на кнопку "Принять" заявку.
    """
    booking_id = int(callback.data.split(":")[2])
    
    await update_booking_status(booking_id, "confirmed")
    booking = await get_booking_with_details(booking_id)
    if not booking:
        await callback.answer("Бронирование не найдено.", show_alert=True)
        return

    await callback.message.edit_text(f"{callback.message.text}\n\n--- \n✅ ВЫ ПРИНЯЛИ ЭТУ ЗАЯВКУ ---")
    
    try:
        # Планируем отправку запроса на отзыв через 2 минуты
        run_date = datetime.now(ZoneInfo("Europe/Kaliningrad")) + timedelta(minutes=2)
        scheduler.add_job(
            request_review,
            'date',
            run_date=run_date,
            kwargs={
                "bot_token": settings.BOT_TOKEN.get_secret_value(),
                "chat_id": booking.user.telegram_id,
                "booking_id": booking.id,
                "property_title": booking.property.title
            }
        )
        logging.info(f"Запланирован запрос отзыва для бронирования {booking.id} на {run_date}")
    except Exception as e:
        logging.error(f"Ошибка при планировании запроса на отзыв: {e}")

    try:
        await bot.send_message(
            chat_id=booking.user.telegram_id,
            text=f"🎉 Ваша заявка на бронирование объекта «{booking.property.title}» была ОДОБРЕНА!\n\nВладелец скоро свяжется с вами для уточнения деталей."
        )
    except TelegramAPIError as e:
        logging.error(f"Telegram API Error при отправке уведомления арендатору: {e}")
        
    await callback.answer("Вы успешно приняли заявку!")


@router.callback_query(F.data.startswith("booking:reject:"))
async def reject_booking(callback: CallbackQuery, bot: Bot):
    """
    Обрабатывает нажатие на кнопку "Отклонить" заявку.
    """
    booking_id = int(callback.data.split(":")[2])
    
    await update_booking_status(booking_id, "rejected")
    booking = await get_booking_with_details(booking_id)
    if not booking:
        await callback.answer("Бронирование не найдено.", show_alert=True)
        return

    await callback.message.edit_text(f"{callback.message.text}\n\n--- \n❌ ВЫ ОТКЛОНИЛИ ЭТУ ЗАЯВКУ ---")

    try:
        await bot.send_message(
            chat_id=booking.user.telegram_id,
            text=f"😔 К сожалению, ваша заявка на бронирование объекта «{booking.property.title}» была ОТКЛОНЕНА."
        )
    except TelegramAPIError as e:
        logging.error(f"Telegram API Error при отправке уведомления арендатору: {e}")
        
    await callback.answer("Вы отклонили заявку.")

--------------------------------------------------------------------------------
--- FILE: app/handlers/owner/add_property.py
--------------------------------------------------------------------------------
import logging
from aiogram import F, Router
from aiogram.filters import Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery, ReplyKeyboardRemove

from src.utils.states import AddProperty
from src.services.user_service import get_user
from src.services.property_service import add_property
from src.services.media_service import add_photos_to_property, add_video_note_to_property

# --- ИСПРАВЛЕНИЕ ЗДЕСЬ: Указываем единственно верный файл с клавиатурами ---
from src.keyboards.inline_keyboards import (get_region_keyboard, get_district_keyboard, get_rooms_keyboard, 
                                           get_property_types_keyboard, get_guests_keyboard, 
                                           get_finish_upload_keyboard, get_skip_video_keyboard)
from src.core.constants import DISTRICTS

router = Router()

# --- Начало диалога ---
@router.callback_query(F.data == "main_menu:add_property")
async def add_property_callback(callback: CallbackQuery, state: FSMContext):
    user = await get_user(callback.from_user.id)
    if not user or user.role not in ['owner', 'admin']:
        await callback.answer("Эта функция доступна только владельцам объектов.", show_alert=True)
        return
        
    await callback.message.edit_text("Начинаем. Введите броское название вашего объекта (например, 'Лофт с видом на Кафедральный собор').")
    await state.set_state(AddProperty.title)
    await callback.answer()

@router.message(Command("addproperty"))
async def add_property_start(message: Message, state: FSMContext):
    user = await get_user(message.from_user.id)
    if not user or user.role not in ['owner', 'admin']:
        await message.answer("Эта функция доступна только владельцам объектов.")
        return
        
    await message.answer("Начинаем. Введите броское название вашего объекта (например, 'Лофт с видом на Кафедральный собор').")
    await state.set_state(AddProperty.title)


# --- Основная цепочка диалога ---

@router.message(AddProperty.title)
async def add_property_title(message: Message, state: FSMContext):
    await state.update_data(title=message.text)
    await message.answer("Отлично. Теперь добавьте яркое описание, расскажите о преимуществах.")
    await state.set_state(AddProperty.description)

@router.message(AddProperty.description)
async def add_property_description(message: Message, state: FSMContext):
    await state.update_data(description=message.text)
    await message.answer("Теперь выберите, где находится ваш объект:", reply_markup=get_region_keyboard())
    await state.set_state(AddProperty.region)

@router.callback_query(AddProperty.region, F.data.startswith("add_property_region:"))
async def add_property_region(callback: CallbackQuery, state: FSMContext):
    region = callback.data.split(":")[1]
    await state.update_data(region=region)
    if region == "Куршская коса":
        await state.update_data(district=region)
        await callback.message.edit_text("Принято. Теперь введите точный адрес (поселок, улица, дом).")
        await state.set_state(AddProperty.address)
    else:
        await callback.message.edit_text("Уточните локацию:", reply_markup=get_district_keyboard(region))
        await state.set_state(AddProperty.district)
    await callback.answer()

@router.callback_query(AddProperty.district, F.data == "back_to_regions")
async def back_to_regions(callback: CallbackQuery, state: FSMContext):
    await callback.message.edit_text("Выберите, где находится ваш объект:", reply_markup=get_region_keyboard())
    await state.set_state(AddProperty.region)
    await callback.answer()

@router.callback_query(AddProperty.district, F.data.startswith("add_prop_dist:"))
async def add_property_district(callback: CallbackQuery, state: FSMContext):
    _, region, district_index_str = callback.data.split(":")
    district_index = int(district_index_str)
    district_name = DISTRICTS[region][district_index]
    await state.update_data(district=district_name)
    await callback.message.edit_text("Принято. Теперь введите точный адрес (улица, дом).")
    await state.set_state(AddProperty.address)
    await callback.answer()

@router.message(AddProperty.address)
async def add_property_address(message: Message, state: FSMContext):
    await state.update_data(address=message.text)
    await message.answer("Укажите количество комнат:", reply_markup=get_rooms_keyboard())
    await state.set_state(AddProperty.rooms)
    
@router.callback_query(AddProperty.rooms, F.data.startswith("add_property_rooms:"))
async def add_property_rooms(callback: CallbackQuery, state: FSMContext):
    rooms = callback.data.split(":")[1]
    await state.update_data(rooms=rooms)
    await callback.message.edit_text("Супер. Укажите цену за ночь в рублях (только цифры).")
    await state.set_state(AddProperty.price_per_night)
    await callback.answer()

@router.message(AddProperty.price_per_night)
async def add_property_price(message: Message, state: FSMContext):
    if not message.text.isdigit():
        await message.answer("Пожалуйста, введите цену цифрами.")
        return
    await state.update_data(price_per_night=message.text)
    await message.answer("Хорошо. Теперь выберите максимальное количество гостей:", reply_markup=get_guests_keyboard())
    await state.set_state(AddProperty.max_guests)

@router.callback_query(AddProperty.max_guests, F.data.startswith("add_property_guests:"))
async def add_property_guests(callback: CallbackQuery, state: FSMContext):
    guests = callback.data.split(":")[1]
    await state.update_data(max_guests=guests)
    await callback.message.edit_text("И последнее: выберите тип объекта:", reply_markup=get_property_types_keyboard())
    await state.set_state(AddProperty.property_type)
    await callback.answer()

@router.callback_query(AddProperty.property_type, F.data.startswith("add_property_type:"))
async def add_property_type_final(callback: CallbackQuery, state: FSMContext):
    property_type = callback.data.split(":")[1]
    await state.update_data(property_type=property_type)
    data = await state.get_data()
    
    try:
        property_id = await add_property(data, owner_id=callback.from_user.id)
        await state.update_data(property_id=property_id)
        
        await callback.message.edit_text("Текстовая информация сохранена.")
        await callback.message.answer(
            "Теперь отправьте мне от 1 до 10 фотографий вашего объекта. "
            "Можно отправить их одним альбомом. Когда закончите, нажмите кнопку 'Завершить загрузку'.",
            reply_markup=get_finish_upload_keyboard()
        )
        await state.set_state(AddProperty.photos)
    except Exception as e:
        logging.error(f"Ошибка при добавлении объекта в БД: {e}")
        await callback.message.answer("К сожалению, при сохранении произошла ошибка.")
        await state.clear()
    finally:
        await callback.answer()

@router.message(AddProperty.photos, F.photo)
async def handle_photos(message: Message, state: FSMContext):
    photos = (await state.get_data()).get('photos', [])
    if len(photos) >= 10:
        await message.answer("Вы уже загрузили максимальное количество фотографий (10). Нажмите 'Завершить загрузку'.")
        return
    photos.append(message.photo[-1].file_id)
    await state.update_data(photos=photos)

@router.message(AddProperty.photos, F.text == "Завершить загрузку")
async def finish_photo_upload(message: Message, state: FSMContext):
    data = await state.get_data()
    photos = data.get('photos')
    property_id = data.get('property_id')

    if not photos:
        await message.answer("Вы не загрузили ни одной фотографии. Пожалуйста, отправьте хотя бы одну или отмените /cancel")
        return

    try:
        await add_photos_to_property(property_id, photos)
        await message.answer(
            "Фотографии сохранены. Теперь, если хотите, запишите и отправьте короткий видео-тур ('кружочек') по объекту. Это сильно повысит доверие. Или пропустите этот шаг.",
            reply_markup=get_skip_video_keyboard()
        )
        await state.set_state(AddProperty.video_note)
    except Exception as e:
        logging.error(f"Ошибка при сохранении фото в БД: {e}")
        await message.answer("Произошла ошибка при сохранении фотографий. Пожалуйста, попробуйте позже.", reply_markup=ReplyKeyboardRemove())
        await state.clear()
        
@router.message(AddProperty.video_note, F.video_note)
async def handle_video_note(message: Message, state: FSMContext):
    data = await state.get_data()
    property_id = data.get('property_id')
    
    try:
        await add_video_note_to_property(property_id, message.video_note.file_id)
        await message.answer(
            "<b>Отлично! Ваш объект с фото и видео-туром успешно добавлен!</b>",
            parse_mode="HTML",
            reply_markup=ReplyKeyboardRemove()
        )
    except Exception as e:
        logging.error(f"Ошибка при сохранении видео в БД: {e}")
        await message.answer("Произошла ошибка при сохранении видео. Пожалуйста, попробуйте позже.", reply_markup=ReplyKeyboardRemove())
    finally:
        await state.clear()

@router.message(AddProperty.video_note, F.text.in_({"Пропустить этот шаг", "Отмена"}))
async def skip_video_note(message: Message, state: FSMContext):
    await message.answer(
        "<b>Хорошо! Ваш объект с фотографиями успешно добавлен!</b>",
        parse_mode="HTML",
        reply_markup=ReplyKeyboardRemove()
    )
    await state.clear()
    
@router.message(AddProperty.photos)
async def incorrect_photo_upload(message: Message):
    await message.answer(
        "Пожалуйста, отправьте фотографию или нажмите кнопку 'Завершить загрузку' / 'Отмена'.",
        reply_markup=get_finish_upload_keyboard()
    )
    
@router.message(AddProperty.video_note)
async def incorrect_video_upload(message: Message):
    await message.answer(
        "Пожалуйста, отправьте видео-сообщение ('кружочек') или нажмите кнопку 'Пропустить этот шаг' / 'Отмена'.",
        reply_markup=get_skip_video_keyboard()
    )

@router.message(StateFilter(AddProperty), Command("cancel"))
@router.message(StateFilter(AddProperty), F.text.casefold() == "отмена")
async def cancel_add_handler(message: Message, state: FSMContext):
    await state.clear()
    await message.answer("Действие отменено.", reply_markup=ReplyKeyboardRemove())

--------------------------------------------------------------------------------
--- FILE: app/handlers/owner/booking_management.py
--------------------------------------------------------------------------------
from aiogram import F, Router, Bot
from aiogram.types import CallbackQuery
from src.services.repository import update_booking_status, get_booking_with_details

router = Router()

@router.callback_query(F.data.startswith("booking:confirm:"))
async def confirm_booking(callback: CallbackQuery, bot: Bot):
    booking_id = int(callback.data.split(":")[2])
    
    # Обновляем статус в БД и получаем обновленную запись
    booking = await update_booking_status(booking_id, "confirmed")
    if not booking:
        await callback.answer("Бронирование не найдено.", show_alert=True)
        return

    # Убираем кнопки и пишем, что заявка принята
    await callback.message.edit_text(f"{callback.message.text}\n\n--- \n✅ ВЫ ПРИНЯЛИ ЭТУ ЗАЯВКУ ---")
    
    # Отправляем уведомление арендатору
    try:
        await bot.send_message(
            chat_id=booking.user.telegram_id,
            text=f"🎉 Ваша заявка на бронирование объекта «{booking.property.title}» была ОДОБРЕНА!\n\nВладелец скоро свяжется с вами для уточнения деталей."
        )
    except Exception as e:
        print(f"Не удалось отправить уведомление арендатору: {e}")
        
    await callback.answer("Вы успешно приняли заявку!")


@router.callback_query(F.data.startswith("booking:reject:"))
async def reject_booking(callback: CallbackQuery, bot: Bot):
    booking_id = int(callback.data.split(":")[2])
    
    booking = await update_booking_status(booking_id, "rejected")
    if not booking:
        await callback.answer("Бронирование не найдено.", show_alert=True)
        return

    await callback.message.edit_text(f"{callback.message.text}\n\n--- \n❌ ВЫ ОТКЛОНИЛИ ЭТУ ЗАЯВКУ ---")

    try:
        await bot.send_message(
            chat_id=booking.user.telegram_id,
            text=f"😔 К сожалению, ваша заявка на бронирование объекта «{booking.property.title}» была ОТКЛОНЕНА."
        )
    except Exception as e:
        print(f"Не удалось отправить уведомление арендатору: {e}")
        
    await callback.answer("Вы отклонили заявку.")

--------------------------------------------------------------------------------
--- FILE: app/handlers/owner/manage_property.py
--------------------------------------------------------------------------------
from aiogram import F, Router
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery

# Обновляем импорты
from src.services.property_service import (get_properties_by_owner, toggle_property_activity, 
                                         delete_property, get_property_with_media_and_owner,
                                         get_owner_properties_summary)
from src.services.booking_service import count_pending_bookings_for_owner
from src.keyboards.inline_keyboards import (get_property_management_keyboard, 
                                           get_delete_confirmation_keyboard)

router = Router()

def format_my_property_card(prop) -> str:
    status_verified = "✅ Верифицирован" if prop.is_verified else "☑️ Не верифицирован"
    status_active = "🟢 Активен" if prop.is_active else "🔴 Скрыт"
    return (
        f"🆔 `{prop.id}`: **{prop.title}**\n"
        f"Статусы: {status_verified}, {status_active}"
    )

# --- ИЗМЕНЕНИЕ ЗДЕСЬ: Добавляем сводку ---
@router.message(Command("myproperties"))
async def my_properties_list(message: Message):
    owner_id = message.from_user.id
    
    # Получаем сводную информацию
    total_props, active_props = await get_owner_properties_summary(owner_id)
    pending_bookings = await count_pending_bookings_for_owner(owner_id)
    
    # Отправляем сводное сообщение
    summary_text = (
        f"Здравствуйте, {message.from_user.first_name}!\n\n"
        f"<b>Ваша приборная панель:</b>\n"
        f"Всего объектов: {total_props}\n"
        f"Активных в поиске: {active_props}\n"
        f"Новых заявок на бронь: {pending_bookings}"
    )
    await message.answer(summary_text)

    # Получаем и выводим список объектов, как и раньше
    properties = await get_properties_by_owner(owner_id=owner_id)
    if not properties:
        await message.answer("У вас пока нет добавленных объектов. Используйте /addproperty, чтобы добавить первый.")
        return
    
    await message.answer("<b>Ваши объекты:</b>")
    for prop in properties:
        await message.answer(
            format_my_property_card(prop),
            reply_markup=get_property_management_keyboard(prop.id, prop.is_active)
        )
# --- КОНЕЦ ИЗМЕНЕНИЯ ---


@router.callback_query(F.data.startswith("manage:toggle:"))
async def toggle_property_handler(callback: CallbackQuery):
    property_id = int(callback.data.split(":")[2])
    new_status = await toggle_property_activity(property_id)
    
    prop, _, _ = await get_property_with_media_and_owner(property_id)
    if prop:
        await callback.message.edit_text(
            format_my_property_card(prop),
            reply_markup=get_property_management_keyboard(prop.id, new_status)
        )
    await callback.answer()

@router.callback_query(F.data.startswith("manage:delete:"))
async def delete_property_handler(callback: CallbackQuery):
    property_id = int(callback.data.split(":")[2])
    await callback.message.edit_reply_markup(
        reply_markup=get_delete_confirmation_keyboard(property_id)
    )
    await callback.answer()

@router.callback_query(F.data.startswith("manage:delete_confirm:"))
async def delete_confirm_handler(callback: CallbackQuery):
    property_id = int(callback.data.split(":")[2])
    await delete_property(property_id)
    await callback.message.edit_text(f"Объект с ID `{property_id}` был успешно удален.")
    await callback.answer("Объект удален.", show_alert=True)

@router.callback_query(F.data == "manage:delete_cancel")
async def delete_cancel_handler(callback: CallbackQuery):
    # Вместо удаления разметки, вернем карточку объекта
    # Из-за вложенности, нам нужно найти ID объекта в кнопке
    prop_id = None
    for row in callback.message.reply_markup.inline_keyboard:
        for button in row:
            if button.callback_data.startswith("manage:edit:"):
                prop_id = int(button.callback_data.split(":")[-1])
                break
        if prop_id:
            break

    if prop_id:
        prop, _, _ = await get_property_with_media_and_owner(prop_id)
        if prop:
            await callback.message.edit_text(
                format_my_property_card(prop),
                reply_markup=get_property_management_keyboard(prop.id, prop.is_active)
            )
    else:
        await callback.message.edit_text("Действие отменено.")
    await callback.answer("Удаление отменено.")

--------------------------------------------------------------------------------
--- FILE: app/handlers/owner/edit_property.py
--------------------------------------------------------------------------------
import logging
from datetime import datetime, date
from aiogram import F, Router
from aiogram.filters import StateFilter, Command
from aiogram.fsm.context import FSMContext
from aiogram.types import (Message, CallbackQuery, ReplyKeyboardRemove,
                           InputMediaPhoto, InlineKeyboardButton)
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram_calendar import SimpleCalendar, SimpleCalendarCallback

from src.services import availability_service, booking_service
from src.utils.states import EditProperty
from src.services.property_service import get_property_with_media_and_owner, update_property_field
from src.services.media_service import (delete_one_media_item, add_photos_to_property,
                                        add_video_note_to_property)
from src.keyboards.inline_keyboards import (get_edit_property_keyboard, get_region_keyboard,
                                           get_district_keyboard, get_rooms_keyboard,
                                           get_guests_keyboard, get_property_types_keyboard,
                                           get_media_management_keyboard, get_delete_one_media_keyboard,
                                           get_finish_upload_keyboard, get_skip_video_keyboard,
                                           get_calendar)
from .manage_property import my_properties_list
from src.core.constants import DISTRICTS

router = Router()


# --- Вспомогательные функции ---

async def show_edit_menu(message_or_callback: Message | CallbackQuery, state: FSMContext, message_text: str | None = None):
    data = await state.get_data()
    property_id = data.get('property_id')

    if not property_id:
        logging.error("Не найден property_id в состоянии FSM при попытке показать меню редактирования.")
        if isinstance(message_or_callback, CallbackQuery):
            await message_or_callback.answer("Произошла ошибка, попробуйте снова.", show_alert=True)
        else:
            await message_or_callback.answer("Произошла ошибка, попробуйте снова.")
        await state.clear()
        return

    prop, _, _ = await get_property_with_media_and_owner(property_id)
    if not prop:
        await message_or_callback.answer("Не удалось найти объект. Возможно, он был удален.")
        await state.clear()
        return

    text = message_text or f"Редактирование объекта: **{prop.title}**\n\nЧто вы хотите изменить?"
    keyboard = get_edit_property_keyboard(property_id)

    if isinstance(message_or_callback, Message):
        await message_or_callback.answer(text, reply_markup=keyboard)
    else:
        try:
            await message_or_callback.message.edit_text(text, reply_markup=keyboard)
        except Exception as e:
            logging.warning(f"Не удалось отредактировать сообщение в show_edit_menu: {e}")
            await message_or_callback.answer()


    await state.set_state(EditProperty.choosing_field)


async def start_media_management(callback_query: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    property_id = data.get('property_id')
    prop, _, _ = await get_property_with_media_and_owner(property_id)

    await callback_query.message.delete()
    await callback_query.message.answer("Управление медиафайлами:")
    if not prop.media:
        await callback_query.message.answer("У этого объекта еще нет фото или видео.")
    else:
        await callback_query.message.answer("Текущие медиафайлы. Нажмите на 🗑️ под каждым, чтобы удалить.")
        for media in prop.media:
            if media.media_type == 'photo':
                await callback_query.message.answer_photo(media.file_id, reply_markup=get_delete_one_media_keyboard(media.id))
            elif media.media_type == 'video_note':
                await callback_query.message.answer_video_note(media.file_id, reply_markup=get_delete_one_media_keyboard(media.id))

    await callback_query.message.answer("Выберите дальнейшее действие:", reply_markup=get_media_management_keyboard(property_id))
    await state.set_state(EditProperty.managing_media)

# --- Начало диалога ---

@router.callback_query(F.data.startswith("manage:edit:"))
async def start_property_edit(callback: CallbackQuery, state: FSMContext):
    property_id = int(callback.data.split(":")[2])
    await state.update_data(property_id=property_id)
    await show_edit_menu(callback, state)
    await callback.answer()

# --- Главный диспетчер меню редактирования ---
@router.callback_query(EditProperty.choosing_field, F.data.startswith("edit_prop:"))
async def edit_field_prompt(callback: CallbackQuery, state: FSMContext):
    parts = callback.data.split(":")
    field = parts[1]

    if field == 'media':
        await start_media_management(callback, state)
        await callback.answer()
        return
    elif field == 'availability':
        await start_availability_management(callback, state)
        return

    prompts = {
        "title": ("Введите новое название:", EditProperty.editing_title),
        "description": ("Введите новое описание:", EditProperty.editing_description),
        "address": ("Введите новый адрес:", EditProperty.editing_address),
        "price": ("Введите новую цену за ночь (только цифры):", EditProperty.editing_price),
        "location": ("Выберите новый регион:", EditProperty.editing_region),
        "rooms": ("Выберите новое кол-во комнат:", EditProperty.editing_rooms),
        "guests": ("Выберите новое кол-во гостей:", EditProperty.editing_guests),
        "type": ("Выберите новый тип объекта:", EditProperty.editing_type),
    }

    if field in prompts:
        prompt_text, new_state = prompts[field]
        keyboard = None
        if field == 'location': keyboard = get_region_keyboard()
        if field == 'rooms': keyboard = get_rooms_keyboard()
        if field == 'guests': keyboard = get_guests_keyboard()
        if field == 'type': keyboard = get_property_types_keyboard()

        await callback.message.edit_text(prompt_text, reply_markup=keyboard)
        await state.set_state(new_state)

    await callback.answer()

# --- Обработка новых значений ---

@router.message(StateFilter(EditProperty.editing_title, EditProperty.editing_description, EditProperty.editing_address))
async def process_new_text_field(message: Message, state: FSMContext):
    current_state_str = await state.get_state()
    field_map = {
        EditProperty.editing_title.state: 'title',
        EditProperty.editing_description.state: 'description',
        EditProperty.editing_address.state: 'address',
    }
    field_to_update = field_map[current_state_str]

    data = await state.get_data()
    await update_property_field(data['property_id'], field_to_update, message.text)

    await message.answer(f"Поле '{field_to_update.replace('_', ' ').capitalize()}' успешно обновлено!")
    await show_edit_menu(message, state)

@router.message(EditProperty.editing_price)
async def process_new_price(message: Message, state: FSMContext):
    if not message.text.isdigit():
        await message.answer("Пожалуйста, введите цену цифрами.")
        return
    data = await state.get_data()
    await update_property_field(data['property_id'], 'price_per_night', int(message.text))
    await message.answer("Цена успешно обновлена!")
    await show_edit_menu(message, state)

@router.callback_query(StateFilter(EditProperty.editing_rooms, EditProperty.editing_guests, EditProperty.editing_type))
async def process_new_button_field(callback: CallbackQuery, state: FSMContext):
    current_state_str = await state.get_state()
    field_map = {
        EditProperty.editing_rooms.state: ('rooms', 'add_property_rooms:'),
        EditProperty.editing_guests.state: ('max_guests', 'add_property_guests:'),
        EditProperty.editing_type.state: ('property_type', 'add_property_type:'),
    }
    field_to_update, prefix = field_map[current_state_str]
    value = callback.data.replace(prefix, '')

    if field_to_update == 'rooms':
        value_to_save = 0 if value == 'Студия' else int(value.replace('+', ''))
    elif field_to_update == 'max_guests':
        value_to_save = int(value.replace('+', ''))
    else:
        value_to_save = value

    data = await state.get_data()
    await update_property_field(data['property_id'], field_to_update, value_to_save)

    await callback.message.answer(f"Поле '{field_to_update.replace('_', ' ').capitalize()}' успешно обновлено!")
    await show_edit_menu(callback, state)
    await callback.answer()

@router.callback_query(EditProperty.editing_region, F.data.startswith("add_property_region:"))
async def process_new_region(callback: CallbackQuery, state: FSMContext):
    region = callback.data.split(":")[1]
    if region == "Куршская коса":
        data = await state.get_data()
        await update_property_field(data['property_id'], 'district', region)
        await callback.message.answer("Район успешно обновлен!")
        await show_edit_menu(callback, state)
    else:
        await callback.message.edit_text("Уточните локацию:", reply_markup=get_district_keyboard(region))
        await state.set_state(EditProperty.editing_district)
    await callback.answer()

@router.callback_query(EditProperty.editing_district, F.data.startswith("add_prop_dist:"))
async def process_new_district(callback: CallbackQuery, state: FSMContext):
    _, region, district_index_str = callback.data.split(":")
    district_index = int(district_index_str)
    district_name = DISTRICTS[region][district_index]
    data = await state.get_data()
    await update_property_field(data['property_id'], 'district', district_name)
    await callback.message.answer("Район успешно обновлен!")
    await show_edit_menu(callback, state)
    await callback.answer()

# --- УПРАВЛЕНИЕ ДОСТУПНОСТЬЮ ---

async def _show_availability_calendar(callback: CallbackQuery, state: FSMContext):
    property_id = (await state.get_data())['property_id']
    
    manual_unavailable = await availability_service.get_unavailable_dates(property_id)
    booked_dates = await booking_service.get_booked_dates_for_property(property_id)
    all_unavailable_dates = sorted(list(set(manual_unavailable + booked_dates)))

    text = "🗓️ **Управление доступностью**\n\n"
    if all_unavailable_dates:
        dates_str = ", ".join([d.strftime("%d.%m") for d in all_unavailable_dates])
        text += f"🚫 **Занятые даты (брони + блокировки):**\n`{dates_str}`\n\n"
    
    text += "Нажмите на дату для ручной блокировки/разблокировки. Нажмите 'Готово', когда закончите."

    calendar_keyboard = await get_calendar()
    builder = InlineKeyboardBuilder.from_markup(calendar_keyboard)
    builder.row(InlineKeyboardButton(text="✅ Готово", callback_data="availability:done"))
    
    try:
        await callback.message.edit_text(text, reply_markup=builder.as_markup())
    except Exception as e:
        logging.info(f"Не удалось обновить календарь (сообщение не изменилось): {e}")
        await callback.answer()

async def start_availability_management(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    await state.set_state(EditProperty.managing_availability)
    await _show_availability_calendar(callback, state)

@router.callback_query(EditProperty.managing_availability, SimpleCalendarCallback.filter())
async def process_availability_date(callback: CallbackQuery, callback_data: SimpleCalendarCallback, state: FSMContext):
    calendar = SimpleCalendar()
    selected, date_obj = await calendar.process_selection(callback, callback_data)

    if selected:
        property_id = (await state.get_data())['property_id']
        selected_date = date_obj.date()

        if selected_date < date.today():
            await callback.answer("Нельзя изменить прошедшую дату.", show_alert=True)
            return
        
        booked_dates = await booking_service.get_booked_dates_for_property(property_id)
        if selected_date in booked_dates:
            await callback.answer("Эту дату нельзя изменить, она занята подтвержденной бронью.", show_alert=True)
            return

        manual_unavailable = await availability_service.get_unavailable_dates(property_id)
        if selected_date in manual_unavailable:
            await availability_service.remove_unavailable_date(property_id, selected_date)
            await callback.answer(f"Дата {selected_date.strftime('%d.%m.%Y')} разблокирована.")
        else:
            await availability_service.add_unavailable_date(property_id, selected_date)
            await callback.answer(f"Дата {selected_date.strftime('%d.%m.%Y')} заблокирована.")
            
        await _show_availability_calendar(callback, state)
    else:
        # Для навигации просто перерисовываем календарь
        await _show_availability_calendar(callback, state)

@router.callback_query(EditProperty.managing_availability, F.data == "availability:done")
async def finish_availability_management(callback: CallbackQuery, state: FSMContext):
    await callback.answer("Настройки сохранены")
    await show_edit_menu(callback, state, message_text="Настройки доступности сохранены.")

# --- Управление медиафайлами ---

@router.callback_query(EditProperty.managing_media, F.data.startswith("edit_media:delete:"))
async def delete_media_item_handler(callback: CallbackQuery):
    media_id = int(callback.data.split(":")[2])
    await delete_one_media_item(media_id)
    await callback.message.delete()
    await callback.answer("Медиафайл удален.", show_alert=True)

@router.callback_query(EditProperty.managing_media, F.data.startswith("edit_media:add:"))
async def add_more_media_prompt(callback: CallbackQuery, state: FSMContext):
    await callback.message.answer(
        "Отправьте новые фото (до 10) или видео-кружочек. Когда закончите, нажмите кнопку.",
        reply_markup=get_finish_upload_keyboard()
    )
    await state.set_state(EditProperty.adding_photos)
    await callback.answer()

@router.message(StateFilter(EditProperty.adding_photos), F.photo)
async def handle_new_photos_in_edit(message: Message, state: FSMContext):
    photos = (await state.get_data()).get('photos_to_add', [])
    if len(photos) >= 10:
        await message.answer("Вы уже добавили 10 фото. Нажмите 'Завершить загрузку'.")
        return
    photos.append(message.photo[-1].file_id)
    await state.update_data(photos_to_add=photos)

@router.message(StateFilter(EditProperty.adding_photos), F.video_note)
async def handle_new_video_in_edit(message: Message, state: FSMContext):
    await state.update_data(video_to_add=message.video_note.file_id)
    await message.answer("Кружочек получен. Вы можете отправить еще фото или нажать 'Завершить загрузку'.")

@router.message(StateFilter(EditProperty.adding_photos), F.text == "Завершить загрузку")
async def finish_adding_photos_in_edit(message: Message, state: FSMContext):
    data = await state.get_data()
    photos = data.get('photos_to_add')
    video = data.get('video_to_add')
    property_id = data.get('property_id')
    if not photos and not video:
        await message.answer("Вы не отправили ни одного файла. Нажмите 'Отмена' для выхода.", reply_markup=ReplyKeyboardRemove())
        await show_edit_menu(message, state)
        return

    if photos: await add_photos_to_property(property_id, photos)
    if video: await add_video_note_to_property(property_id, video)
    
    await message.answer("Новые медиафайлы добавлены!", reply_markup=ReplyKeyboardRemove())
    await state.update_data(photos_to_add=[], video_to_add=None)
    await show_edit_menu(message, state)

# --- Выход и Отмена ---

@router.callback_query(StateFilter(EditProperty.managing_media), F.data.startswith("edit_media:done:"))
async def finish_media_management(callback: CallbackQuery, state: FSMContext):
    await callback.message.delete()
    await show_edit_menu(callback, state)
    await callback.answer()

@router.callback_query(EditProperty.choosing_field, F.data == "back_to_my_properties")
async def back_to_list_from_edit(callback: CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.delete()
    await my_properties_list(callback.message)
    await callback.answer("Вы вышли из режима редактирования.")

@router.message(StateFilter(EditProperty), Command("cancel"))
@router.message(StateFilter(EditProperty), F.text.casefold() == "отмена")
async def cancel_edit_handler(message: Message, state: FSMContext):
    await state.clear()
    await message.answer("Редактирование отменено.", reply_markup=ReplyKeyboardRemove())


--------------------------------------------------------------------------------
--- FILE: app/handlers/user/booking.py
--------------------------------------------------------------------------------
import json
from datetime import datetime, timedelta
from aiogram import F, Router, Bot
from aiogram.types import Message, CallbackQuery, InputMediaPhoto

# --- Удаляем FSM, он больше не нужен для бронирования ---
# from aiogram.fsm.context import FSMContext
# from src.utils.states import BookingFlow

from src.services.property_service import get_property_with_media_and_owner
from src.services import booking_service
from src.services.review_service import get_reviews_summary
from src.keyboards.inline_keyboards import (get_booking_management_keyboard, 
                                            get_property_card_keyboard)

router = Router()


@router.callback_query(F.data.startswith(("view_photos:", "view_media:")))
async def view_media(callback: CallbackQuery, bot: Bot):
    await callback.answer()
    property_id = int(callback.data.split(":")[1])

    prop, photo_files, video_file = await get_property_with_media_and_owner(property_id)

    if not prop:
        await callback.message.answer("Объект не найден.")
        return

    media_to_show = []
    if video_file and callback.data.startswith("view_media:"):
        await bot.send_video_note(chat_id=callback.from_user.id, video_note=video_file)
        media_to_show = photo_files
    elif callback.data.startswith("view_photos:") and len(photo_files) > 1:
        media_to_show = photo_files[1:]

    if media_to_show:
        if len(media_to_show) > 1:
            media_group = [InputMediaPhoto(media=file_id) for file_id in media_to_show]
            await bot.send_media_group(chat_id=callback.from_user.id, media=media_group)
        elif len(media_to_show) == 1:
            await bot.send_photo(chat_id=callback.from_user.id, photo=media_to_show[0])
    elif not video_file:
         await callback.message.answer("Больше фотографий нет.")

    _, reviews_count = await get_reviews_summary(prop.id)
    await callback.message.answer(
        "Выберите дальнейшее действие:",
        reply_markup=get_property_card_keyboard(
            property_id=prop.id,
            photos_count=len(photo_files),
            has_video=bool(video_file),
            reviews_count=reviews_count
        )
    )

# --- НОВЫЙ ОБРАБОТЧИК ДЛЯ ДАННЫХ ИЗ WEB APP ---

@router.message(F.web_app_data)
async def process_booking_from_webapp(message: Message, bot: Bot):
    """
    Этот хендлер "ловит" данные, отправленные из Web App календаря.
    """
    try:
        data = json.loads(message.web_app_data.data)
        
        # 1. Извлекаем и преобразуем данные
        property_id = int(data['property_id'])
        # Даты приходят в формате 'ГГГГ-ММ-ДД', преобразуем их в datetime
        checkin_date = datetime.fromisoformat(data['checkin_date'])
        checkout_date = datetime.fromisoformat(data['checkout_date'])

        # 2. Проводим проверки
        prop, _, _ = await get_property_with_media_and_owner(property_id)
        if not prop:
            await message.answer("Ошибка: объект не найден.")
            return

        if prop.owner.telegram_id == message.from_user.id:
            await message.answer("Вы не можете забронировать свой собственный объект.")
            return

        # 3. Создаем бронирование (используем наш booking_service)
        new_booking = await booking_service.create_booking(
            user_id=message.from_user.id,
            property_id=property_id,
            start_date=checkin_date,
            end_date=checkout_date
        )

        # 4. Отправляем уведомления
        user_info = f"@{message.from_user.username}" if message.from_user.username else message.from_user.first_name
        num_nights = (checkout_date - checkin_date).days
        total_price = prop.price_per_night * num_nights

        await bot.send_message(
            chat_id=prop.owner.telegram_id,
            text=(
                f"🔔 Новая заявка на бронирование!\n\n"
                f"<b>Объект:</b> «{prop.title}»\n"
                f"<b>Даты:</b> с {checkin_date.strftime('%d.%m.%Y')} по {checkout_date.strftime('%d.%m.%Y')} ({num_nights} ночей)\n"
                f"<b>Сумма:</b> {total_price} руб.\n"
                f"<b>Гость:</b> {user_info}"
            ),
            reply_markup=get_booking_management_keyboard(new_booking.id)
        )
        
        await message.answer("✅ Спасибо! Ваша заявка на бронирование отправлена владельцу.")

    except Exception as e:
        print(f"Ошибка обработки данных из Web App: {e}")
        await message.answer("Произошла ошибка при обработке вашего бронирования. Попробуйте снова.")



--------------------------------------------------------------------------------
--- FILE: app/handlers/user/review.py
--------------------------------------------------------------------------------
from aiogram import F, Router
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery

from src.utils.states import LeaveReview
from src.services.review_service import add_review, get_latest_reviews
from src.keyboards.inline_keyboards import get_rating_keyboard

router = Router()

# ... (код process_rating и process_comment без изменений) ...
@router.callback_query(F.data.startswith("review:"))
async def process_rating(callback: CallbackQuery, state: FSMContext):
    _, booking_id_str, _, rating_str = callback.data.split(":")
    await state.update_data(
        booking_id=int(booking_id_str),
        rating=int(rating_str)
    )
    await callback.message.edit_text(
        f"Вы поставили оценку: {'⭐️' * int(rating_str)}\n\n"
        "Теперь, пожалуйста, напишите текстовый комментарий... "
        "Или отправьте '-', если не хотите оставлять комментарий."
    )
    await state.set_state(LeaveReview.waiting_for_comment)
    await callback.answer()

@router.message(LeaveReview.waiting_for_comment)
async def process_comment(message: Message, state: FSMContext):
    data = await state.get_data()
    booking_id = data.get('booking_id')
    rating = data.get('rating')
    comment_text = message.text if message.text != '-' else None
    await add_review(
        booking_id=booking_id,
        rating=rating,
        text=comment_text
    )
    await message.answer("Спасибо! Ваш отзыв был успешно сохранен.")
    await state.clear()


# --- НОВЫЙ ОБРАБОТЧИК ---
@router.callback_query(F.data.startswith("view_reviews:"))
async def view_reviews_handler(callback: CallbackQuery):
    property_id = int(callback.data.split(":")[1])
    reviews = await get_latest_reviews(property_id)
    
    if not reviews:
        await callback.answer("У этого объекта еще нет отзывов.", show_alert=True)
        return

    response_text = "<b>Последние отзывы:</b>\n\n"
    for review in reviews:
        stars = "⭐️" * review.rating
        comment = f" — «{review.text}»" if review.text else ""
        response_text += f"{stars}{comment}\n--------------------\n"
        
    await callback.message.answer(response_text)
    await callback.answer()

--------------------------------------------------------------------------------
--- FILE: app/handlers/user/common.py
--------------------------------------------------------------------------------
from aiogram import F, Router
from aiogram.filters import CommandStart, Command
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery, ReplyKeyboardRemove

from src.services.user_service import add_user
from src.keyboards.inline_keyboards import get_main_menu

router = Router()

@router.message(CommandStart())
async def cmd_start(message: Message, state: FSMContext):
    # При старте на всякий случай сбрасываем состояние
    current_state = await state.get_state()
    if current_state is not None:
        await state.clear()
        
    await message.answer("Загрузка...", reply_markup=ReplyKeyboardRemove())
    await add_user(
        telegram_id=message.from_user.id,
        username=message.from_user.username,
        first_name=message.from_user.first_name
    )
    await message.answer(
        "Добро пожаловать в 'Гид по Калининграду'!",
        reply_markup=get_main_menu()
    )

# --- НАШ НОВЫЙ ОБРАБОТЧИК ---
@router.message(Command("help"))
async def cmd_help(message: Message):
    help_text = (
        "<b>Добро пожаловать в Справку!</b>\n\n"
        "Я бот для поиска и аренды жилья в Калининградской области.\n\n"
        "<b>Основные команды:</b>\n"
        "/start - перезапуск бота и вызов главного меню.\n"
        "/help - вызов этого сообщения.\n"
        "/cancel - отмена любого текущего диалога (добавления, поиска и т.д.).\n\n"
        "<b>Для Владельцев (и Администраторов):</b>\n"
        "/myproperties - посмотреть список ваших объектов и управлять ими.\n"
        "/addproperty - запустить диалог добавления нового объекта."
    )
    await message.answer(help_text)


@router.callback_query(F.data == "main_menu:about")
async def about_service(callback: CallbackQuery):
    await callback.message.answer(
        "Этот бот создан, чтобы помочь вам легко найти и арендовать "
        "лучшее жилье в Калининградской области."
    )
    await callback.answer()

--------------------------------------------------------------------------------
--- FILE: app/handlers/user/search.py
--------------------------------------------------------------------------------
from aiogram import F, Router
from aiogram.filters import StateFilter, Command
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery, ReplyKeyboardRemove, KeyboardButton, InputMediaPhoto
from aiogram.utils.keyboard import ReplyKeyboardBuilder

from src.services.property_service import get_all_properties
from src.services.review_service import get_reviews_summary
from src.keyboards.inline_keyboards import (get_region_keyboard, get_district_keyboard, 
                                            get_property_card_keyboard, get_guests_keyboard)
from src.core.constants import DISTRICTS
from src.utils.states import SearchProperties

router = Router()

async def show_properties_by_filter(message: Message, state: FSMContext):
    """
    Финальная функция: собирает данные из состояния, делает запрос в БД и показывает результаты.
    """
    data = await state.get_data()
    properties = await get_all_properties(
        districts=data.get('districts'),
        max_price=data.get('max_price'),
        min_guests=data.get('min_guests')
    )
    
    await state.clear()

    if not properties:
        await message.answer("К сожалению, по вашему запросу ничего не найдено.")
        return

    await message.answer(f"Найдено {len(properties)} вариантов:")
    for prop in properties:
        avg_rating, reviews_count = await get_reviews_summary(prop.id)
        
        rating_info = ""
        if reviews_count > 0 and avg_rating is not None:
            rating_info = f"⭐️ **{avg_rating:.1f}/5.0** ({reviews_count} отзывов)\n"

        verified_icon = "✅" if prop.is_verified else ""
        rooms_str = f"{prop.rooms} комн." if prop.rooms > 0 else "Студия"
        
        caption = (
            f"{verified_icon} 🏠 **{prop.title}**\n"
            f"{rating_info}\n"
            f"📝 {prop.description}\n\n"
            f"📍 Район: {prop.district}\n"
            f"🗺️ Адрес: {prop.address}\n"
            f"🛏️ Комнаты: {rooms_str}\n"
            f"💰 Цена: {prop.price_per_night} руб/ночь\n"
            f"👥 Гостей: до {prop.max_guests}"
        )
        
        photo_files = [media.file_id for media in prop.media if media.media_type == 'photo']
        video_note_id = next((media.file_id for media in prop.media if media.media_type == 'video_note'), None)

        # Передаем актуальное количество фото и отзывов в клавиатуру
        keyboard = get_property_card_keyboard(prop.id, len(photo_files), bool(video_note_id), reviews_count)

        if video_note_id:
            await message.answer_video_note(video_note_id)
            await message.answer(caption, reply_markup=keyboard)
        elif photo_files:
            await message.answer_photo(
                photo=photo_files[0],
                caption=caption,
                reply_markup=keyboard
            )
        else:
            await message.answer(caption, reply_markup=keyboard)


def get_skip_keyboard():
    """Возвращает Reply-клавиатуру с кнопкой 'Пропустить'."""
    builder = ReplyKeyboardBuilder()
    builder.add(KeyboardButton(text="Пропустить"))
    return builder.as_markup(resize_keyboard=True, one_time_keyboard=True)

# --- Логика Поиска (FSM) ---

@router.callback_query(F.data == "main_menu:search")
async def start_search(callback: CallbackQuery, state: FSMContext):
    await callback.message.edit_text("Давайте подберем вам жилье. Выберите регион:", reply_markup=get_region_keyboard())
    await state.set_state(SearchProperties.region)
    await callback.answer()

@router.callback_query(SearchProperties.region, F.data.startswith("add_property_region:"))
async def search_select_region(callback: CallbackQuery, state: FSMContext):
    region = callback.data.split(":")[1]
    await state.update_data(region=region)
    
    if region == "Куршская коса":
        await state.update_data(districts=[region]) # Сразу сохраняем как список
        await callback.message.edit_text("Район выбран. Укажите максимальную цену за ночь (или пропустите):")
        await callback.message.answer("Введите цену или нажмите 'Пропустить'", reply_markup=get_skip_keyboard())
        await state.set_state(SearchProperties.price)
    else:
        await callback.message.edit_text("Уточните локацию:", reply_markup=get_district_keyboard(region))
        await state.set_state(SearchProperties.district)
    await callback.answer()

@router.callback_query(SearchProperties.district, F.data == "back_to_regions")
async def search_back_to_regions(callback: CallbackQuery, state: FSMContext):
    await callback.message.edit_text("Выберите регион:", reply_markup=get_region_keyboard())
    await state.set_state(SearchProperties.region)
    await callback.answer()

# Новый обработчик для кнопки "Все варианты в регионе"
@router.callback_query(SearchProperties.district, F.data.startswith("search_all_in_region:"))
async def search_all_in_region(callback: CallbackQuery, state: FSMContext):
    region = callback.data.split(":")[1]
    districts_in_region = DISTRICTS.get(region, [])
    
    await state.update_data(districts=districts_in_region)
    
    await callback.message.edit_text(f"Выбраны все варианты в '{region}'.")
    await callback.message.answer("Теперь укажите максимальную цену за ночь (или пропустите):", reply_markup=get_skip_keyboard())
    await state.set_state(SearchProperties.price)
    await callback.answer()

@router.callback_query(SearchProperties.district, F.data.startswith("add_prop_dist:"))
async def search_select_district(callback: CallbackQuery, state: FSMContext):
    _, region, district_index_str = callback.data.split(":")
    district_index = int(district_index_str)
    district_name = DISTRICTS[region][district_index]
    
    await state.update_data(districts=[district_name]) # Сохраняем как список
    
    await callback.message.edit_text("Район выбран. Укажите максимальную цену за ночь (или пропустите):")
    await callback.message.answer("Введите цену или нажмите 'Пропустить'", reply_markup=get_skip_keyboard())
    await state.set_state(SearchProperties.price)
    await callback.answer()

@router.message(SearchProperties.price)
async def search_by_price(message: Message, state: FSMContext):
    if message.text.lower() != 'пропустить':
        if not message.text.isdigit():
            await message.answer("Пожалуйста, введите цену цифрами.")
            return
        await state.update_data(max_price=int(message.text))
    
    await message.answer("Хорошо. На какое количество гостей ищете жилье?", reply_markup=ReplyKeyboardRemove())
    await message.answer("Выберите количество гостей:", reply_markup=get_guests_keyboard())
    await state.set_state(SearchProperties.guests)

@router.callback_query(SearchProperties.guests, F.data.startswith("add_property_guests:"))
async def search_by_guests(callback: CallbackQuery, state: FSMContext):
    guests = callback.data.split(":")[1]
    value_to_save = int(guests.replace('+', ''))
    await state.update_data(min_guests=value_to_save)
    
    await callback.message.edit_text(f"Выбрано гостей: {guests}. Идет поиск...")
    
    await show_properties_by_filter(callback.message, state)
    await callback.answer()

@router.message(StateFilter(SearchProperties), Command("cancel"))
@router.message(StateFilter(SearchProperties), F.text.casefold() == "отмена")
async def cancel_search_handler(message: Message, state: FSMContext):
    await state.clear()
    await message.answer("Поиск отменен.", reply_markup=ReplyKeyboardRemove())

@router.message(StateFilter(SearchProperties))
async def incorrect_search_input(message: Message):
    await message.answer("Пожалуйста, следуйте инструкциям или нажмите на кнопки. Для отмены поиска введите /cancel")

--------------------------------------------------------------------------------
--- FILE: app/services/db.py
--------------------------------------------------------------------------------
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
from src.core.settings import settings

# echo=False, чтобы не засорять логи SQL-запросами в продакшене
engine = create_async_engine(settings.DATABASE_URL_asyncpg, echo=False) 
async_session_maker = async_sessionmaker(engine, expire_on_commit=False)

--------------------------------------------------------------------------------
--- FILE: app/services/review_service.py
--------------------------------------------------------------------------------
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import async_sessionmaker

from src.models.models import Booking, Review
from .db import async_session_maker

async def add_review(booking_id: int, rating: int, text: str | None):
    async with async_session_maker() as session:
        booking = await session.get(Booking, booking_id)
        if not booking:
            return

        new_review = Review(
            property_id=booking.property_id,
            user_id=booking.user_id,
            booking_id=booking_id,
            rating=rating,
            text=text
        )
        session.add(new_review)
        await session.commit()

# --- НОВЫЕ ФУНКЦИИ ---

async def get_reviews_summary(property_id: int) -> tuple[float | None, int]:
    """
    Возвращает средний рейтинг и количество отзывов для объекта.
    """
    async with async_session_maker() as session:
        query = (
            select(
                func.avg(Review.rating),
                func.count(Review.id)
            )
            .where(Review.property_id == property_id)
        )
        result = await session.execute(query)
        # one_or_none() вернет (None, 0), если отзывов нет
        avg_rating, count = result.one_or_none() or (None, 0)
        return avg_rating, count

async def get_latest_reviews(property_id: int, limit: int = 5):
    """
    Возвращает последние N отзывов для объекта.
    """
    async with async_session_maker() as session:
        query = (
            select(Review)
            .where(Review.property_id == property_id)
            .order_by(Review.created_at.desc())
            .limit(limit)
        )
        result = await session.execute(query)
        return result.scalars().all()

--------------------------------------------------------------------------------
--- FILE: app/services/__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--- FILE: app/services/availability_service.py
--------------------------------------------------------------------------------
from datetime import date
from sqlalchemy import select, delete, and_
from src.models.models import UnavailableDate
from .db import async_session_maker

async def get_manual_blocks(property_id: int) -> list[UnavailableDate]:
    """Возвращает список объектов UnavailableDate, заблокированных владельцем вручную."""
    async with async_session_maker() as session:
        query = select(UnavailableDate).where(UnavailableDate.property_id == property_id)
        result = await session.execute(query)
        return result.scalars().all()

async def toggle_manual_availability(property_id: int, target_date: date, comment: str | None = None) -> str:
    """
    Переключает статус ручной блокировки для даты.
    Если дата блокируется, можно передать комментарий.
    """
    async with async_session_maker() as session:
        query = select(UnavailableDate).where(
            and_(
                UnavailableDate.property_id == property_id,
                UnavailableDate.date == target_date
            )
        )
        result = await session.execute(query)
        existing_block = result.scalar_one_or_none()

        if existing_block:
            await session.delete(existing_block)
            new_status = 'available'
        else:
            new_block = UnavailableDate(property_id=property_id, date=target_date, comment=comment)
            session.add(new_block)
            new_status = 'manual_block'
        
        await session.commit()
        return new_status


--------------------------------------------------------------------------------
--- FILE: app/services/pricing_service.py
--------------------------------------------------------------------------------
from datetime import date
from sqlalchemy import select, and_, delete
from sqlalchemy.orm import selectinload

from src.models.models import Property, PriceRule
from .db import async_session_maker

async def get_price_for_date(session, property_id: int, target_date: date, base_price: int) -> int:
    """
    Определяет цену для конкретной даты, учитывая правила.
    Правило, которое начинается позже, имеет приоритет.
    """
    query = (
        select(PriceRule.price)
        .where(
            and_(
                PriceRule.property_id == property_id,
                PriceRule.start_date <= target_date,
                PriceRule.end_date >= target_date
            )
        )
        .order_by(PriceRule.start_date.desc())
        .limit(1)
    )
    result = await session.execute(query)
    rule_price = result.scalar_one_or_none()

    return rule_price if rule_price is not None else base_price

async def get_property_with_price_rules(session, property_id: int):
    """Загружает объект со всеми его ценовыми правилами."""
    query = (
        select(Property)
        .where(Property.id == property_id)
        .options(selectinload(Property.price_rules))
    )
    result = await session.execute(query)
    return result.scalar_one_or_none()

async def add_price_rule(property_id: int, start_date: date, end_date: date, price: int) -> PriceRule:
    """Создает новое ценовое правило."""
    async with async_session_maker() as session:
        new_rule = PriceRule(
            property_id=property_id,
            start_date=start_date,
            end_date=end_date,
            price=price
        )
        session.add(new_rule)
        await session.commit()
        await session.refresh(new_rule)
        return new_rule

async def get_price_rules_for_property(property_id: int) -> list[PriceRule]:
    """Получает все ценовые правила для объекта."""
    async with async_session_maker() as session:
        query = select(PriceRule).where(PriceRule.property_id == property_id).order_by(PriceRule.start_date)
        result = await session.execute(query)
        return result.scalars().all()

async def delete_price_rule(rule_id: int) -> bool:
    """Удаляет ценовое правило по его ID."""
    async with async_session_maker() as session:
        result = await session.execute(delete(PriceRule).where(PriceRule.id == rule_id))
        await session.commit()
        return result.rowcount > 0


--------------------------------------------------------------------------------
--- FILE: app/services/booking_service.py
--------------------------------------------------------------------------------
from datetime import datetime, timedelta
from sqlalchemy import select, update, func, and_
from sqlalchemy.orm import selectinload

from src.models.models import Booking, Property
from .db import async_session_maker


async def create_booking(user_id: int, property_id: int, start_date: datetime, end_date: datetime) -> Booking:
    """Создает новую заявку на бронирование с датами и статусом 'pending'."""
    async with async_session_maker() as session:
        new_booking = Booking(
            user_id=user_id,
            property_id=property_id,
            start_date=start_date,
            end_date=end_date
        )
        session.add(new_booking)
        await session.commit()
        return new_booking

async def update_booking_status(booking_id: int, status: str) -> Booking | None:
    """Обновляет статус бронирования (pending, confirmed, rejected)."""
    async with async_session_maker() as session:
        booking = await session.get(Booking, booking_id)
        if booking:
            booking.status = status
            await session.commit()
        return booking

async def get_booking_with_details(booking_id: int):
    """Получает бронирование со связанными данными пользователя и объекта."""
    async with async_session_maker() as session:
        query = (
            select(Booking)
            .where(Booking.id == booking_id)
            .options(selectinload(Booking.user), selectinload(Booking.property))
        )
        result = await session.execute(query)
        return result.unique().scalar_one_or_none()


async def count_pending_bookings_for_owner(owner_id: int) -> int:
    """Подсчитывает количество необработанных заявок ('pending') для владельца."""
    async with async_session_maker() as session:
        query = (
            select(func.count(Booking.id))
            .join(Property, Booking.property_id == Property.id)
            .where(
                and_(
                    Property.owner_id == owner_id,
                    Booking.status == 'pending'
                )
            )
        )
        result = await session.execute(query)
        return result.scalar_one()

async def get_booked_dates_for_property(property_id: int) -> list[datetime.date]:
    """
    Возвращает список всех дат, занятых подтвержденными бронированиями ('confirmed').
    """
    async with async_session_maker() as session:
        query = select(Booking.start_date, Booking.end_date).where(
            and_(
                Booking.property_id == property_id,
                Booking.status == 'confirmed'
            )
        )
        result = await session.execute(query)
        booked_dates = []
        for start_date, end_date in result.all():
            current_date = start_date
            # Бронирование не включает день выезда, поэтому <
            while current_date < end_date:
                booked_dates.append(current_date.date())
                current_date += timedelta(days=1)
        return booked_dates


--------------------------------------------------------------------------------
--- FILE: app/services/user_service.py
--------------------------------------------------------------------------------
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import async_sessionmaker

from src.models.models import User
from .db import async_session_maker

async def add_user(telegram_id: int, username: str | None, first_name: str) -> User:
    async with async_session_maker() as session:
        result = await session.execute(select(User).where(User.telegram_id == telegram_id))
        user = result.scalar_one_or_none()
        if user is None:
            new_user = User(telegram_id=telegram_id, username=username, first_name=first_name)
            session.add(new_user)
            await session.commit()
            return new_user
        return user

async def get_user(user_id: int) -> User | None:
    async with async_session_maker() as session:
        return await session.get(User, user_id)

async def set_user_role(user_id: int, role: str):
    async with async_session_maker() as session:
        query = update(User).where(User.telegram_id == user_id).values(role=role)
        await session.execute(query)
        await session.commit()

--------------------------------------------------------------------------------
--- FILE: app/services/media_service.py
--------------------------------------------------------------------------------
from sqlalchemy import delete
from sqlalchemy.ext.asyncio import async_sessionmaker

from src.models.models import PropertyMedia
from .db import async_session_maker

async def add_photos_to_property(property_id: int, photo_file_ids: list[str]):
    async with async_session_maker() as session:
        for file_id in photo_file_ids:
            new_photo = PropertyMedia(
                property_id=property_id,
                file_id=file_id,
                media_type='photo'
            )
            session.add(new_photo)
        await session.commit()
        
async def add_video_note_to_property(property_id: int, file_id: str):
    async with async_session_maker() as session:
        new_video_note = PropertyMedia(
            property_id=property_id,
            file_id=file_id,
            media_type='video_note'
        )
        session.add(new_video_note)
        await session.commit()

async def delete_all_media_for_property(property_id: int):
    async with async_session_maker() as session:
        await session.execute(delete(PropertyMedia).where(PropertyMedia.property_id == property_id))
        await session.commit()

async def delete_one_media_item(media_id: int):
    async with async_session_maker() as session:
        await session.execute(delete(PropertyMedia).where(PropertyMedia.id == media_id))
        await session.commit()

--------------------------------------------------------------------------------
--- FILE: app/services/property_service.py
--------------------------------------------------------------------------------
from sqlalchemy import select, update, delete, func, and_
from sqlalchemy.ext.asyncio import async_sessionmaker
from sqlalchemy.orm import selectinload

from src.models.models import Property, PropertyMedia
from .db import async_session_maker


async def add_property(data: dict, owner_id: int) -> int:
    async with async_session_maker() as session:
        rooms_str = data.get('rooms', '0')
        rooms_int = 0 if rooms_str == 'Студия' else int(rooms_str.replace('+', ''))
        guests_str = data.get('max_guests', '1')
        guests_int = int(guests_str.replace('+', ''))
        new_property = Property(
            owner_id=owner_id,
            title=data.get('title'),
            description=data.get('description'),
            district=data.get('district'),
            address=data.get('address'),
            rooms=rooms_int,
            price_per_night=int(data.get('price_per_night')),
            max_guests=guests_int,
            property_type=data.get('property_type')
        )
        session.add(new_property)
        await session.flush()
        property_id = new_property.id
        await session.commit()
        return property_id

async def get_all_properties(
    districts: list[str] | None = None, 
    max_price: int | None = None, 
    min_guests: int | None = None
):
    """
    Возвращает список всех активных объектов с учетом фильтров.
    """
    async with async_session_maker() as session:
        query = (
            select(Property)
            .where(Property.is_active == True)
            .options(selectinload(Property.media))
        )
        
        if districts:
            query = query.where(Property.district.in_(districts)) # Используем .in_ для списка
        if max_price:
            query = query.where(Property.price_per_night <= max_price)
        if min_guests:
            query = query.where(Property.max_guests >= min_guests)
            
        result = await session.execute(query)
        return result.unique().scalars().all()
# --- КОНЕЦ ИСПРАВЛЕНИЯ ---

async def get_property_with_media_and_owner(property_id: int):
    async with async_session_maker() as session:
        query = (
            select(Property)
            .where(Property.id == property_id)
            .options(selectinload(Property.owner), selectinload(Property.media))
        )
        result = await session.execute(query)
        prop = result.unique().scalar_one_or_none()
        if prop:
            photo_files = [media.file_id for media in prop.media if media.media_type == 'photo']
            video_file = next((media.file_id for media in prop.media if media.media_type == 'video_note'), None)
            return prop, photo_files, video_file
        return None, [], None

async def set_property_verified(property_id: int, status: bool = True):
    async with async_session_maker() as session:
        query = update(Property).where(Property.id == property_id).values(is_verified=status)
        await session.execute(query)
        await session.commit()

async def get_properties_by_owner(owner_id: int):
    async with async_session_maker() as session:
        query = select(Property).where(Property.owner_id == owner_id).order_by(Property.id)
        result = await session.execute(query)
        return result.scalars().all()

async def toggle_property_activity(property_id: int) -> bool:
    async with async_session_maker() as session:
        prop = await session.get(Property, property_id)
        if prop:
            prop.is_active = not prop.is_active
            await session.commit()
            return prop.is_active
    return False

async def delete_property(property_id: int):
    async with async_session_maker() as session:
        await session.execute(delete(Property).where(Property.id == property_id))
        await session.commit()

async def update_property_field(property_id: int, field: str, value):
    async with async_session_maker() as session:
        query = update(Property).where(Property.id == property_id).values({field: value})
        await session.execute(query)
        await session.commit()

# --- НОВАЯ ФУНКЦИЯ ---
async def get_owner_properties_summary(owner_id: int) -> tuple[int, int]:
    """
    Подсчитывает общее и активное количество объектов владельца.
    Возвращает кортеж (total_count, active_count).
    """
    async with async_session_maker() as session:
        # Считаем общее количество
        total_query = select(func.count(Property.id)).where(Property.owner_id == owner_id)
        total_result = await session.execute(total_query)
        total_count = total_result.scalar_one()

        # Считаем количество активных
        active_query = select(func.count(Property.id)).where(
            and_(Property.owner_id == owner_id, Property.is_active == True)
        )
        active_result = await session.execute(active_query)
        active_count = active_result.scalar_one()
        
        return total_count, active_count

--------------------------------------------------------------------------------
--- FILE: alembic/script.py.mako
--------------------------------------------------------------------------------
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}


--------------------------------------------------------------------------------
--- SKIPPED (binary or error): alembic/.DS_Store | Reason: 'utf-8' codec can't decode byte 0xff in position 570: invalid start byte
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- FILE: alembic/env.py
--------------------------------------------------------------------------------
import sys
from logging.config import fileConfig
from os.path import abspath, dirname

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# --- НАШИ ДОБАВЛЕНИЯ НАЧИНАЮТСЯ ЗДЕСЬ ---

# Это нужно, чтобы Alembic мог найти наши модули 'app'
sys.path.insert(0, dirname(dirname(abspath(__file__))))

# 1. Импортируем наши настройки и базовую модель из SQLAlchemy
from src.core.settings import settings
from src.models.base import Base # Мы создадим этот файл на следующем шаге

# --- НАШИ ДОБАВЛЕНИЯ ЗАКАНЧИВАЮТСЯ ЗДЕСЬ ---


# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# --- НАШИ ИЗМЕНЕНИЯ ЗДЕСЬ ---
# Устанавливаем URL базы данных из наших настроек
# Это самая важная строка, она говорит Alembic, куда подключаться
config.set_main_option('sqlalchemy.url', settings.DATABASE_URL_psycopg)
# --- КОНЕЦ ИЗМЕНЕНИЙ ---


# Interpret the config file for Python logging.
# This line needs to be placed after an `import logging`.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
# --- НАШИ ИЗМЕНЕНИЯ ЗДЕСЬ ---
# Указываем Alembic на метаданные наших моделей
target_metadata = Base.metadata
# --- КОНЕЦ ИЗМЕНЕНИЙ ---


# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

--------------------------------------------------------------------------------
--- FILE: alembic/README
--------------------------------------------------------------------------------
Generic single-database configuration.

--------------------------------------------------------------------------------
--- FILE: alembic/versions/229b2ca3612e_add_unavailable_dates_table.py
--------------------------------------------------------------------------------
"""Add unavailable_dates table

Revision ID: 229b2ca3612e
Revises: 0372a3ff3322
Create Date: 2025-06-22 18:56:32.008209

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '229b2ca3612e'
down_revision: Union[str, None] = '0372a3ff3322'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('unavailable_dates',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('property_id', sa.Integer(), nullable=False),
    sa.Column('date', sa.Date(), nullable=False),
    sa.ForeignKeyConstraint(['property_id'], ['public.properties.id'], ),
    sa.PrimaryKeyConstraint('id'),
    schema='public'
    )
    op.drop_index('ix_apscheduler_jobs_next_run_time', table_name='apscheduler_jobs')
    op.drop_table('apscheduler_jobs')
    op.drop_constraint('bookings_user_id_fkey', 'bookings', type_='foreignkey')
    op.drop_constraint('bookings_property_id_fkey', 'bookings', type_='foreignkey')
    op.create_foreign_key(None, 'bookings', 'users', ['user_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'bookings', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.drop_constraint('properties_owner_id_fkey', 'properties', type_='foreignkey')
    op.create_foreign_key(None, 'properties', 'users', ['owner_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.drop_constraint('property_media_property_id_fkey', 'property_media', type_='foreignkey')
    op.create_foreign_key(None, 'property_media', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.drop_constraint('reviews_booking_id_fkey', 'reviews', type_='foreignkey')
    op.drop_constraint('reviews_property_id_fkey', 'reviews', type_='foreignkey')
    op.drop_constraint('reviews_user_id_fkey', 'reviews', type_='foreignkey')
    op.create_foreign_key(None, 'reviews', 'users', ['user_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'reviews', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'reviews', 'bookings', ['booking_id'], ['id'], source_schema='public', referent_schema='public')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.create_foreign_key('reviews_user_id_fkey', 'reviews', 'users', ['user_id'], ['telegram_id'])
    op.create_foreign_key('reviews_property_id_fkey', 'reviews', 'properties', ['property_id'], ['id'])
    op.create_foreign_key('reviews_booking_id_fkey', 'reviews', 'bookings', ['booking_id'], ['id'])
    op.drop_constraint(None, 'property_media', schema='public', type_='foreignkey')
    op.create_foreign_key('property_media_property_id_fkey', 'property_media', 'properties', ['property_id'], ['id'])
    op.drop_constraint(None, 'properties', schema='public', type_='foreignkey')
    op.create_foreign_key('properties_owner_id_fkey', 'properties', 'users', ['owner_id'], ['telegram_id'])
    op.drop_constraint(None, 'bookings', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'bookings', schema='public', type_='foreignkey')
    op.create_foreign_key('bookings_property_id_fkey', 'bookings', 'properties', ['property_id'], ['id'])
    op.create_foreign_key('bookings_user_id_fkey', 'bookings', 'users', ['user_id'], ['telegram_id'])
    op.create_table('apscheduler_jobs',
    sa.Column('id', sa.VARCHAR(length=191), autoincrement=False, nullable=False),
    sa.Column('next_run_time', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('job_state', postgresql.BYTEA(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='apscheduler_jobs_pkey')
    )
    op.create_index('ix_apscheduler_jobs_next_run_time', 'apscheduler_jobs', ['next_run_time'], unique=False)
    op.drop_table('unavailable_dates', schema='public')
    # ### end Alembic commands ###


--------------------------------------------------------------------------------
--- SKIPPED (binary or error): alembic/versions/.DS_Store | Reason: 'utf-8' codec can't decode byte 0xc1 in position 343: invalid start byte
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- FILE: alembic/versions/a1daaa3bb07b_add_comment_to_unavailable_dates.py
--------------------------------------------------------------------------------
"""Add comment to unavailable_dates

Revision ID: a1daaa3bb07b
Revises: 72be0060b370
Create Date: 2025-06-28 08:01:50.837662

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = 'a1daaa3bb07b'
down_revision: Union[str, None] = '72be0060b370'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index('ix_apscheduler_jobs_next_run_time', table_name='apscheduler_jobs')
    op.drop_table('apscheduler_jobs')
    op.drop_constraint('bookings_user_id_fkey', 'bookings', type_='foreignkey')
    op.drop_constraint('bookings_property_id_fkey', 'bookings', type_='foreignkey')
    op.create_foreign_key(None, 'bookings', 'users', ['user_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'bookings', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.drop_constraint('price_rules_property_id_fkey', 'price_rules', type_='foreignkey')
    op.create_foreign_key(None, 'price_rules', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.drop_constraint('properties_owner_id_fkey', 'properties', type_='foreignkey')
    op.create_foreign_key(None, 'properties', 'users', ['owner_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.drop_constraint('property_media_property_id_fkey', 'property_media', type_='foreignkey')
    op.create_foreign_key(None, 'property_media', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.drop_constraint('reviews_user_id_fkey', 'reviews', type_='foreignkey')
    op.drop_constraint('reviews_booking_id_fkey', 'reviews', type_='foreignkey')
    op.drop_constraint('reviews_property_id_fkey', 'reviews', type_='foreignkey')
    op.create_foreign_key(None, 'reviews', 'users', ['user_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'reviews', 'bookings', ['booking_id'], ['id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'reviews', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.drop_constraint('unavailable_dates_property_id_fkey', 'unavailable_dates', type_='foreignkey')
    op.create_foreign_key(None, 'unavailable_dates', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'unavailable_dates', schema='public', type_='foreignkey')
    op.create_foreign_key('unavailable_dates_property_id_fkey', 'unavailable_dates', 'properties', ['property_id'], ['id'])
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.create_foreign_key('reviews_property_id_fkey', 'reviews', 'properties', ['property_id'], ['id'])
    op.create_foreign_key('reviews_booking_id_fkey', 'reviews', 'bookings', ['booking_id'], ['id'])
    op.create_foreign_key('reviews_user_id_fkey', 'reviews', 'users', ['user_id'], ['telegram_id'])
    op.drop_constraint(None, 'property_media', schema='public', type_='foreignkey')
    op.create_foreign_key('property_media_property_id_fkey', 'property_media', 'properties', ['property_id'], ['id'])
    op.drop_constraint(None, 'properties', schema='public', type_='foreignkey')
    op.create_foreign_key('properties_owner_id_fkey', 'properties', 'users', ['owner_id'], ['telegram_id'])
    op.drop_constraint(None, 'price_rules', schema='public', type_='foreignkey')
    op.create_foreign_key('price_rules_property_id_fkey', 'price_rules', 'properties', ['property_id'], ['id'])
    op.drop_constraint(None, 'bookings', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'bookings', schema='public', type_='foreignkey')
    op.create_foreign_key('bookings_property_id_fkey', 'bookings', 'properties', ['property_id'], ['id'])
    op.create_foreign_key('bookings_user_id_fkey', 'bookings', 'users', ['user_id'], ['telegram_id'])
    op.create_table('apscheduler_jobs',
    sa.Column('id', sa.VARCHAR(length=191), autoincrement=False, nullable=False),
    sa.Column('next_run_time', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('job_state', postgresql.BYTEA(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='apscheduler_jobs_pkey')
    )
    op.create_index('ix_apscheduler_jobs_next_run_time', 'apscheduler_jobs', ['next_run_time'], unique=False)
    # ### end Alembic commands ###


--------------------------------------------------------------------------------
--- FILE: alembic/versions/b916a9cda604_add_price_rules_table.py
--------------------------------------------------------------------------------
"""Add price_rules table

Revision ID: b916a9cda604
Revises: 8eb8795be577
Create Date: 2025-06-27 14:24:17.874265

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = 'b916a9cda604'
down_revision: Union[str, None] = '8eb8795be577'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index('ix_apscheduler_jobs_next_run_time', table_name='apscheduler_jobs')
    op.drop_table('apscheduler_jobs')
    op.drop_constraint('bookings_user_id_fkey', 'bookings', type_='foreignkey')
    op.drop_constraint('bookings_property_id_fkey', 'bookings', type_='foreignkey')
    op.create_foreign_key(None, 'bookings', 'users', ['user_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'bookings', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.drop_constraint('price_rules_property_id_fkey', 'price_rules', type_='foreignkey')
    op.create_foreign_key(None, 'price_rules', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.drop_constraint('properties_owner_id_fkey', 'properties', type_='foreignkey')
    op.create_foreign_key(None, 'properties', 'users', ['owner_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.drop_constraint('property_media_property_id_fkey', 'property_media', type_='foreignkey')
    op.create_foreign_key(None, 'property_media', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.drop_constraint('reviews_user_id_fkey', 'reviews', type_='foreignkey')
    op.drop_constraint('reviews_property_id_fkey', 'reviews', type_='foreignkey')
    op.drop_constraint('reviews_booking_id_fkey', 'reviews', type_='foreignkey')
    op.create_foreign_key(None, 'reviews', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'reviews', 'users', ['user_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'reviews', 'bookings', ['booking_id'], ['id'], source_schema='public', referent_schema='public')
    op.drop_constraint('unavailable_dates_property_id_fkey', 'unavailable_dates', type_='foreignkey')
    op.create_foreign_key(None, 'unavailable_dates', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'unavailable_dates', schema='public', type_='foreignkey')
    op.create_foreign_key('unavailable_dates_property_id_fkey', 'unavailable_dates', 'properties', ['property_id'], ['id'])
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.create_foreign_key('reviews_booking_id_fkey', 'reviews', 'bookings', ['booking_id'], ['id'])
    op.create_foreign_key('reviews_property_id_fkey', 'reviews', 'properties', ['property_id'], ['id'])
    op.create_foreign_key('reviews_user_id_fkey', 'reviews', 'users', ['user_id'], ['telegram_id'])
    op.drop_constraint(None, 'property_media', schema='public', type_='foreignkey')
    op.create_foreign_key('property_media_property_id_fkey', 'property_media', 'properties', ['property_id'], ['id'])
    op.drop_constraint(None, 'properties', schema='public', type_='foreignkey')
    op.create_foreign_key('properties_owner_id_fkey', 'properties', 'users', ['owner_id'], ['telegram_id'])
    op.drop_constraint(None, 'price_rules', schema='public', type_='foreignkey')
    op.create_foreign_key('price_rules_property_id_fkey', 'price_rules', 'properties', ['property_id'], ['id'])
    op.drop_constraint(None, 'bookings', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'bookings', schema='public', type_='foreignkey')
    op.create_foreign_key('bookings_property_id_fkey', 'bookings', 'properties', ['property_id'], ['id'])
    op.create_foreign_key('bookings_user_id_fkey', 'bookings', 'users', ['user_id'], ['telegram_id'])
    op.create_table('apscheduler_jobs',
    sa.Column('id', sa.VARCHAR(length=191), autoincrement=False, nullable=False),
    sa.Column('next_run_time', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('job_state', postgresql.BYTEA(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='apscheduler_jobs_pkey')
    )
    op.create_index('ix_apscheduler_jobs_next_run_time', 'apscheduler_jobs', ['next_run_time'], unique=False)
    # ### end Alembic commands ###


--------------------------------------------------------------------------------
--- FILE: alembic/versions/8eb8795be577_add_price_rules_table.py
--------------------------------------------------------------------------------
"""Add price_rules table

Revision ID: 8eb8795be577
Revises: 229b2ca3612e
Create Date: 2025-06-25 21:42:49.968603

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '8eb8795be577'
down_revision: Union[str, None] = '229b2ca3612e'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('price_rules',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('property_id', sa.Integer(), nullable=False),
    sa.Column('start_date', sa.Date(), nullable=False),
    sa.Column('end_date', sa.Date(), nullable=False),
    sa.Column('price', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['property_id'], ['public.properties.id'], ),
    sa.PrimaryKeyConstraint('id'),
    schema='public'
    )
    op.drop_index('ix_apscheduler_jobs_next_run_time', table_name='apscheduler_jobs')
    op.drop_table('apscheduler_jobs')
    op.drop_constraint('bookings_property_id_fkey', 'bookings', type_='foreignkey')
    op.drop_constraint('bookings_user_id_fkey', 'bookings', type_='foreignkey')
    op.create_foreign_key(None, 'bookings', 'users', ['user_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'bookings', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.drop_constraint('properties_owner_id_fkey', 'properties', type_='foreignkey')
    op.create_foreign_key(None, 'properties', 'users', ['owner_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.drop_constraint('property_media_property_id_fkey', 'property_media', type_='foreignkey')
    op.create_foreign_key(None, 'property_media', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.drop_constraint('reviews_booking_id_fkey', 'reviews', type_='foreignkey')
    op.drop_constraint('reviews_property_id_fkey', 'reviews', type_='foreignkey')
    op.drop_constraint('reviews_user_id_fkey', 'reviews', type_='foreignkey')
    op.create_foreign_key(None, 'reviews', 'bookings', ['booking_id'], ['id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'reviews', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'reviews', 'users', ['user_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.drop_constraint('unavailable_dates_property_id_fkey', 'unavailable_dates', type_='foreignkey')
    op.create_foreign_key(None, 'unavailable_dates', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'unavailable_dates', schema='public', type_='foreignkey')
    op.create_foreign_key('unavailable_dates_property_id_fkey', 'unavailable_dates', 'properties', ['property_id'], ['id'])
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.create_foreign_key('reviews_user_id_fkey', 'reviews', 'users', ['user_id'], ['telegram_id'])
    op.create_foreign_key('reviews_property_id_fkey', 'reviews', 'properties', ['property_id'], ['id'])
    op.create_foreign_key('reviews_booking_id_fkey', 'reviews', 'bookings', ['booking_id'], ['id'])
    op.drop_constraint(None, 'property_media', schema='public', type_='foreignkey')
    op.create_foreign_key('property_media_property_id_fkey', 'property_media', 'properties', ['property_id'], ['id'])
    op.drop_constraint(None, 'properties', schema='public', type_='foreignkey')
    op.create_foreign_key('properties_owner_id_fkey', 'properties', 'users', ['owner_id'], ['telegram_id'])
    op.drop_constraint(None, 'bookings', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'bookings', schema='public', type_='foreignkey')
    op.create_foreign_key('bookings_user_id_fkey', 'bookings', 'users', ['user_id'], ['telegram_id'])
    op.create_foreign_key('bookings_property_id_fkey', 'bookings', 'properties', ['property_id'], ['id'])
    op.create_table('apscheduler_jobs',
    sa.Column('id', sa.VARCHAR(length=191), autoincrement=False, nullable=False),
    sa.Column('next_run_time', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('job_state', postgresql.BYTEA(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='apscheduler_jobs_pkey')
    )
    op.create_index('ix_apscheduler_jobs_next_run_time', 'apscheduler_jobs', ['next_run_time'], unique=False)
    op.drop_table('price_rules', schema='public')
    # ### end Alembic commands ###


--------------------------------------------------------------------------------
--- FILE: alembic/versions/0372a3ff3322_final_schema.py
--------------------------------------------------------------------------------
"""Final schema

Revision ID: 0372a3ff3322
Revises: 
Create Date: 2025-06-20 19:09:27.554564

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '0372a3ff3322'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
    sa.Column('telegram_id', sa.BigInteger(), nullable=False),
    sa.Column('username', sa.String(length=32), nullable=True),
    sa.Column('first_name', sa.String(length=64), nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=True),
    sa.Column('role', sa.String(length=20), nullable=False),
    sa.PrimaryKeyConstraint('telegram_id'),
    sa.UniqueConstraint('username'),
    schema='public'
    )
    op.create_table('properties',
    sa.Column('owner_id', sa.BigInteger(), nullable=False),
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('title', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('address', sa.String(length=255), nullable=False),
    sa.Column('district', sa.String(length=50), nullable=False),
    sa.Column('rooms', sa.Integer(), nullable=False),
    sa.Column('price_per_night', sa.Integer(), nullable=False),
    sa.Column('max_guests', sa.Integer(), nullable=False),
    sa.Column('property_type', sa.String(length=50), nullable=False),
    sa.Column('is_verified', sa.Boolean(), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['owner_id'], ['public.users.telegram_id'], ),
    sa.PrimaryKeyConstraint('id'),
    schema='public'
    )
    op.create_table('bookings',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('property_id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.BigInteger(), nullable=False),
    sa.Column('start_date', sa.DateTime(), nullable=False),
    sa.Column('end_date', sa.DateTime(), nullable=False),
    sa.Column('status', sa.String(length=20), nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['property_id'], ['public.properties.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['public.users.telegram_id'], ),
    sa.PrimaryKeyConstraint('id'),
    schema='public'
    )
    op.create_table('property_media',
    sa.Column('property_id', sa.Integer(), nullable=False),
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('file_id', sa.String(length=255), nullable=False),
    sa.Column('media_type', sa.String(length=10), nullable=False),
    sa.ForeignKeyConstraint(['property_id'], ['public.properties.id'], ),
    sa.PrimaryKeyConstraint('id'),
    schema='public'
    )
    op.create_table('reviews',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('property_id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.BigInteger(), nullable=False),
    sa.Column('booking_id', sa.Integer(), nullable=False),
    sa.Column('rating', sa.Integer(), nullable=False),
    sa.Column('text', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['booking_id'], ['public.bookings.id'], ),
    sa.ForeignKeyConstraint(['property_id'], ['public.properties.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['public.users.telegram_id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('booking_id'),
    schema='public'
    )
    op.drop_index('ix_apscheduler_jobs_next_run_time', table_name='apscheduler_jobs')
    op.drop_table('apscheduler_jobs')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('apscheduler_jobs',
    sa.Column('id', sa.VARCHAR(length=191), autoincrement=False, nullable=False),
    sa.Column('next_run_time', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('job_state', postgresql.BYTEA(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='apscheduler_jobs_pkey')
    )
    op.create_index('ix_apscheduler_jobs_next_run_time', 'apscheduler_jobs', ['next_run_time'], unique=False)
    op.drop_table('reviews', schema='public')
    op.drop_table('property_media', schema='public')
    op.drop_table('bookings', schema='public')
    op.drop_table('properties', schema='public')
    op.drop_table('users', schema='public')
    # ### end Alembic commands ###


--------------------------------------------------------------------------------
--- FILE: alembic/versions/72be0060b370_add_price_rules_table.py
--------------------------------------------------------------------------------
"""Add price_rules table

Revision ID: 72be0060b370
Revises: b916a9cda604
Create Date: 2025-06-27 14:28:38.507276

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '72be0060b370'
down_revision: Union[str, None] = 'b916a9cda604'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index('ix_apscheduler_jobs_next_run_time', table_name='apscheduler_jobs')
    op.drop_table('apscheduler_jobs')
    op.drop_constraint('bookings_user_id_fkey', 'bookings', type_='foreignkey')
    op.drop_constraint('bookings_property_id_fkey', 'bookings', type_='foreignkey')
    op.create_foreign_key(None, 'bookings', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'bookings', 'users', ['user_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.drop_constraint('price_rules_property_id_fkey', 'price_rules', type_='foreignkey')
    op.create_foreign_key(None, 'price_rules', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.drop_constraint('properties_owner_id_fkey', 'properties', type_='foreignkey')
    op.create_foreign_key(None, 'properties', 'users', ['owner_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.drop_constraint('property_media_property_id_fkey', 'property_media', type_='foreignkey')
    op.create_foreign_key(None, 'property_media', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.drop_constraint('reviews_booking_id_fkey', 'reviews', type_='foreignkey')
    op.drop_constraint('reviews_user_id_fkey', 'reviews', type_='foreignkey')
    op.drop_constraint('reviews_property_id_fkey', 'reviews', type_='foreignkey')
    op.create_foreign_key(None, 'reviews', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'reviews', 'users', ['user_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'reviews', 'bookings', ['booking_id'], ['id'], source_schema='public', referent_schema='public')
    op.add_column('unavailable_dates', sa.Column('comment', sa.String(length=100), nullable=True))
    op.drop_constraint('unavailable_dates_property_id_fkey', 'unavailable_dates', type_='foreignkey')
    op.create_foreign_key(None, 'unavailable_dates', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'unavailable_dates', schema='public', type_='foreignkey')
    op.create_foreign_key('unavailable_dates_property_id_fkey', 'unavailable_dates', 'properties', ['property_id'], ['id'])
    op.drop_column('unavailable_dates', 'comment')
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.create_foreign_key('reviews_property_id_fkey', 'reviews', 'properties', ['property_id'], ['id'])
    op.create_foreign_key('reviews_user_id_fkey', 'reviews', 'users', ['user_id'], ['telegram_id'])
    op.create_foreign_key('reviews_booking_id_fkey', 'reviews', 'bookings', ['booking_id'], ['id'])
    op.drop_constraint(None, 'property_media', schema='public', type_='foreignkey')
    op.create_foreign_key('property_media_property_id_fkey', 'property_media', 'properties', ['property_id'], ['id'])
    op.drop_constraint(None, 'properties', schema='public', type_='foreignkey')
    op.create_foreign_key('properties_owner_id_fkey', 'properties', 'users', ['owner_id'], ['telegram_id'])
    op.drop_constraint(None, 'price_rules', schema='public', type_='foreignkey')
    op.create_foreign_key('price_rules_property_id_fkey', 'price_rules', 'properties', ['property_id'], ['id'])
    op.drop_constraint(None, 'bookings', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'bookings', schema='public', type_='foreignkey')
    op.create_foreign_key('bookings_property_id_fkey', 'bookings', 'properties', ['property_id'], ['id'])
    op.create_foreign_key('bookings_user_id_fkey', 'bookings', 'users', ['user_id'], ['telegram_id'])
    op.create_table('apscheduler_jobs',
    sa.Column('id', sa.VARCHAR(length=191), autoincrement=False, nullable=False),
    sa.Column('next_run_time', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('job_state', postgresql.BYTEA(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='apscheduler_jobs_pkey')
    )
    op.create_index('ix_apscheduler_jobs_next_run_time', 'apscheduler_jobs', ['next_run_time'], unique=False)
    # ### end Alembic commands ###


