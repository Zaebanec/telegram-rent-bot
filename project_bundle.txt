# BUNDLE OF PROJECT: /root/telegram-rent-bot

--------------------------------------------------------------------------------
--- FILE: docker-compose.yml
--------------------------------------------------------------------------------
services:
  # --- СЕРВИС ДЛЯ ОСНОВНОГО БОТА ---
  bot:
    build: .
    env_file: .env
    volumes:
      # --- ИЗМЕНЕНИЕ ЗДЕСЬ: Монтируем текущую папку в /src ---
      # Теперь путь на хосте (например, ./src/core) совпадает с путем в контейнере (/src/src/core)
      # Это не совсем верно, давайте исправим.
      # Правильно: монтируем содержимое текущей папки в /src
      - .:/src
    ports:
      - "8080:8080"
    depends_on:
      - db
      - redis
    restart: always

  # --- СЕРВИС ДЛЯ ОСНОВНОЙ БАЗЫ ДАННЫХ ---
  db:
    image: postgres:16-alpine
    env_file: .env
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    restart: always

  # --- СЕРВИС ДЛЯ REDIS ---
  redis:
    image: redis:7-alpine
    restart: always

  # --- НОВЫЙ СЕРВИС ДЛЯ ТЕСТОВОЙ БД ---
  test_db:
    image: postgres:16-alpine
    env_file: .env
    environment:
      POSTGRES_DB: test_rent_bot_db
    restart: always

  # --- НОВЫЙ СЕРВИС ДЛЯ ЗАПУСКА ТЕСТОВ ---
  tests:
    build: .
    depends_on:
      - test_db
    env_file: .env
    volumes:
      # --- ИЗМЕНЕНИЕ ЗДЕСЬ: Монтируем текущую папку в /src ---
      - .:/src
    environment:
      POSTGRES_HOST: test_db
      POSTGRES_DB: test_rent_bot_db
    command: ["pytest", "-v"]

# --- СЕКЦИЯ ДЛЯ ТОМОВ (VOLUMES) ---
volumes:
  postgres_data:

--------------------------------------------------------------------------------
--- FILE: project_structure.txt
--------------------------------------------------------------------------------
.
├── alembic
│   ├── __pycache__
│   │   └── env.cpython-311.pyc
│   ├── env.py
│   ├── README
│   ├── script.py.mako
│   └── versions
│       ├── __pycache__
│       │   └── e511f78981e8_add_district_and_rooms_update_fsm.cpython-311.pyc
│       └── e511f78981e8_add_district_and_rooms_update_fsm.py
├── alembic.ini
├── app
│   ├── core
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-311.pyc
│   │   │   ├── commands.cpython-311.pyc
│   │   │   ├── constants.cpython-311.pyc
│   │   │   └── settings.cpython-311.pyc
│   │   ├── commands.py
│   │   ├── constants.py
│   │   └── settings.py
│   ├── handlers
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-311.pyc
│   │   │   ├── admin_handlers.cpython-311.pyc
│   │   │   ├── owner_handlers.cpython-311.pyc
│   │   │   └── user_handlers.cpython-311.pyc
│   │   ├── admin_handlers.py
│   │   ├── owner_handlers.py
│   │   └── user_handlers.py
│   ├── keyboards
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-311.pyc
│   │   │   └── inline_keyboards.cpython-311.pyc
│   │   └── inline_keyboards.py
│   ├── models
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-311.pyc
│   │   │   ├── base.cpython-311.pyc
│   │   │   └── models.cpython-311.pyc
│   │   ├── base.py
│   │   └── models.py
│   ├── services
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-311.pyc
│   │   │   └── repository.cpython-311.pyc
│   │   └── repository.py
│   └── utils
│       ├── __init__.py
│       ├── __pycache__
│       │   ├── __init__.cpython-311.pyc
│       │   └── states.cpython-311.pyc
│       └── states.py
├── docker-compose.yml
├── Dockerfile
├── main.py
├── project_structure.txt
├── requirements.txt
└── tests

19 directories, 46 files


--------------------------------------------------------------------------------
--- FILE: project_bundle.txt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--- FILE: pytest.ini
--------------------------------------------------------------------------------
[pytest]
pythonpath = .
asyncio_mode = auto

--------------------------------------------------------------------------------
--- FILE: alembic.ini
--------------------------------------------------------------------------------
# A generic, single database configuration.

[alembic]
# path to migration scripts
# Use forward slashes (/) also on windows to provide an os agnostic path
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to alembic/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:alembic/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
version_path_separator = os  # Use os.pathsep. Default configuration used for new projects.

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = driver://user:pass@localhost/dbname


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S


--------------------------------------------------------------------------------
--- SKIPPED (binary or error): .DS_Store | Reason: 'utf-8' codec can't decode byte 0x80 in position 3131: invalid start byte
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- FILE: readme.txt
--------------------------------------------------------------------------------
# Telegram Rent Bot: AI-Гид по Калининграду

Этот проект представляет собой многофункционального Telegram-бота, предназначенного для аренды жилья в Калининградской области. На текущем этапе реализован MVP для владельцев недвижимости, в активной разработке находится функционал для клиентов.

Глобальная цель проекта — создание комплексного AI-помощника для туристов.

## Технологический стек

- **Бэкенд:** Python 3.11
- **Telegram Bot API:** `aiogram` 3.x
- **Веб-сервер:** `aiohttp` (для Telegram Web Apps)
- **База данных:** `PostgreSQL`
- **ORM и Миграции:** `SQLAlchemy` 2.0, `Alembic`
- **Кэш / FSM:** `Redis`
- **Окружение:** `Docker`, `Docker Compose`

---

## Быстрый старт (Локальная разработка)

### 1. Предварительные требования

- Установленный [Docker](https://www.docker.com/get-started/) и Docker Compose.
- Git.

### 2. Настройка окружения

1.  **Клонируйте репозиторий:**
    ```bash
    git clone https://github.com/Zaebanec/telegram-rent-bot.git
    cd telegram-rent-bot
    ```

2.  **Создайте файл с переменными окружения:**
    Скопируйте файл `.env.example` в `.env` и заполните его вашими данными.
    ```bash
    cp .env.example .env
    ```
    Обязательно укажите ваш `BOT_TOKEN`.

### 3. Запуск проекта

1.  **Сборка и запуск контейнеров:**
    Эта команда запустит бота, базу данных и Redis в фоновом режиме.
    ```bash
    docker-compose up --build -d
    ```

2.  **Применение миграций базы данных (ВАЖНО!)**
    При первом запуске или после внесения изменений в модели данных (`app/models/models.py`), необходимо применить миграции. **Эта команда выполняется отдельно.**
    ```bash
    docker-compose run --rm bot alembic upgrade head
    ```

### 4. Остановка проекта

Чтобы остановить все сервисы, выполните:
```bash
docker-compose down

Управление миграциями Alembic
Создание новой миграции (после изменения моделей):
Generated bash
docker-compose run --rm bot alembic revision --autogenerate -m "Краткое описание изменений"
Use code with caution.
Bash
Применение последней миграции:
Generated bash
docker-compose run --rm bot alembic upgrade head
Use code with caution.
Bash
Откат последней миграции:
Generated bash
docker-compose run --rm bot alembic downgrade -1

--------------------------------------------------------------------------------
--- FILE: .env
--------------------------------------------------------------------------------
# Telegram Bot Token
BOT_TOKEN=8088668796:AAFvLtI83X8dmcwyxuKQDGy9z35emtg4irI
ADMIN_IDS='[6180797700]'
# PostgreSQL Settings
POSTGRES_USER=myuser
POSTGRES_PASSWORD=mypassword
POSTGRES_DB=rent_bot_db
POSTGRES_HOST=db
POSTGRES_PORT=5432

# Redis Settings
REDIS_HOST=redis
REDIS_PORT=6379

WEBHOOK_SECRET="some-super-secret-string-12345"
WEB_APP_BASE_URL=https://24kalinrentbot.ru


--------------------------------------------------------------------------------
--- FILE: Dockerfile
--------------------------------------------------------------------------------
# 1. Используем официальный образ Python как основу
FROM python:3.11-slim

# --- ИЗМЕНЕНИЕ ЗДЕСЬ: Устанавливаем правильную рабочую директорию ---
WORKDIR /src

# 3. Копируем файл с зависимостями в контейнер
COPY requirements.txt .

# 4. Устанавливаем зависимости
# Добавляем --no-cache-dir для уменьшения размера образа
RUN pip install --no-cache-dir -r requirements.txt

# 5. Копируем весь код нашего приложения в контейнер
COPY . .

# 6. Команда, которая будет запускать бота при старте контейнера
# Python будет искать main.py в рабочей директории /src
CMD ["python", "main.py"]

--------------------------------------------------------------------------------
--- FILE: requirements.txt
--------------------------------------------------------------------------------
# Фреймворк для бота
aiogram==3.10.0

# Работа с базой данных PostgreSQL
sqlalchemy==2.0.31
alembic==1.13.2
asyncpg==0.29.0
psycopg2-binary==2.9.9

# Работа с Redis (для машины состояний FSM)
redis==5.0.7

# Загрузка переменных окружения из .env файла
python-dotenv==1.0.1

# Для типизации и валидации настроек (лучшая практика)
pydantic==2.8.2
pydantic-settings==2.4.0

# Планировщик фоновых задач
apscheduler==3.10.4

# Календарь для aiogram 3
aiogram_calendar==0.6.0

# Веб-сервер
aiohttp

# --- НОВАЯ ЗАВИСИМОСТЬ ---
# Для настройки CORS (Cross-Origin Resource Sharing)
aiohttp-cors==0.7.0

# --- ЗАВИСИМОСТИ ДЛЯ ТЕСТИРОВАНИЯ ---
pytest==8.3.2
pytest-asyncio==0.23.8

--------------------------------------------------------------------------------
--- FILE: .env.example
--------------------------------------------------------------------------------
# Telegram Bot Token
BOT_TOKEN=ВАШ_ТЕЛЕГРАМ_ТОКЕН_ЗДЕСЬ

# PostgreSQL Settings
POSTGRES_USER=myuser
POSTGRES_PASSWORD=mypassword
POSTGRES_DB=rent_bot_db
POSTGRES_HOST=db
POSTGRES_PORT=5432

# Redis Settings
REDIS_HOST=redis
REDIS_PORT=6379

WEBHOOK_SECRET="some-super-secret-string-12345"

--------------------------------------------------------------------------------
--- FILE: check_webhook.py
--------------------------------------------------------------------------------
import requests
import os
from dotenv import load_dotenv

# Загружаем переменные из вашего .env файла
load_dotenv()

# Получаем токен бота
BOT_TOKEN = os.getenv("BOT_TOKEN")
if not BOT_TOKEN:
    print("Ошибка: Не удалось найти BOT_TOKEN в .env файле.")
    exit()

# Формируем URL для запроса информации о вебхуке
url = f"https://api.telegram.org/bot{BOT_TOKEN}/getWebhookInfo"

try:
    # Отправляем запрос
    response = requests.get(url)
    response.raise_for_status()  # Проверяем, что ответ успешный (статус 2xx)
    
    # Печатаем результат в красивом виде
    data = response.json()
    print("="*50)
    print("ИНФОРМАЦИЯ О ВЕБХУКЕ:")
    print("="*50)
    if data.get("ok"):
        result = data.get("result", {})
        print(f"URL вебхука: {result.get('url', 'Не установлен')}")
        print(f"Ожидает обновлений: {result.get('pending_update_count', 0)}")
        if result.get('last_error_date'):
            import datetime
            error_time = datetime.datetime.fromtimestamp(result['last_error_date']).strftime('%Y-%m-%d %H:%M:%S')
            print(f"!!! ПОСЛЕДНЯЯ ОШИБКА ДОСТАВКИ: {error_time}")
            print(f"!!! СООБЩЕНИЕ ОБ ОШИБКЕ: {result.get('last_error_message', 'Нет сообщения')}")
        else:
            print("Последних ошибок доставки нет.")
    else:
        print("Не удалось получить информацию. Ответ от API:")
        print(data)
    print("="*50)

except requests.exceptions.RequestException as e:
    print(f"Ошибка сети при запросе к Telegram API: {e}")

--------------------------------------------------------------------------------
--- FILE: gitignore
--------------------------------------------------------------------------------
# Файлы кэша Python
__pycache__/
*.pyc
*.pyo
*.pyd

# Виртуальные окружения
venv/
env/
.venv/

# Файлы IDE и редакторов
.vscode/
.idea/

# Файлы операционной системы
.DS_Store
Thumbs.db

# Файлы с секретами и переменными окружения
# ВАЖНО: Никогда не добавляйте файлы с паролями, токенами, ключами API в Git!
.env
*.env

# Лог-файлы
*.log

--------------------------------------------------------------------------------
--- FILE: run.py
--------------------------------------------------------------------------------
import os

# --- Настройки ---
# Папки и файлы, которые нужно исключить из сборки
EXCLUDE_DIRS = {'.git', '.idea', '.vscode', '__pycache__', '.venv', 'venv'}
EXCLUDE_FILES = {'.gitignore', 'project_archive.zip', 'bundle_for_ai.py'}
# Имя выходного файла
OUTPUT_FILE = 'project_bundle.txt'
# --- Конец настроек ---

def bundle_project(project_path='.'):
    """Собирает все текстовые файлы проекта в один .txt файл."""
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f_out:
        f_out.write(f"# BUNDLE OF PROJECT: {os.path.abspath(project_path)}\n\n")
        for root, dirs, files in os.walk(project_path):
            # Исключаем ненужные директории
            dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]

            for file in files:
                if file in EXCLUDE_FILES:
                    continue

                file_path = os.path.join(root, file)
                relative_path = os.path.relpath(file_path, project_path)

                try:
                    with open(file_path, 'r', encoding='utf-8') as f_in:
                        content = f_in.read()
                    
                    f_out.write("-" * 80 + "\n")
                    f_out.write(f"--- FILE: {relative_path.replace(os.sep, '/')}\n")
                    f_out.write("-" * 80 + "\n")
                    f_out.write(content)
                    f_out.write("\n\n")
                    print(f"[+] Added: {relative_path}")

                except Exception as e:
                    # Пропускаем бинарные файлы или файлы с проблемами кодировки
                    f_out.write("-" * 80 + "\n")
                    f_out.write(f"--- SKIPPED (binary or error): {relative_path.replace(os.sep, '/')} | Reason: {e}\n")
                    f_out.write("-" * 80 + "\n\n")
                    print(f"[-] Skipped: {relative_path} ({e})")

    print(f"\nProject bundled into: {OUTPUT_FILE}")

if __name__ == '__main__':
    bundle_project()

--------------------------------------------------------------------------------
--- FILE: main.py
--------------------------------------------------------------------------------
import asyncio
import logging
import sys

from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.types import Message
from aiohttp import web
import aiohttp_cors

from src.core.settings import settings
from src.core.commands import set_commands
from src.core.scheduler import scheduler
from src.handlers import main_router
# --- ИЗМЕНЕНИЕ: Импортируем ВСЕ необходимые обработчики ---
from src.web.routes import (
    webhook_handler, 
    client_webapp_handler, 
    owner_webapp_handler, # <-- Возвращаем
    get_calendar_data,
    set_availability,
    add_price_rule
)

async def on_startup(app: web.Application):
    bot: Bot = app["bot"]
    base_url = app["base_url"]
    webhook_secret = app["webhook_secret"]
    
    await set_commands(bot)
    await bot.set_webhook(
        f"{base_url}/webhook",
        secret_token=webhook_secret,
        allowed_updates=["message", "callback_query", "my_chat_member", "chat_member"]
    )
    logging.info("Webhook has been set.")

async def on_shutdown(app: web.Application):
    bot: Bot = app["bot"]
    await bot.delete_webhook()
    logging.info("Webhook has been deleted.")

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, stream=sys.stdout)

    bot = Bot(
        token=settings.BOT_TOKEN.get_secret_value(),
        default=DefaultBotProperties(parse_mode=ParseMode.HTML)
    )
    dp = Dispatcher()
    
    # Убираем тестовый обработчик, он нам больше не нужен
    # dp.message.register(temporary_webapp_catcher, F.web_app_data)
    dp.include_router(main_router)

    app = web.Application()
    
    app["bot"] = bot
    app["dp"] = dp
    app["base_url"] = settings.WEB_APP_BASE_URL
    app["webhook_secret"] = settings.WEBHOOK_SECRET.get_secret_value()

    # --- ИЗМЕНЕНИЕ: Полная и правильная регистрация всех роутов ---
    app.router.add_static('/static/', path='src/static', name='static')
    app.router.add_get("/webapp/client", client_webapp_handler)
    app.router.add_get("/webapp/owner", owner_webapp_handler) # <-- Возвращаем
    app.router.add_post("/webhook", webhook_handler)
    
    cors = aiohttp_cors.setup(app, defaults={
        "*": aiohttp_cors.ResourceOptions(
            allow_credentials=True, expose_headers="*",
            allow_headers="*", allow_methods="*",
        )
    })
    
    calendar_resource = cors.add(app.router.add_resource('/api/calendar_data/{property_id}'))
    cors.add(calendar_resource.add_route("GET", get_calendar_data))
    
    set_availability_resource = cors.add(app.router.add_resource('/api/owner/set_availability'))
    cors.add(set_availability_resource.add_route("POST", set_availability))
    
    pricing_resource = cors.add(app.router.add_resource('/api/owner/price_rule'))
    cors.add(pricing_resource.add_route("POST", add_price_rule))

    app.on_startup.append(on_startup)
    app.on_shutdown.append(on_shutdown)

    scheduler.start()

    try:
        web.run_app(app, host="0.0.0.0", port=8080)
    except (KeyboardInterrupt, SystemExit):
        logging.info("Bot stopped!")

--------------------------------------------------------------------------------
--- FILE: tests/conftest.py
--------------------------------------------------------------------------------
import asyncio
import pytest
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker

from src.core.settings import settings
from src.models.base import Base
from src.services.db import async_session_maker as main_async_session_maker

# Создаем отдельный движок и сессию для тестовой БД
test_engine = create_async_engine(settings.DATABASE_URL_asyncpg)
test_async_session_maker = async_sessionmaker(test_engine, expire_on_commit=False)


@pytest.fixture(scope="session", autouse=True)
def event_loop():
    """
    Создает экземпляр цикла событий для всех тестов.
    Эта реализация вызывает DeprecationWarning, но она РАБОТАЕТ.
    Мы вернемся к исправлению предупреждения позже, отдельной задачей.
    """
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()


@pytest.fixture(scope="session", autouse=True)
async def setup_database():
    """
    Фикстура для создания и удаления таблиц в тестовой БД.
    """
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)
        await conn.run_sync(Base.metadata.create_all)
    yield
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)


@pytest.fixture(scope="function")
async def db_session():
    """
    Фикстура, которая предоставляет сессию БД для каждого теста.
    """
    main_async_session_maker.kw['bind'] = test_engine
    
    async with test_async_session_maker() as session:
        await session.begin_nested()
        yield session
        await session.rollback()

--------------------------------------------------------------------------------
--- FILE: tests/services/test_user_service.py
--------------------------------------------------------------------------------
import pytest
from sqlalchemy.ext.asyncio import AsyncSession
from src.services.user_service import add_user, get_user

pytestmark = pytest.mark.asyncio

async def test_add_and_get_user(db_session: AsyncSession):
    test_user_id = 123
    created_user = await add_user(test_user_id, "test", "Test")
    retrieved_user = await get_user(test_user_id)
    assert retrieved_user is not None
    assert retrieved_user.telegram_id == test_user_id

async def test_add_existing_user(db_session: AsyncSession):
    test_user_id = 456
    await add_user(test_user_id, "existing", "First")
    # В нашей реализации add_user не обновляет данные, а просто возвращает существующего
    # Это нормально, но тест должен это проверять
    user_again = await add_user(test_user_id, "new_username", "NewName")
    assert user_again.first_name == "First"

--------------------------------------------------------------------------------
--- FILE: tests/services/test_booking_service.py
--------------------------------------------------------------------------------
import pytest
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession

from src.services.user_service import add_user
from src.services.property_service import add_property
from src.services.booking_service import (
    create_booking, 
    update_booking_status, 
    get_booked_dates_for_property,
    count_pending_bookings_for_owner
)

pytestmark = pytest.mark.asyncio


# Мы УДАЛИЛИ фикстуру setup_for_booking


async def test_create_and_count_pending_booking(db_session: AsyncSession):
    """
    Тест: проверяем создание бронирования и счетчик ожидающих заявок.
    """
    # --- ИЗМЕНЕНИЕ: Вся подготовка данных теперь внутри теста ---
    owner = await add_user(telegram_id=1001, username="booking_owner_1", first_name="Owner")
    client = await add_user(telegram_id=2002, username="booking_client_1", first_name="Client")
    property_data = {"title": "Объект 1", "district": "Бронь", "address": "a", "rooms": "1", "price_per_night": "1000", "max_guests": "1", "property_type": "Квартира"}
    property_id = await add_property(property_data, owner_id=owner.telegram_id)
    
    # 1. Проверка до создания
    pending_count_before = await count_pending_bookings_for_owner(owner.telegram_id)
    assert pending_count_before == 0

    # 2. Выполнение: создаем бронирование
    start_date = datetime(2025, 10, 1)
    end_date = datetime(2025, 10, 5)
    new_booking = await create_booking(
        user_id=client.telegram_id,
        property_id=property_id,
        start_date=start_date,
        end_date=end_date
    )

    # 3. Проверка после создания
    assert new_booking is not None
    assert new_booking.status == 'pending'
    
    pending_count_after = await count_pending_bookings_for_owner(owner.telegram_id)
    assert pending_count_after == 1


async def test_update_booking_status_and_dates(db_session: AsyncSession):
    """
    Тест: проверяем обновление статуса брони и получение списка занятых дат.
    """
    # --- ИЗМЕНЕНИЕ: Вся подготовка данных теперь внутри теста ---
    owner = await add_user(telegram_id=3003, username="booking_owner_2", first_name="Owner")
    client = await add_user(telegram_id=4004, username="booking_client_2", first_name="Client")
    property_data = {"title": "Объект 2", "district": "Бронь", "address": "b", "rooms": "2", "price_per_night": "2000", "max_guests": "2", "property_type": "Дом"}
    property_id = await add_property(property_data, owner_id=owner.telegram_id)

    start_date = datetime(2025, 11, 10)
    end_date = datetime(2025, 11, 12) # 2 ночи: 10 и 11
    booking = await create_booking(client.telegram_id, property_id, start_date, end_date)

    # 1. Проверка до обновления
    booked_dates_before = await get_booked_dates_for_property(property_id)
    assert len(booked_dates_before) == 0

    # 2. Выполнение: подтверждаем бронь
    await update_booking_status(booking.id, "confirmed")

    # 3. Проверка после обновления
    booked_dates_after = await get_booked_dates_for_property(property_id)
    assert len(booked_dates_after) == 2
    assert start_date.date() in booked_dates_after
    assert (start_date.date() + timedelta(days=1)) in booked_dates_after
    assert end_date.date() not in booked_dates_after

--------------------------------------------------------------------------------
--- FILE: tests/services/test_property_service.py
--------------------------------------------------------------------------------
import pytest
from sqlalchemy.ext.asyncio import AsyncSession

# Импортируем сервисы, которые будем тестировать и которые нужны для подготовки данных
from src.services.user_service import add_user
from src.services.property_service import (
    add_property, 
    get_all_properties, 
    get_properties_by_owner,
    toggle_property_activity,
    delete_property
)

pytestmark = pytest.mark.asyncio


async def test_add_and_get_property(db_session: AsyncSession):
    """
    Тест: проверяем успешное добавление объекта и его получение из БД.
    """
    # 1. Подготовка: создаем тестового пользователя-владельца
    owner = await add_user(telegram_id=111, username="owner1", first_name="Owner")

    # 2. Подготовка: данные для нового объекта
    property_data = {
        "title": "Тестовый Лофт",
        "description": "Отличное место для отдыха",
        "district": "Центральный",
        "address": "ул. Тестовая, 1",
        "rooms": "2",
        "price_per_night": "5000",
        "max_guests": "4",
        "property_type": "Квартира"
    }

    # 3. Выполнение: добавляем объект в БД
    property_id = await add_property(property_data, owner_id=owner.telegram_id)

    # 4. Проверка: получаем все объекты и убеждаемся, что наш объект там есть
    all_properties = await get_all_properties(districts=["Центральный"])
    
    assert len(all_properties) == 1
    new_property = all_properties[0]
    assert new_property.id == property_id
    assert new_property.title == "Тестовый Лофт"
    assert new_property.owner_id == owner.telegram_id
    # Проверяем, что строковые значения корректно преобразовались в числовые
    assert new_property.rooms == 2
    assert new_property.price_per_night == 5000
    assert new_property.max_guests == 4


async def test_toggle_property_activity(db_session: AsyncSession):
    """
    Тест: проверяем активацию и деактивацию объекта.
    """
    # 1. Подготовка: создаем владельца и его объект
    owner = await add_user(telegram_id=222, username="owner2", first_name="Owner")
    property_data = {"title": "Активный объект", "district": "Тест", "address": "a", "rooms": "1", "price_per_night": "1000", "max_guests": "1", "property_type": "Апартаменты"}
    property_id = await add_property(property_data, owner_id=owner.telegram_id)

    # 2. Выполнение и Проверка:
    # Изначально объект активен (is_active=True по умолчанию)
    props_before = await get_properties_by_owner(owner.telegram_id)
    assert props_before[0].is_active is True

    # Деактивируем объект
    await toggle_property_activity(property_id)
    props_after_toggle = await get_properties_by_owner(owner.telegram_id)
    assert props_after_toggle[0].is_active is False

    # Снова активируем
    await toggle_property_activity(property_id)
    props_after_second_toggle = await get_properties_by_owner(owner.telegram_id)
    assert props_after_second_toggle[0].is_active is True


async def test_delete_property(db_session: AsyncSession):
    """
    Тест: проверяем удаление объекта.
    """
    # 1. Подготовка: создаем владельца и его объект
    owner = await add_user(telegram_id=333, username="owner3", first_name="Owner")
    property_data = {"title": "Объект на удаление", "district": "Тест", "address": "a", "rooms": "1", "price_per_night": "1000", "max_guests": "1", "property_type": "Дом"}
    property_id = await add_property(property_data, owner_id=owner.telegram_id)

    # 2. Проверка до удаления
    props_before = await get_properties_by_owner(owner.telegram_id)
    assert len(props_before) == 1

    # 3. Выполнение: удаляем объект
    await delete_property(property_id)

    # 4. Проверка после удаления
    props_after = await get_properties_by_owner(owner.telegram_id)
    assert len(props_after) == 0

--------------------------------------------------------------------------------
--- SKIPPED (binary or error): alembic/.DS_Store | Reason: 'utf-8' codec can't decode byte 0xff in position 570: invalid start byte
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- FILE: alembic/script.py.mako
--------------------------------------------------------------------------------
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}


--------------------------------------------------------------------------------
--- FILE: alembic/env.py
--------------------------------------------------------------------------------
import sys
from logging.config import fileConfig
from os.path import abspath, dirname

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# --- НАШИ ДОБАВЛЕНИЯ НАЧИНАЮТСЯ ЗДЕСЬ ---

# Это нужно, чтобы Alembic мог найти наши модули 'app'
sys.path.insert(0, dirname(dirname(abspath(__file__))))

# 1. Импортируем наши настройки и базовую модель из SQLAlchemy
from src.core.settings import settings
from src.models.base import Base # Мы создадим этот файл на следующем шаге

# --- НАШИ ДОБАВЛЕНИЯ ЗАКАНЧИВАЮТСЯ ЗДЕСЬ ---


# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# --- НАШИ ИЗМЕНЕНИЯ ЗДЕСЬ ---
# Устанавливаем URL базы данных из наших настроек
# Это самая важная строка, она говорит Alembic, куда подключаться
config.set_main_option('sqlalchemy.url', settings.DATABASE_URL_psycopg)
# --- КОНЕЦ ИЗМЕНЕНИЙ ---


# Interpret the config file for Python logging.
# This line needs to be placed after an `import logging`.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
# --- НАШИ ИЗМЕНЕНИЯ ЗДЕСЬ ---
# Указываем Alembic на метаданные наших моделей
target_metadata = Base.metadata
# --- КОНЕЦ ИЗМЕНЕНИЙ ---


# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

--------------------------------------------------------------------------------
--- FILE: alembic/README
--------------------------------------------------------------------------------
Generic single-database configuration.

--------------------------------------------------------------------------------
--- FILE: alembic/versions/2bf2bba148b0_initial_migration_from_final_models.py
--------------------------------------------------------------------------------
"""Initial migration from final models

Revision ID: 2bf2bba148b0
Revises: 
Create Date: 2025-06-30 13:50:13.953448

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '2bf2bba148b0'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
    sa.Column('telegram_id', sa.BigInteger(), nullable=False),
    sa.Column('username', sa.String(length=32), nullable=True),
    sa.Column('first_name', sa.String(length=64), nullable=False),
    sa.Column('role', sa.String(length=20), nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.PrimaryKeyConstraint('telegram_id'),
    sa.UniqueConstraint('username'),
    schema='public'
    )
    op.create_table('properties',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('owner_id', sa.BigInteger(), nullable=False),
    sa.Column('title', sa.String(length=100), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('address', sa.String(length=255), nullable=False),
    sa.Column('district', sa.String(length=50), nullable=False),
    sa.Column('price_per_night', sa.Integer(), nullable=False),
    sa.Column('rooms', sa.Integer(), nullable=False),
    sa.Column('max_guests', sa.Integer(), nullable=False),
    sa.Column('property_type', sa.String(length=50), nullable=False),
    sa.Column('is_verified', sa.Boolean(), nullable=False),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.ForeignKeyConstraint(['owner_id'], ['public.users.telegram_id'], ),
    sa.PrimaryKeyConstraint('id'),
    schema='public'
    )
    op.create_index(op.f('ix_public_properties_district'), 'properties', ['district'], unique=False, schema='public')
    op.create_index(op.f('ix_public_properties_price_per_night'), 'properties', ['price_per_night'], unique=False, schema='public')
    op.create_table('bookings',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('property_id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.BigInteger(), nullable=False),
    sa.Column('start_date', sa.DateTime(), nullable=False),
    sa.Column('end_date', sa.DateTime(), nullable=False),
    sa.Column('status', sa.String(length=20), nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.ForeignKeyConstraint(['property_id'], ['public.properties.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['public.users.telegram_id'], ),
    sa.PrimaryKeyConstraint('id'),
    schema='public'
    )
    op.create_table('price_rules',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('property_id', sa.Integer(), nullable=False),
    sa.Column('start_date', sa.Date(), nullable=False),
    sa.Column('end_date', sa.Date(), nullable=False),
    sa.Column('price', sa.Integer(), nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.ForeignKeyConstraint(['property_id'], ['public.properties.id'], ),
    sa.PrimaryKeyConstraint('id'),
    schema='public'
    )
    op.create_table('property_media',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('property_id', sa.Integer(), nullable=False),
    sa.Column('file_id', sa.String(length=255), nullable=False),
    sa.Column('media_type', sa.String(length=10), nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.ForeignKeyConstraint(['property_id'], ['public.properties.id'], ),
    sa.PrimaryKeyConstraint('id'),
    schema='public'
    )
    op.create_table('unavailable_dates',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('property_id', sa.Integer(), nullable=False),
    sa.Column('date', sa.Date(), nullable=False),
    sa.Column('comment', sa.String(length=100), nullable=True),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.ForeignKeyConstraint(['property_id'], ['public.properties.id'], ),
    sa.PrimaryKeyConstraint('id'),
    schema='public'
    )
    op.create_table('reviews',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('property_id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.BigInteger(), nullable=False),
    sa.Column('booking_id', sa.Integer(), nullable=False),
    sa.Column('rating', sa.Integer(), nullable=False),
    sa.Column('text', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.ForeignKeyConstraint(['booking_id'], ['public.bookings.id'], ),
    sa.ForeignKeyConstraint(['property_id'], ['public.properties.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['public.users.telegram_id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('booking_id'),
    schema='public'
    )
    op.drop_index('ix_apscheduler_jobs_next_run_time', table_name='apscheduler_jobs')
    op.drop_table('apscheduler_jobs')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('apscheduler_jobs',
    sa.Column('id', sa.VARCHAR(length=191), autoincrement=False, nullable=False),
    sa.Column('next_run_time', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('job_state', postgresql.BYTEA(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='apscheduler_jobs_pkey')
    )
    op.create_index('ix_apscheduler_jobs_next_run_time', 'apscheduler_jobs', ['next_run_time'], unique=False)
    op.drop_table('reviews', schema='public')
    op.drop_table('unavailable_dates', schema='public')
    op.drop_table('property_media', schema='public')
    op.drop_table('price_rules', schema='public')
    op.drop_table('bookings', schema='public')
    op.drop_index(op.f('ix_public_properties_price_per_night'), table_name='properties', schema='public')
    op.drop_index(op.f('ix_public_properties_district'), table_name='properties', schema='public')
    op.drop_table('properties', schema='public')
    op.drop_table('users', schema='public')
    # ### end Alembic commands ###


--------------------------------------------------------------------------------
--- SKIPPED (binary or error): alembic/versions/.DS_Store | Reason: 'utf-8' codec can't decode byte 0xc1 in position 343: invalid start byte
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- FILE: alembic/versions/e59ee5e86b40_add_unique_constraint_to_unavailable_.py
--------------------------------------------------------------------------------
"""Add unique constraint to unavailable dates

Revision ID: e59ee5e86b40
Revises: 2bf2bba148b0
Create Date: 2025-07-01 17:55:19.205013

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = 'e59ee5e86b40'
down_revision: Union[str, None] = '2bf2bba148b0'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index('ix_apscheduler_jobs_next_run_time', table_name='apscheduler_jobs')
    op.drop_table('apscheduler_jobs')
    op.drop_constraint('bookings_property_id_fkey', 'bookings', type_='foreignkey')
    op.drop_constraint('bookings_user_id_fkey', 'bookings', type_='foreignkey')
    op.create_foreign_key(None, 'bookings', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'bookings', 'users', ['user_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.drop_constraint('price_rules_property_id_fkey', 'price_rules', type_='foreignkey')
    op.create_foreign_key(None, 'price_rules', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.drop_constraint('properties_owner_id_fkey', 'properties', type_='foreignkey')
    op.create_foreign_key(None, 'properties', 'users', ['owner_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.drop_constraint('property_media_property_id_fkey', 'property_media', type_='foreignkey')
    op.create_foreign_key(None, 'property_media', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.drop_constraint('reviews_property_id_fkey', 'reviews', type_='foreignkey')
    op.drop_constraint('reviews_booking_id_fkey', 'reviews', type_='foreignkey')
    op.drop_constraint('reviews_user_id_fkey', 'reviews', type_='foreignkey')
    op.create_foreign_key(None, 'reviews', 'bookings', ['booking_id'], ['id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'reviews', 'users', ['user_id'], ['telegram_id'], source_schema='public', referent_schema='public')
    op.create_foreign_key(None, 'reviews', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    op.create_unique_constraint('uq_property_date', 'unavailable_dates', ['property_id', 'date'], schema='public')
    op.drop_constraint('unavailable_dates_property_id_fkey', 'unavailable_dates', type_='foreignkey')
    op.create_foreign_key(None, 'unavailable_dates', 'properties', ['property_id'], ['id'], source_schema='public', referent_schema='public')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'unavailable_dates', schema='public', type_='foreignkey')
    op.create_foreign_key('unavailable_dates_property_id_fkey', 'unavailable_dates', 'properties', ['property_id'], ['id'])
    op.drop_constraint('uq_property_date', 'unavailable_dates', schema='public', type_='unique')
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'reviews', schema='public', type_='foreignkey')
    op.create_foreign_key('reviews_user_id_fkey', 'reviews', 'users', ['user_id'], ['telegram_id'])
    op.create_foreign_key('reviews_booking_id_fkey', 'reviews', 'bookings', ['booking_id'], ['id'])
    op.create_foreign_key('reviews_property_id_fkey', 'reviews', 'properties', ['property_id'], ['id'])
    op.drop_constraint(None, 'property_media', schema='public', type_='foreignkey')
    op.create_foreign_key('property_media_property_id_fkey', 'property_media', 'properties', ['property_id'], ['id'])
    op.drop_constraint(None, 'properties', schema='public', type_='foreignkey')
    op.create_foreign_key('properties_owner_id_fkey', 'properties', 'users', ['owner_id'], ['telegram_id'])
    op.drop_constraint(None, 'price_rules', schema='public', type_='foreignkey')
    op.create_foreign_key('price_rules_property_id_fkey', 'price_rules', 'properties', ['property_id'], ['id'])
    op.drop_constraint(None, 'bookings', schema='public', type_='foreignkey')
    op.drop_constraint(None, 'bookings', schema='public', type_='foreignkey')
    op.create_foreign_key('bookings_user_id_fkey', 'bookings', 'users', ['user_id'], ['telegram_id'])
    op.create_foreign_key('bookings_property_id_fkey', 'bookings', 'properties', ['property_id'], ['id'])
    op.create_table('apscheduler_jobs',
    sa.Column('id', sa.VARCHAR(length=191), autoincrement=False, nullable=False),
    sa.Column('next_run_time', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('job_state', postgresql.BYTEA(), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='apscheduler_jobs_pkey')
    )
    op.create_index('ix_apscheduler_jobs_next_run_time', 'apscheduler_jobs', ['next_run_time'], unique=False)
    # ### end Alembic commands ###


--------------------------------------------------------------------------------
--- SKIPPED (binary or error): src/.DS_Store | Reason: 'utf-8' codec can't decode byte 0x80 in position 3131: invalid start byte
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- FILE: src/static/index.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Бронирование</title>
    <style>
        :root {
            --tg-bg: var(--tg-theme-bg-color, #ffffff);
            --tg-text: var(--tg-theme-text-color, #222222);
            --tg-hint: var(--tg-theme-hint-color, #999999);
            --tg-button: var(--tg-theme-button-color, #2481cc);
            --tg-button-text: var(--tg-theme-button-text-color, #ffffff);
            --tg-secondary-bg: var(--tg-theme-secondary-bg-color, #f1f1f1);
            --color-booked: #e0e0e0; 
        }
        html, body { height: auto; min-height: 100%; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--tg-bg);
            color: var(--tg-text);
            margin: 0;
            padding: 15px;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }
        .calendar-month-container { margin-bottom: 25px; }
        .calendar-header { text-align: center; padding: 10px 5px; }
        .calendar-month-year { font-weight: 600; font-size: 18px; }
        .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; }
        .calendar-day, .calendar-weekday { display: flex; justify-content: center; align-items: center; text-align: center; border-radius: 50%; }
        .calendar-weekday { height: 30px; color: var(--tg-hint); font-size: 12px; }
        .calendar-day { cursor: pointer; border: 1px solid transparent; transition: background-color 0.2s, color 0.2s; flex-direction: column; padding: 2px 0; height: 44px; }
        .day-number { font-size: 15px; font-weight: 500; }
        .day-price { font-size: 9px; color: var(--tg-hint); }
        .calendar-day:not(.disabled):hover { background-color: var(--tg-secondary-bg); }
        .calendar-day.selected, .calendar-day.start-range, .calendar-day.end-range { background-color: var(--tg-button); color: var(--tg-button-text); border-color: var(--tg-button); }
        .calendar-day.selected .day-price, .calendar-day.start-range .day-price, .calendar-day.end-range .day-price { color: var(--tg-button-text); }
        .calendar-day.in-range { background-color: var(--tg-secondary-bg); color: var(--tg-text); border-radius: 0; }
        .calendar-day.disabled { color: var(--tg-hint); cursor: not-allowed; opacity: 0.6; }
        .calendar-day.disabled .day-number { text-decoration: line-through; }
        .calendar-day.padding { visibility: hidden; }
        .calendar-day.booked { background-color: var(--color-booked); }
        .sticky-footer { position: sticky; bottom: 0; left: 0; right: 0; padding: 15px; background-color: var(--tg-bg); box-shadow: 0 -5px 15px -5px rgba(0,0,0,0.1); }
        .info-panel { text-align: center; padding: 12px; border-radius: 8px; font-size: 14px; background-color: var(--tg-secondary-bg); margin-bottom: 15px; }
        #confirm-button { font-family: inherit; font-weight: 600; font-size: 16px; width: 100%; padding: 15px; border: none; border-radius: 8px; cursor: pointer; background-color: var(--tg-button); color: var(--tg-button-text); }
        #confirm-button:disabled { opacity: 0.5; cursor: not-allowed; }
    </style>
</head>
<body>

    <div id="calendar-body"></div>
    <div class="sticky-footer">
        <div class="info-panel" id="info-panel">Загрузка...</div>
        <button id="confirm-button" disabled>Подтвердить</button>
    </div>

    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const tg = window.Telegram.WebApp;
            tg.ready();
            tg.expand();

            const calendarBody = document.getElementById('calendar-body');
            const infoPanel = document.getElementById('info-panel');
            const confirmButton = document.getElementById('confirm-button');
            
            let currentYear, currentMonth;
            let calendarData = {}; 
            let checkinDate = null;
            let checkoutDate = null;
            let isLoading = false; 

            const monthNames = ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"];
            const dayNames = ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"];

            async function fetchAndRenderMonth(year, month) {
                if (isLoading) return;
                isLoading = true;
                try {
                    const urlParams = new URLSearchParams(window.location.search);
                    const propertyId = urlParams.get('property_id');
                    if (!propertyId) { throw new Error("Не найден ID объекта в URL."); }
                    const fetchUrl = `/api/calendar_data/${propertyId}?year=${year}&month=${month + 1}`;
                    const response = await fetch(fetchUrl);
                    if (!response.ok) { throw new Error(`Ошибка сети: ${response.status}`); }
                    const data = await response.json();
                    if (!Array.isArray(data)) { throw new Error("API вернул некорректные данные."); }
                    data.forEach(dayInfo => { calendarData[dayInfo.date] = { status: dayInfo.status, price: dayInfo.price }; });
                    renderMonth(year, month);
                    updateUI();
                } catch (error) {
                    console.error('Критическая ошибка при загрузке календаря:', error);
                    infoPanel.textContent = "Ошибка загрузки данных. Попробуйте позже.";
                    confirmButton.disabled = true; 
                } finally {
                    isLoading = false;
                }
            }
            
            function renderMonth(year, month) {
                const monthContainerId = `month-${year}-${month}`;
                if (document.getElementById(monthContainerId)) return;
                const monthContainer = document.createElement('div');
                monthContainer.className = 'calendar-month-container';
                monthContainer.id = monthContainerId;
                const header = document.createElement('div');
                header.className = 'calendar-header';
                header.innerHTML = `<span class="calendar-month-year">${monthNames[month]} ${year}</span>`;
                monthContainer.appendChild(header);
                const weekdaysGrid = document.createElement('div');
                weekdaysGrid.className = 'calendar-grid';
                dayNames.forEach(day => { weekdaysGrid.innerHTML += `<div class="calendar-weekday">${day}</div>`; });
                monthContainer.appendChild(weekdaysGrid);
                const calendarGrid = document.createElement('div');
                calendarGrid.className = 'calendar-grid';
                const firstDayOfMonth = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                const startingDay = (firstDayOfMonth === 0) ? 6 : firstDayOfMonth - 1;
                for (let i = 0; i < startingDay; i++) { calendarGrid.innerHTML += '<div class="calendar-day padding"></div>'; }
                for (let day = 1; day <= daysInMonth; day++) {
                    const currentDate = new Date(year, month, day);
                    const currentDateStr = currentDate.toISOString().split('T')[0];
                    const dayData = calendarData[currentDateStr];
                    const dayEl = document.createElement('div');
                    dayEl.className = 'calendar-day';
                    dayEl.dataset.date = currentDateStr;
                    let dayNumberHTML = `<div class="day-number">${day}</div>`;
                    let dayPriceHTML = '';
                    if (dayData) {
                        if (dayData.status !== 'available') {
                            dayEl.classList.add('disabled');
                            if (dayData.status === 'booked') { dayEl.classList.add('booked'); }
                        } else {
                            dayPriceHTML = `<div class="day-price">${dayData.price ? `${dayData.price}` : ''}</div>`;
                            dayEl.addEventListener('click', onDayClick);
                        }
                    }
                    dayEl.innerHTML = dayNumberHTML + dayPriceHTML;
                    calendarGrid.appendChild(dayEl);
                }
                monthContainer.appendChild(calendarGrid);
                calendarBody.appendChild(monthContainer);
            }
            
            function onDayClick(event) {
                const selectedDateStr = event.currentTarget.dataset.date;
                if (checkinDate && checkoutDate) {
                    checkinDate = selectedDateStr;
                    checkoutDate = null;
                } else if (checkinDate) {
                    const selectedD = new Date(selectedDateStr);
                    const checkinD = new Date(checkinDate);
                    if (selectedD > checkinD) {
                        if (isRangeAvailable(checkinDate, selectedDateStr)) { checkoutDate = selectedDateStr; } 
                        else {
                            tg.showAlert('Выбранный диапазон содержит занятые даты. Пожалуйста, выберите другой период.');
                            checkinDate = selectedDateStr;
                            checkoutDate = null;
                        }
                    } else {
                        checkinDate = selectedDateStr;
                        checkoutDate = null;
                    }
                } else {
                    checkinDate = selectedDateStr;
                }
                updateUI();
            }

            function isRangeAvailable(startStr, endStr) {
                const start = new Date(startStr);
                const end = new Date(endStr);
                for (let d = new Date(start); d < end; d.setDate(d.getDate() + 1)) {
                    const dateStr = d.toISOString().split('T')[0];
                    if (calendarData[dateStr] && calendarData[dateStr].status !== 'available') { return false; }
                }
                return true;
            }

            function updateUI() {
                document.querySelectorAll('.calendar-day[data-date]').forEach(cell => {
                    cell.classList.remove('selected', 'in-range', 'start-range', 'end-range');
                    const cellDateStr = cell.dataset.date;
                    if (checkinDate && checkoutDate) {
                        const checkin = new Date(checkinDate);
                        const checkout = new Date(checkoutDate);
                        const current = new Date(cellDateStr);
                        if (current >= checkin && current <= checkout) {
                            cell.classList.add('in-range');
                            if (current.getTime() === checkin.getTime()) cell.classList.add('start-range');
                            if (current.getTime() === checkout.getTime()) cell.classList.add('end-range');
                        }
                    } else if (checkinDate && cellDateStr === checkinDate) {
                        cell.classList.add('selected');
                    }
                });
                if (!checkinDate) {
                    infoPanel.textContent = 'Выберите дату заезда';
                    confirmButton.disabled = true;
                    confirmButton.textContent = 'Подтвердить';
                } else if (!checkoutDate) {
                    infoPanel.textContent = `Заезд: ${formatDate(checkinDate)}. Теперь выберите дату выезда.`;
                    confirmButton.disabled = true;
                    confirmButton.textContent = 'Выберите дату выезда';
                } else {
                    const { total, nights } = calculateTotal();
                    if (nights > 0) {
                        infoPanel.textContent = `Итоговая стоимость за ${nights} ночей`;
                        confirmButton.disabled = false;
                        confirmButton.textContent = `Подтвердить за ${total} руб.`;
                    } else {
                        infoPanel.textContent = 'Выберите дату выезда позже даты заезда.';
                        confirmButton.disabled = true;
                        confirmButton.textContent = 'Подтвердить';
                    }
                }
            }
            
            function calculateTotal() {
                let total = 0;
                let nights = 0;
                const start = new Date(checkinDate);
                const end = new Date(checkoutDate);
                for (let d = new Date(start); d < end; d.setDate(d.getDate() + 1)) {
                    const dateStr = d.toISOString().split('T')[0];
                    if (calendarData[dateStr] && calendarData[dateStr].price) {
                        total += calendarData[dateStr].price;
                        nights++;
                    }
                }
                return { total, nights };
            }

            function formatDate(dateStr) {
                const [_, month, day] = dateStr.split('-');
                return `${day}.${month}`;
            }

            // --- ИЗМЕНЕНИЕ ЗДЕСЬ: Обработчик для нашей HTML-кнопки ---
            confirmButton.addEventListener('click', async () => {
                if (confirmButton.disabled) return;

                if (checkinDate && checkoutDate) {
                    const { total } = calculateTotal();
                    const dataToSend = {
                        property_id: new URLSearchParams(window.location.search).get('property_id'),
                        checkin_date: checkinDate,
                        checkout_date: checkoutDate,
                        total_price: total,
                        user: tg.initDataUnsafe.user
                    };

                    try {
                        confirmButton.disabled = true;
                        confirmButton.textContent = 'Обработка...';

                        const response = await fetch('/api/bookings/create', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(dataToSend),
                        });

                        if (!response.ok) { throw new Error('Ошибка при отправке бронирования.'); }

                        tg.showPopup({
                            title: 'Успешно!',
                            message: 'Ваша заявка на бронирование отправлена владельцу.',
                            buttons: [{ type: 'ok' }]
                        }, () => { tg.close(); });

                    } catch (error) {
                        console.error('Ошибка fetch:', error);
                        tg.showAlert('Произошла ошибка. Пожалуйста, попробуйте снова.');
                        updateUI(); 
                    }
                }
            });

            window.addEventListener('scroll', () => {
                if (!isLoading && (window.innerHeight + window.scrollY) >= document.body.offsetHeight - 150) {
                   currentMonth++;
                   if (currentMonth > 11) { currentMonth = 0; currentYear++; }
                   fetchAndRenderMonth(currentYear, currentMonth);
                }
            });

            async function main() {
                const today = new Date();
                currentYear = today.getFullYear();
                currentMonth = today.getMonth();
                for (let i = 0; i < 4; i++) {
                    let yearToLoad = currentYear;
                    let monthToLoad = currentMonth + i;
                    if (monthToLoad > 11) {
                        yearToLoad += Math.floor(monthToLoad / 12);
                        monthToLoad = monthToLoad % 12;
                    }
                    await fetchAndRenderMonth(yearToLoad, monthToLoad);
                }
            }
            main();
        });
    </script>
</body>
</html>

--------------------------------------------------------------------------------
--- FILE: src/static/owner.css
--------------------------------------------------------------------------------
:root {
    --tg-bg-color: var(--tg-theme-bg-color, #212121);
    --tg-text-color: var(--tg-theme-text-color, #ffffff);
    --tg-hint-color: var(--tg-theme-hint-color, #aaaaaa);
    --tg-button-color: var(--tg-theme-button-color, #5288c1);
    --tg-button-text-color: var(--tg-theme-button-text-color, #ffffff);
    
    /* --- НОВАЯ СТИЛЬНАЯ ЦВЕТОВАЯ СХЕМА --- */
    --color-cell-bg: #303030;         /* Фон ячейки по умолчанию */
    --color-cell-border: #424242;     /* Цвет рамки */
    --color-price-text: #9e9e9e;      /* Цвет цены */
    --color-booked-bg: #424242;       /* Фон для броней (темнее) */
    --color-booked-text: #9e9e9e;
    --color-past-bg: #212121;         /* Фон для прошедших дат (как фон страницы) */
    --color-past-text: #616161;
    --color-selected-bg: #5288c1;     /* Яркий синий для выделения */
    --color-selected-text: #ffffff;
    --color-manual-block-dot: #e53935; /* Ярко-красный для точки */
}

html, body { height: auto; min-height: 100%; }
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    background-color: var(--tg-bg-color);
    color: var(--tg-text-color);
    margin: 0;
    padding: 15px;
    box-sizing: border-box;
}

.calendar-month-container { margin-bottom: 25px; }
.calendar-header { text-align: center; padding: 10px 5px; font-weight: 600; font-size: 18px; }
.calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; }
.calendar-weekday { font-weight: 600; font-size: 0.9em; text-align: center; color: var(--tg-hint-color); padding-bottom: 10px; }

.day-cell {
    position: relative;
    aspect-ratio: 1 / 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border: 1px solid var(--color-cell-border);
    background-color: var(--color-cell-bg);
    border-radius: 12px;
    cursor: pointer;
    transition: transform 0.1s, background-color 0.2s;
}

.day-cell:hover:not(.disabled) { transform: scale(1.05); }
.day-number { font-size: 1em; font-weight: 500; }
.day-price { font-size: 0.8em; font-weight: 600; margin-top: 2px; color: var(--color-price-text); }

/* --- ИЗМЕНЕНИЕ: СТИЛЬ ДЛЯ ТОЧКИ БЛОКИРОВКИ --- */
.day-cell.manual-block::after {
    content: '';
    position: absolute;
    top: 8px;
    right: 8px;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background-color: var(--color-manual-block-dot);
}

/* --- СТИЛИЗАЦИЯ СТАТУСОВ --- */
.day-cell.booked { background-color: var(--color-booked-bg); color: var(--color-booked-text); }
.day-cell.booked .day-price { color: var(--color-booked-text); }
.day-cell.past { background-color: var(--color-past-bg); color: var(--color-past-text); border-color: transparent; }
.day-cell.past .day-price { color: var(--color-past-text); }
.day-cell.selected { background-color: var(--color-selected-bg); color: var(--color-selected-text) !important; border-color: var(--tg-link-color); }
.day-cell.selected .day-price { color: var(--color-selected-text) !important; }
.day-cell.empty { background-color: transparent; border: none; cursor: default; }
.day-cell.empty:hover { transform: none; }
.day-cell.disabled { cursor: not-allowed; }

.legend { display: none; } /* Легенда больше не нужна, точка говорит сама за себя */
.loader-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 1000; visibility: hidden; opacity: 0; transition: opacity 0.3s, visibility 0.3s; }
.loader-overlay.visible { visibility: visible; opacity: 1; }
.loader-spinner { border: 5px solid #424242; border-top: 5px solid var(--tg-button-color); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

--------------------------------------------------------------------------------
--- FILE: src/static/owner.js
--------------------------------------------------------------------------------
document.addEventListener('DOMContentLoaded', () => {
    const tg = window.Telegram.WebApp;
    tg.ready();
    tg.expand();

    const calendarContainer = document.getElementById('calendar-container');
    const loader = document.getElementById('loader');
    const urlParams = new URLSearchParams(window.location.search);
    const propertyId = urlParams.get('property_id');
    
    if (!propertyId) {
        calendarContainer.innerHTML = '<p style="color: red;">Ошибка: ID объекта не указан в URL.</p>';
        return;
    }

    let currentYear, currentMonth;
    let calendarData = {};
    let selection = { start: null, end: null };
    let isLoading = false;
    const monthNames = ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"];
    const dayNames = ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"];

    // ... (функции fetchAndRenderMonth, renderMonth, updateSelectionHighlight без изменений)
    async function fetchAndRenderMonth(year, month) { /* ... */ }
    function renderMonth(year, month) { /* ... */ }
    function updateSelectionHighlight() {
        document.querySelectorAll('.day-cell[data-date]').forEach(cell => {
            const cellDate = new Date(cell.dataset.date + 'T00:00:00');
            const inSelection = selection.start && cellDate >= selection.start && (selection.end || selection.start) && cellDate <= (selection.end || selection.start);
            cell.classList.toggle('selected', inSelection);
        });
    }

    // --- ИЗМЕНЕНИЕ: Полностью новая логика выделения ---
    calendarContainer.addEventListener('click', (e) => {
        const cell = e.target.closest('.day-cell');
        if (!cell || !cell.dataset.date || cell.classList.contains('disabled')) return;
        
        const clickedDate = new Date(cell.dataset.date + 'T00:00:00');

        // Если это первый клик или мы начинаем новое выделение
        if (!selection.start || selection.end) {
            selection.start = clickedDate;
            selection.end = null;
            updateSelectionHighlight();
        } 
        // Если это второй клик
        else {
            // Если кликнули на ту же дату (действие для одной даты)
            if (clickedDate.getTime() === selection.start.getTime()) {
                selection.end = clickedDate; // Завершаем выделение на одной дате
                showActionPopup();
            } 
            // Если кликнули на другую дату (действие для периода)
            else {
                if (clickedDate < selection.start) {
                    selection.end = selection.start;
                    selection.start = clickedDate;
                } else {
                    selection.end = clickedDate;
                }
                showActionPopup();
            }
            updateSelectionHighlight();
        }
    });

    window.addEventListener('scroll', () => { /* ... */ });

    // ... (остальные функции handlePopupAction, setPeriodAvailability, handleSetPrice, main без изменений)
    function showActionPopup() {
        if (!selection.start) return;
        const isSingleDate = !selection.end || selection.start.getTime() === selection.end.getTime();
        const startDateStr = selection.start.toLocaleDateString('ru-RU');
        const endDateStr = selection.end.toLocaleDateString('ru-RU');
        const message = isSingleDate ? `Применить действие для даты: ${startDateStr}` : `Применить действие для периода: ${startDateStr} - ${endDateStr}`;

        tg.showPopup({
            title: 'Управление датами',
            message: message,
            buttons: [
                { id: 'block', type: 'default', text: '🚫 Заблокировать' },
                { id: 'unblock', type: 'default', text: '✅ Сделать доступными' },
                { id: 'set_price', type: 'default', text: '💰 Установить цену' },
                { type: 'cancel' },
            ]
        }, (buttonId) => handlePopupAction(buttonId));
    }
    
    function handlePopupAction(buttonId) {
        if (!buttonId) {
            selection.start = null;
            selection.end = null;
            updateSelectionHighlight();
            return;
        }
        switch (buttonId) {
            case 'block':
                const comment = prompt("Введите причину блокировки (необязательно):", "");
                if (comment !== null) setPeriodAvailability(false, comment);
                break;
            case 'unblock':
                setPeriodAvailability(true, null);
                break;
            case 'set_price':
                handleSetPrice();
                break;
        }
    }

    async function setPeriodAvailability(isAvailable, comment) {
        const dates = [];
        const endDate = selection.end || selection.start;
        for (let d = new Date(selection.start); d <= endDate; d.setDate(d.getDate() + 1)) {
            dates.push(d.toISOString().split('T')[0]);
        }
        
        setLoaderVisible(true);
        try {
            const response = await fetch(`/api/owner/set_availability`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    property_id: propertyId, 
                    dates: dates, 
                    is_available: isAvailable,
                    comment: comment
                })
            });
            if (!response.ok) throw new Error('Ошибка сервера.');
            tg.showPopup({ title: 'Успех', message: `Статус для выбранного периода успешно изменен.` });
        } catch (error) {
            tg.showAlert(`Ошибка: ${error.message}`);
        } finally {
            selection.start = null;
            selection.end = null;
            calendarContainer.innerHTML = '';
            main();
        }
    }

    async function handleSetPrice() {
        const price = prompt("Введите новую цену для выбранного периода:", "5000");
        if (price === null || isNaN(parseInt(price)) || parseInt(price) <= 0) {
            if (price !== null) tg.showAlert("Пожалуйста, введите корректное число больше нуля.");
            selection.start = null;
            selection.end = null;
            updateSelectionHighlight();
            return;
        }
        const startDate = selection.start.toISOString().split('T')[0];
        const endDate = (selection.end || selection.start).toISOString().split('T')[0];
        setLoaderVisible(true);
        try {
            const response = await fetch(`/api/owner/price_rule`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    property_id: propertyId,
                    start_date: startDate,
                    end_date: endDate,
                    price: parseInt(price)
                })
            });
            if (!response.ok) throw new Error('Ошибка сервера при установке цены.');
            tg.showPopup({ title: 'Успех', message: `Цена ${price}₽ установлена для периода с ${startDate} по ${endDate}.` });
        } catch (error) {
            tg.showAlert(`Ошибка: ${error.message}`);
        } finally {
            selection.start = null;
            selection.end = null;
            calendarContainer.innerHTML = '';
            main();
        }
    }

    async function main() {
        const today = new Date();
        currentYear = today.getFullYear();
        currentMonth = today.getMonth();
        for (let i = 0; i < 4; i++) {
            let yearToLoad = currentYear;
            let monthToLoad = currentMonth + i;
            if (monthToLoad > 11) {
                yearToLoad += Math.floor(monthToLoad / 12);
                monthToLoad = monthToLoad % 12;
            }
            await fetchAndRenderMonth(yearToLoad, monthToLoad);
        }
    }
    main();
});

--------------------------------------------------------------------------------
--- FILE: src/static/owner.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Управление Календарем</title>
    <link rel="stylesheet" href="/static/owner.css">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>

    <!-- Основной контейнер для календарей -->
    <div id="calendar-container"></div>

    <!-- Легенда для статусов дней -->
    <div class="legend">
        <div class="legend-item"><span class="color-box available"></span> - Свободно</div>
        <div class="legend-item"><span class="color-box booked"></span> - Забронировано</div>
        <div class="legend-item"><span class="color-box manual-block"></span> - Заблокировано</div>
        <div class="legend-item"><span class="color-box selected"></span> - Выбрано</div>
    </div>

    <!-- Индикатор загрузки -->
    <div id="loader" class="loader-overlay">
        <div class="loader-spinner"></div>
    </div>

    <!-- Подключаем основной файл с логикой -->
    <script src="/static/owner.js"></script>
</body>
</html>

--------------------------------------------------------------------------------
--- FILE: src/handlers/admin_handlers.py
--------------------------------------------------------------------------------
import logging
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo

from aiogram import Router, F, Bot
from aiogram.exceptions import TelegramAPIError
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery

from src.services.property_service import set_property_verified
from src.services.booking_service import update_booking_status, get_booking_with_details
from src.services.user_service import set_user_role
from src.core.settings import settings
from src.core.scheduler import scheduler, request_review

router = Router()
# Фильтр гарантирует, что все обработчики в этом файле будут работать только для админов
router.message.filter(F.from_user.id.in_(settings.ADMIN_IDS))
router.callback_query.filter(F.from_user.id.in_(settings.ADMIN_IDS))


@router.message(Command("setrole"))
async def set_user_role_handler(message: Message):
    """
    Устанавливает роль пользователю.
    Формат: /setrole <user_id> <role>
    """
    try:
        parts = message.text.split()
        if len(parts) != 3:
            raise ValueError("Неверное количество аргументов.")
        
        user_id = int(parts[1])
        role = parts[2].lower()

        if role not in ['user', 'owner', 'admin']:
            await message.answer("Неверная роль. Доступные роли: user, owner, admin.")
            return

        await set_user_role(user_id, role)
        await message.answer(f"Пользователю с ID {user_id} была успешно присвоена роль '{role}'.")

    except (ValueError, IndexError):
        # --- ИЗМЕНЕНИЕ ЗДЕСЬ: Экранируем HTML-символы ---
        await message.answer(
            "Неверный формат команды. Используйте: `/setrole <ID пользователя> <роль>`"
        )
    except Exception as e:
        logging.error(f"Ошибка при установке роли: {e}")
        await message.answer(f"Произошла непредвиденная ошибка при установке роли.")


@router.message(Command("verify"))
async def verify_property(message: Message):
    """
    Верифицирует объект по ID.
    Формат: /verify 123
    """
    try:
        property_id = int(message.text.split()[1])
        await set_property_verified(property_id, status=True)
        await message.answer(f"Объект с ID {property_id} был успешно верифицирован ✅.")
    except (IndexError, ValueError):
        # --- ИЗМЕНЕНИЕ ЗДЕСЬ: Экранируем HTML-символы ---
        await message.answer("Неверный формат команды. Используйте: `/verify <ID объекта>`")
    except Exception as e:
        await message.answer(f"Произошла ошибка: {e}")

@router.message(Command("unverify"))
async def unverify_property(message: Message):
    """
    Снимает верификацию с объекта по ID.
    Формат: /unverify 123
    """
    try:
        property_id = int(message.text.split()[1])
        await set_property_verified(property_id, status=False)
        await message.answer(f"С объекта с ID {property_id} была снята верификация.")
    except (IndexError, ValueError):
        # --- ИЗМЕНЕНИЕ ЗДЕСЬ: Экранируем HTML-символы ---
        await message.answer("Неверный формат команды. Используйте: `/unverify <ID объекта>`")
    except Exception as e:
        await message.answer(f"Произошла ошибка: {e}")


# --- Обработка заявок на бронирование (без изменений) ---

@router.callback_query(F.data.startswith("booking:confirm:"))
async def confirm_booking(callback: CallbackQuery, bot: Bot):
    booking_id = int(callback.data.split(":")[2])
    
    await update_booking_status(booking_id, "confirmed")
    booking = await get_booking_with_details(booking_id)
    if not booking:
        await callback.answer("Бронирование не найдено.", show_alert=True)
        return

    await callback.message.edit_text(f"{callback.message.text}\n\n--- \n✅ ВЫ ПРИНЯЛИ ЭТУ ЗАЯВКУ ---")
    
    try:
        run_date = datetime.now(ZoneInfo("Europe/Kaliningrad")) + timedelta(minutes=2)
        scheduler.add_job(
            request_review,
            'date',
            run_date=run_date,
            kwargs={
                "bot_token": settings.BOT_TOKEN.get_secret_value(),
                "chat_id": booking.user.telegram_id,
                "booking_id": booking.id,
                "property_title": booking.property.title
            }
        )
        logging.info(f"Запланирован запрос отзыва для бронирования {booking.id} на {run_date}")
    except Exception as e:
        logging.error(f"Ошибка при планировании запроса на отзыв: {e}")

    try:
        await bot.send_message(
            chat_id=booking.user.telegram_id,
            text=f"🎉 Ваша заявка на бронирование объекта «{booking.property.title}» была ОДОБРЕНА!\n\nВладелец скоро свяжется с вами для уточнения деталей."
        )
    except TelegramAPIError as e:
        logging.error(f"Telegram API Error при отправке уведомления арендатору: {e}")
        
    await callback.answer("Вы успешно приняли заявку!")


@router.callback_query(F.data.startswith("booking:reject:"))
async def reject_booking(callback: CallbackQuery, bot: Bot):
    booking_id = int(callback.data.split(":")[2])
    
    await update_booking_status(booking_id, "rejected")
    booking = await get_booking_with_details(booking_id)
    if not booking:
        await callback.answer("Бронирование не найдено.", show_alert=True)
        return

    await callback.message.edit_text(f"{callback.message.text}\n\n--- \n❌ ВЫ ОТКЛОНИЛИ ЭТУ ЗАЯВКУ ---")

    try:
        await bot.send_message(
            chat_id=booking.user.telegram_id,
            text=f"😔 К сожалению, ваша заявка на бронирование объекта «{booking.property.title}» была ОТКЛОНЕНА."
        )
    except TelegramAPIError as e:
        logging.error(f"Telegram API Error при отправке уведомления арендатору: {e}")
        
    await callback.answer("Вы отклонили заявку.")

--------------------------------------------------------------------------------
--- SKIPPED (binary or error): src/handlers/.DS_Store | Reason: 'utf-8' codec can't decode byte 0xff in position 1082: invalid start byte
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- FILE: src/handlers/__init__.py
--------------------------------------------------------------------------------
from aiogram import Router

# Импортируем наши большие "агрегаторы"
from .user_handlers import user_router
from .owner_handlers import owner_router
from .admin_handlers import router as admin_router
from .user.webapp import router as webapp_router
# --- НОВЫЙ ИМПОРТ ---
from .common_handlers import router as common_router

# Создаем главный роутер всего приложения
main_router = Router()

# --- ИЗМЕНЕНИЕ ЗДЕСЬ: Регистрируем универсальные обработчики ПЕРВЫМИ ---
main_router.include_router(common_router)
main_router.include_router(webapp_router)

# Далее регистрируем остальные роутеры.
main_router.include_router(admin_router)
main_router.include_router(owner_router)
main_router.include_router(user_router)

--------------------------------------------------------------------------------
--- FILE: src/handlers/user_handlers.py
--------------------------------------------------------------------------------
from aiogram import Router
# --- ИЗМЕНЕНИЕ ЗДЕСЬ: Убираем webapp ---
from .user import common, search, booking, review 

user_router = Router()

# Регистрируем все роутеры, КРОМЕ webapp
user_router.include_router(common.router)
user_router.include_router(search.router)
user_router.include_router(booking.router)
user_router.include_router(review.router)

--------------------------------------------------------------------------------
--- FILE: src/handlers/common_handlers.py
--------------------------------------------------------------------------------
from aiogram import Router, F
from aiogram.filters import Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, ReplyKeyboardRemove

router = Router()

@router.message(Command("cancel"), StateFilter("*"))
@router.message(F.text.casefold() == "отмена", StateFilter("*"))
async def cancel_handler(message: Message, state: FSMContext) -> None:
    """
    Универсальный обработчик для отмены любого состояния FSM.
    Работает по команде /cancel или слову "отмена".
    """
    current_state = await state.get_state()
    if current_state is None:
        await message.answer(
            text="Нет активных действий для отмены.",
            reply_markup=ReplyKeyboardRemove()
        )
        return

    await state.clear()
    await message.answer(
        text="Действие отменено.",
        reply_markup=ReplyKeyboardRemove()
    )

--------------------------------------------------------------------------------
--- FILE: src/handlers/owner_handlers.py
--------------------------------------------------------------------------------
from aiogram import Router
from .owner import add_property, manage_property, edit_property

owner_router = Router()

owner_router.include_router(add_property.router)
owner_router.include_router(manage_property.router)
owner_router.include_router(edit_property.router)

--------------------------------------------------------------------------------
--- FILE: src/handlers/user/booking.py
--------------------------------------------------------------------------------
from aiogram import F, Router, Bot
from aiogram.types import CallbackQuery, InputMediaPhoto

from src.services.property_service import get_property_with_media_and_owner
from src.services.review_service import get_reviews_summary 
from src.keyboards.inline_keyboards import get_property_card_keyboard

router = Router()

@router.callback_query(F.data.startswith(("view_photos:", "view_media:")))
async def view_media(callback: CallbackQuery, bot: Bot):
    await callback.answer()
    property_id = int(callback.data.split(":")[1])

    prop, photo_files, video_file = await get_property_with_media_and_owner(property_id)

    if not prop:
        await callback.message.answer("Объект не найден.")
        return

    media_to_show = []
    if video_file and callback.data.startswith("view_media:"):
        await bot.send_video_note(chat_id=callback.from_user.id, video_note=video_file)
        media_to_show = photo_files
    elif callback.data.startswith("view_photos:") and len(photo_files) > 1:
        media_to_show = photo_files[1:]

    if media_to_show:
        if len(media_to_show) > 1:
            media_group = [InputMediaPhoto(media=file_id) for file_id in media_to_show]
            await bot.send_media_group(chat_id=callback.from_user.id, media=media_group)
        elif len(media_to_show) == 1:
            await bot.send_photo(chat_id=callback.from_user.id, photo=media_to_show[0])
    elif not video_file:
         await callback.message.answer("Больше фотографий нет.")

    _, reviews_count = await get_reviews_summary(prop.id)

    await callback.message.answer(
        text="Выберите дальнейшее действие:",
        reply_markup=get_property_card_keyboard(
            property_id=prop.id,
            photos_count=len(photo_files),
            has_video=bool(video_file),
            reviews_count=reviews_count
        )
    )

--------------------------------------------------------------------------------
--- FILE: src/handlers/user/webapp.py
--------------------------------------------------------------------------------
import json
from datetime import datetime
from aiogram import F, Router, Bot
from aiogram.types import Message

from src.services.property_service import get_property_with_media_and_owner
from src.services import booking_service
from src.keyboards.inline_keyboards import get_booking_management_keyboard

# Создаем отдельный роутер специально для Web App
router = Router()

@router.message(F.web_app_data)
async def process_booking_from_webapp(message: Message, bot: Bot):
    """
    Этот хендлер "ловит" данные, отправленные из Web App календаря.
    """
    try:
        data = json.loads(message.web_app_data.data)
        
        property_id = int(data['property_id'])
        checkin_date = datetime.fromisoformat(data['checkin_date'])
        checkout_date = datetime.fromisoformat(data['checkout_date'])
        total_price = data['total_price']

        prop, _, _ = await get_property_with_media_and_owner(property_id)
        if not prop:
            await message.answer("Ошибка: объект не найден.")
            return

        if prop.owner.telegram_id == message.from_user.id:
            await message.answer("Вы не можете забронировать свой собственный объект.")
            return

        new_booking = await booking_service.create_booking(
            user_id=message.from_user.id,
            property_id=property_id,
            start_date=checkin_date,
            end_date=checkout_date
        )

        user_info = f"@{message.from_user.username}" if message.from_user.username else message.from_user.first_name
        num_nights = (checkout_date - checkin_date).days

        await bot.send_message(
            chat_id=prop.owner.telegram_id,
            text=(
                f"🔔 Новая заявка на бронирование!\n\n"
                f"<b>Объект:</b> «{prop.title}»\n"
                f"<b>Даты:</b> с {checkin_date.strftime('%d.%m.%Y')} по {checkout_date.strftime('%d.%m.%Y')} ({num_nights} ночей)\n"
                f"<b>Сумма:</b> {total_price} руб.\n"
                f"<b>Гость:</b> {user_info}"
            ),
            reply_markup=get_booking_management_keyboard(new_booking.id)
        )
        
        await message.answer("✅ Спасибо! Ваша заявка на бронирование отправлена владельцу. Он скоро с вами свяжется.")

    except Exception as e:
        print(f"Ошибка обработки данных из Web App: {e}")
        await message.answer("Произошла ошибка при обработке вашего бронирования. Попробуйте снова.")

--------------------------------------------------------------------------------
--- FILE: src/handlers/user/common.py
--------------------------------------------------------------------------------
from aiogram import F, Router
from aiogram.filters import CommandStart, Command
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery, ReplyKeyboardRemove

from src.services.user_service import add_user
from src.keyboards.inline_keyboards import get_main_menu

router = Router()

@router.message(CommandStart())
async def cmd_start(message: Message, state: FSMContext):
    # При старте на всякий случай сбрасываем состояние
    current_state = await state.get_state()
    if current_state is not None:
        await state.clear()
        
    await message.answer("Загрузка...", reply_markup=ReplyKeyboardRemove())
    await add_user(
        telegram_id=message.from_user.id,
        username=message.from_user.username,
        first_name=message.from_user.first_name
    )
    await message.answer(
        "Добро пожаловать в 'Гид по Калининграду'!",
        reply_markup=get_main_menu()
    )

# --- НАШ НОВЫЙ ОБРАБОТЧИК ---
@router.message(Command("help"))
async def cmd_help(message: Message):
    help_text = (
        "<b>Добро пожаловать в Справку!</b>\n\n"
        "Я бот для поиска и аренды жилья в Калининградской области.\n\n"
        "<b>Основные команды:</b>\n"
        "/start - перезапуск бота и вызов главного меню.\n"
        "/help - вызов этого сообщения.\n"
        "/cancel - отмена любого текущего диалога (добавления, поиска и т.д.).\n\n"
        "<b>Для Владельцев (и Администраторов):</b>\n"
        "/myproperties - посмотреть список ваших объектов и управлять ими.\n"
        "/addproperty - запустить диалог добавления нового объекта."
    )
    await message.answer(help_text)


@router.callback_query(F.data == "main_menu:about")
async def about_service(callback: CallbackQuery):
    await callback.message.answer(
        "Этот бот создан, чтобы помочь вам легко найти и арендовать "
        "лучшее жилье в Калининградской области."
    )
    await callback.answer()

--------------------------------------------------------------------------------
--- FILE: src/handlers/user/review.py
--------------------------------------------------------------------------------
from aiogram import F, Router
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery

from src.utils.states import LeaveReview
from src.services.review_service import add_review, get_latest_reviews, get_reviews_summary
# --- ИСПРАВЛЕНИЕ ЗДЕСЬ: Импортируем нужные сервисы и клавиатуры ---
from src.services.property_service import get_property_with_media_and_owner
from src.keyboards.inline_keyboards import get_rating_keyboard, get_property_card_keyboard

router = Router()

# Обработчики для оставления отзыва (без изменений)
# ... (код process_rating и process_comment)
@router.callback_query(F.data.startswith("review:"))
async def process_rating(callback: CallbackQuery, state: FSMContext):
    _, booking_id_str, _, rating_str = callback.data.split(":")
    await state.update_data(
        booking_id=int(booking_id_str),
        rating=int(rating_str)
    )
    await callback.message.edit_text(
        f"Вы поставили оценку: {'⭐️' * int(rating_str)}\n\n"
        "Теперь, пожалуйста, напишите текстовый комментарий... "
        "Или отправьте '-', если не хотите оставлять комментарий."
    )
    await state.set_state(LeaveReview.waiting_for_comment)
    await callback.answer()

@router.message(LeaveReview.waiting_for_comment)
async def process_comment(message: Message, state: FSMContext):
    data = await state.get_data()
    booking_id = data.get('booking_id')
    rating = data.get('rating')
    comment_text = message.text if message.text != '-' else None
    await add_review(
        booking_id=booking_id,
        rating=rating,
        text=comment_text
    )
    await message.answer("Спасибо! Ваш отзыв был успешно сохранен.")
    await state.clear()


@router.callback_query(F.data.startswith("view_reviews:"))
async def view_reviews_handler(callback: CallbackQuery):
    """
    Обработчик для кнопки 'Читать отзывы'.
    Получает отзывы, форматирует их и ВОЗВРАЩАЕТ МЕНЮ.
    """
    await callback.answer()
    property_id = int(callback.data.split(":")[1])
    
    reviews = await get_latest_reviews(property_id, limit=5)
    
    if not reviews:
        await callback.message.answer("У этого объекта еще нет отзывов.")
        # --- ИСПРАВЛЕНИЕ ЗДЕСЬ: Даже если отзывов нет, вернем меню ---
    else:
        response_text = "<b>Последние отзывы:</b>\n\n"
        for review in reviews:
            stars = "⭐️" * review.rating
            comment = f" — «{review.text}»" if review.text else ""
            response_text += f"{stars}{comment}\n"
            response_text += "--------------------\n"
        await callback.message.answer(response_text)

    # --- ИСПРАВЛЕНИЕ ЗДЕСЬ: Возвращаем меню в любом случае ---
    prop, photo_files, video_file = await get_property_with_media_and_owner(property_id)
    _, reviews_count = await get_reviews_summary(prop.id)

    await callback.message.answer(
        text="Выберите дальнейшее действие:",
        reply_markup=get_property_card_keyboard(
            property_id=prop.id,
            photos_count=len(photo_files),
            has_video=bool(video_file),
            reviews_count=reviews_count
        )
    )

--------------------------------------------------------------------------------
--- FILE: src/handlers/user/search.py
--------------------------------------------------------------------------------
from aiogram import F, Router
from aiogram.filters import StateFilter, Command
from aiogram.fsm.context import FSMContext
from aiogram.types import (Message, CallbackQuery, ReplyKeyboardRemove, 
                           KeyboardButton, InputMediaPhoto, InlineKeyboardButton)
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder

from src.services.property_service import get_all_properties
from src.services.review_service import get_reviews_summary
from src.keyboards.inline_keyboards import (get_region_keyboard, get_district_keyboard, 
                                            get_property_card_keyboard, get_guests_keyboard)
from src.core.constants import DISTRICTS
from src.utils.states import SearchProperties

router = Router()

# --- Вспомогательные функции ---

async def show_properties_by_filter(message: Message, state: FSMContext):
    """
    Финальная функция: собирает данные из состояния, делает запрос в БД и показывает результаты.
    """
    data = await state.get_data()
    
    # Вызываем сервис для получения объектов из БД по собранным фильтрам
    properties = await get_all_properties(
        districts=data.get('districts'),
        max_price=data.get('max_price'),
        min_guests=data.get('min_guests')
    )
    
    await state.clear()

    # Обрабатываем случай, когда ничего не найдено
    if not properties:
        await message.answer("К сожалению, по вашему запросу ничего не найдено. Попробуйте изменить критерии поиска.")
        return

    await message.answer(f"✅ Найдено {len(properties)} вариантов:")
    for prop in properties:
        # Получаем рейтинг и количество отзывов для каждого объекта
        avg_rating, reviews_count = await get_reviews_summary(prop.id)
        
        rating_info = ""
        if reviews_count > 0 and avg_rating is not None:
            rating_info = f"⭐️ **{avg_rating:.1f}/5.0** ({reviews_count} отзывов)\n"

        verified_icon = "✅" if prop.is_verified else ""
        rooms_str = f"{prop.rooms} комн." if prop.rooms > 0 else "Студия"
        
        # Формируем красивую карточку объекта
        caption = (
            f"{verified_icon} 🏠 **{prop.title}**\n"
            f"{rating_info}\n"
            f"📝 {prop.description}\n\n"
            f"📍 Район: {prop.district}\n"
            f"🗺️ Адрес: {prop.address}\n"
            f"🛏️ Комнаты: {rooms_str}\n"
            f"💰 Цена: {prop.price_per_night} руб/ночь\n"
            f"👥 Гостей: до {prop.max_guests}"
        )
        
        photo_files = [media.file_id for media in prop.media if media.media_type == 'photo']
        video_note_id = next((media.file_id for media in prop.media if media.media_type == 'video_note'), None)

        # Передаем актуальное количество медиа и отзывов в клавиатуру
        keyboard = get_property_card_keyboard(prop.id, len(photo_files), bool(video_note_id), reviews_count)

        # Отправляем карточку с фото (если есть) или просто текстом
        if photo_files:
            await message.answer_photo(
                photo=photo_files[0],
                caption=caption,
                reply_markup=keyboard
            )
        else:
            await message.answer(caption, reply_markup=keyboard)


def get_skip_keyboard(text: str = "Пропустить"):
    """Возвращает Reply-клавиатуру с одной кнопкой."""
    builder = ReplyKeyboardBuilder()
    builder.add(KeyboardButton(text=text))
    return builder.as_markup(resize_keyboard=True, one_time_keyboard=True)

# --- Логика Поиска (FSM) ---

@router.callback_query(F.data == "main_menu:search")
async def start_search(callback: CallbackQuery, state: FSMContext):
    """Точка входа в поиск. Запускается из главного меню."""
    await callback.message.edit_text("Давайте подберем вам жилье. Выберите регион:", reply_markup=get_region_keyboard())
    await state.set_state(SearchProperties.region)
    await callback.answer()

@router.callback_query(SearchProperties.region, F.data.startswith("add_property_region:"))
async def search_select_region(callback: CallbackQuery, state: FSMContext):
    """Шаг 1: Пользователь выбрал регион."""
    region = callback.data.split(":")[1]
    await state.update_data(region=region)
    
    if region == "Куршская коса":
        await state.update_data(districts=[region])
        await callback.message.answer(
            "Район выбран. Укажите максимальную цену за ночь (например, 5000) или пропустите этот шаг.",
            reply_markup=get_skip_keyboard()
        )
        await state.set_state(SearchProperties.price)
    else:
        await callback.message.edit_text("Уточните локацию:", reply_markup=get_district_keyboard(region))
        await state.set_state(SearchProperties.district)
    await callback.answer()

@router.callback_query(SearchProperties.district, F.data == "back_to_regions")
async def search_back_to_regions(callback: CallbackQuery, state: FSMContext):
    """Обработка кнопки 'Назад' для возврата к выбору региона."""
    await callback.message.edit_text("Выберите регион:", reply_markup=get_region_keyboard())
    await state.set_state(SearchProperties.region)
    await callback.answer()

@router.callback_query(SearchProperties.district, F.data.startswith("search_all_in_region:"))
async def search_all_in_region(callback: CallbackQuery, state: FSMContext):
    """Шаг 2 (альтернативный): Пользователь выбрал все районы в регионе."""
    region = callback.data.split(":")[1]
    districts_in_region = DISTRICTS.get(region, [])
    
    await state.update_data(districts=districts_in_region)
    
    await callback.message.edit_text(f"Выбраны все варианты в '{region}'.")
    await callback.message.answer(
        "Теперь укажите максимальную цену за ночь (например, 5000) или пропустите этот шаг.", 
        reply_markup=get_skip_keyboard()
    )
    await state.set_state(SearchProperties.price)
    await callback.answer()

@router.callback_query(SearchProperties.district, F.data.startswith("add_prop_dist:"))
async def search_select_district(callback: CallbackQuery, state: FSMContext):
    """Шаг 2: Пользователь выбрал конкретный район."""
    _, region, district_index_str = callback.data.split(":")
    district_index = int(district_index_str)
    district_name = DISTRICTS[region][district_index]
    
    await state.update_data(districts=[district_name])
    
    await callback.message.edit_text("Район выбран.")
    await callback.message.answer(
        "Укажите максимальную цену за ночь (например, 5000) или пропустите этот шаг.", 
        reply_markup=get_skip_keyboard()
    )
    await state.set_state(SearchProperties.price)
    await callback.answer()

@router.message(SearchProperties.price)
async def search_by_price(message: Message, state: FSMContext):
    """Шаг 3: Пользователь ввел цену или пропустил шаг."""
    if message.text.lower() != 'пропустить':
        if not message.text.isdigit() or int(message.text) <= 0:
            await message.answer("Пожалуйста, введите цену положительным числом.")
            return
        await state.update_data(max_price=int(message.text))
    
    await message.answer(
        "Хорошо. На какое количество гостей ищете жилье?", 
        reply_markup=ReplyKeyboardRemove()
    )
    
    builder = InlineKeyboardBuilder.from_markup(get_guests_keyboard())
    builder.row(InlineKeyboardButton(text="Пропустить", callback_data="skip_guests_filter"))
    await message.answer("Выберите количество гостей или пропустите:", reply_markup=builder.as_markup())

    await state.set_state(SearchProperties.guests)

@router.callback_query(SearchProperties.guests, F.data == "skip_guests_filter")
async def search_skip_guests(callback: CallbackQuery, state: FSMContext):
    """Обработка пропуска фильтра по гостям."""
    await callback.message.edit_text("Фильтр по гостям пропущен. Идет поиск...")
    await show_properties_by_filter(callback.message, state)
    await callback.answer()

@router.callback_query(SearchProperties.guests, F.data.startswith("add_property_guests:"))
async def search_by_guests(callback: CallbackQuery, state: FSMContext):
    """Шаг 4: Пользователь выбрал количество гостей."""
    guests = callback.data.split(":")[1]
    value_to_save = int(guests.replace('+', ''))
    await state.update_data(min_guests=value_to_save)
    
    await callback.message.edit_text(f"Выбрано гостей: {guests}. Идет поиск...")
    
    await show_properties_by_filter(callback.message, state)
    await callback.answer()

# --- Отмена и некорректный ввод ---

@router.message(StateFilter(SearchProperties), Command("cancel"))
@router.message(StateFilter(SearchProperties), F.text.casefold() == "отмена")
async def cancel_search_handler(message: Message, state: FSMContext):
    """Отмена диалога поиска в любом состоянии."""
    await state.clear()
    await message.answer("Поиск отменен.", reply_markup=ReplyKeyboardRemove())

@router.message(StateFilter(SearchProperties))
async def incorrect_search_input(message: Message):
    """Обработка некорректного ввода (не по кнопке/команде)."""
    await message.answer("Пожалуйста, следуйте инструкциям и используйте кнопки. Для отмены поиска введите /cancel")

--------------------------------------------------------------------------------
--- FILE: src/handlers/owner/manage_property.py
--------------------------------------------------------------------------------
from aiogram import F, Router
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery

# Импортируем все необходимые сервисы и клавиатуры
from src.services.property_service import (get_properties_by_owner, toggle_property_activity, 
                                         delete_property, get_property_with_media_and_owner,
                                         get_owner_properties_summary)
from src.services.booking_service import count_pending_bookings_for_owner
from src.keyboards.inline_keyboards import (get_property_management_keyboard, 
                                           get_delete_confirmation_keyboard)

router = Router()

def format_my_property_card(prop) -> str:
    """Форматирует текстовую карточку объекта для вывода в списке /myproperties."""
    status_verified = "✅ Верифицирован" if prop.is_verified else "☑️ Не верифицирован"
    status_active = "🟢 Активен" if prop.is_active else "🔴 Скрыт"
    return (
        f"🆔 `{prop.id}`: **{prop.title}**\n"
        f"Статусы: {status_verified}, {status_active}"
    )

@router.message(Command("myproperties"))
async def my_properties_list(message: Message):
    """
    Обработчик команды /myproperties.
    Выводит сводную информацию и список объектов владельца с кнопками управления.
    """
    owner_id = message.from_user.id
    
    # Получаем сводную информацию по объектам и заявкам
    total_props, active_props = await get_owner_properties_summary(owner_id)
    pending_bookings = await count_pending_bookings_for_owner(owner_id)
    
    # Формируем и отправляем сводное сообщение
    summary_text = (
        f"Здравствуйте, {message.from_user.first_name}!\n\n"
        f"<b>Ваша приборная панель:</b>\n"
        f"Всего объектов: {total_props}\n"
        f"Активных в поиске: {active_props}\n"
        f"Новых заявок на бронь: {pending_bookings}"
    )
    await message.answer(summary_text)

    # Получаем и выводим список объектов
    properties = await get_properties_by_owner(owner_id=owner_id)
    if not properties:
        await message.answer("У вас пока нет добавленных объектов. Используйте /addproperty, чтобы добавить первый.")
        return
    
    await message.answer("<b>Ваши объекты:</b>")
    for prop in properties:
        # Для каждого объекта отправляем его карточку и клавиатуру управления
        await message.answer(
            format_my_property_card(prop),
            reply_markup=get_property_management_keyboard(prop.id, prop.is_active)
        )

# --- УПРАВЛЕНИЕ ОБЪЕКТОМ ---

@router.callback_query(F.data.startswith("manage:toggle:"))
async def toggle_property_handler(callback: CallbackQuery):
    """
    Обработчик для кнопки 'Скрыть'/'Активировать'.
    Переключает статус is_active у объекта.
    """
    property_id = int(callback.data.split(":")[2])
    new_status = await toggle_property_activity(property_id)
    
    # Обновляем текст сообщения, чтобы отразить новый статус
    prop, _, _ = await get_property_with_media_and_owner(property_id)
    if prop:
        await callback.message.edit_text(
            format_my_property_card(prop),
            reply_markup=get_property_management_keyboard(prop.id, new_status)
        )
    await callback.answer(f"Статус изменен на {'Активен' if new_status else 'Скрыт'}")

@router.callback_query(F.data.startswith("manage:delete:"))
async def delete_property_handler(callback: CallbackQuery):
    """
    Обработчик для кнопки 'Удалить'.
    Показывает клавиатуру с подтверждением удаления.
    """
    property_id = int(callback.data.split(":")[2])
    await callback.message.edit_reply_markup(
        reply_markup=get_delete_confirmation_keyboard(property_id)
    )
    await callback.answer("Пожалуйста, подтвердите удаление.")

@router.callback_query(F.data.startswith("manage:delete_confirm:"))
async def delete_confirm_handler(callback: CallbackQuery):
    """
    Обработчик для кнопки 'Да, удалить'.
    Окончательно удаляет объект из базы данных.
    """
    property_id = int(callback.data.split(":")[2])
    await delete_property(property_id)
    await callback.message.edit_text(f"Объект с ID `{property_id}` был успешно удален.")
    await callback.answer("Объект удален.", show_alert=True)

@router.callback_query(F.data == "manage:delete_cancel")
async def delete_cancel_handler(callback: CallbackQuery):
    """
    Обработчик для кнопки 'Отмена' при удалении.
    Возвращает исходную клавиатуру управления.
    """
    # Извлекаем ID объекта из данных другой кнопки в этой же клавиатуре
    prop_id = None
    for row in callback.message.reply_markup.inline_keyboard:
        for button in row:
            if button.callback_data and button.callback_data.startswith("manage:edit:"):
                prop_id = int(button.callback_data.split(":")[-1])
                break
        if prop_id:
            break

    if prop_id:
        prop, _, _ = await get_property_with_media_and_owner(prop_id)
        if prop:
            # Восстанавливаем исходное сообщение с карточкой объекта
            await callback.message.edit_text(
                format_my_property_card(prop),
                reply_markup=get_property_management_keyboard(prop.id, prop.is_active)
            )
    else:
        # Если что-то пошло не так, просто убираем кнопки
        await callback.message.edit_text("Действие отменено.")
        
    await callback.answer("Удаление отменено.")

--------------------------------------------------------------------------------
--- FILE: src/handlers/owner/edit_property.py
--------------------------------------------------------------------------------
import logging
from aiogram import F, Router
from aiogram.filters import StateFilter, Command
from aiogram.fsm.context import FSMContext
from aiogram.types import (Message, CallbackQuery, ReplyKeyboardRemove)

from src.utils.states import EditProperty
from src.services.property_service import get_property_with_media_and_owner, update_property_field
from src.services.media_service import (delete_one_media_item, add_photos_to_property,
                                        add_video_note_to_property)
# Импортируем все необходимые клавиатуры
from src.keyboards.inline_keyboards import (get_edit_property_keyboard, get_region_keyboard,
                                           get_district_keyboard, get_rooms_keyboard,
                                           get_guests_keyboard, get_property_types_keyboard,
                                           get_media_management_keyboard, get_delete_one_media_keyboard,
                                           get_finish_upload_keyboard)
# Импортируем обработчик /myproperties, чтобы вернуться к нему после редактирования
from .manage_property import my_properties_list
from src.core.constants import DISTRICTS

router = Router()


# --- Вспомогательные функции ---

async def show_edit_menu(message_or_callback: Message | CallbackQuery, state: FSMContext, message_text: str | None = None):
    """
    Отображает главное меню редактирования объекта.
    Эта функция вызывается каждый раз после успешного изменения поля.
    """
    data = await state.get_data()
    property_id = data.get('property_id')

    if not property_id:
        # Критическая ошибка, если мы потеряли ID объекта в состоянии
        logging.error("Не найден property_id в состоянии FSM при попытке показать меню редактирования.")
        if isinstance(message_or_callback, CallbackQuery):
            await message_or_callback.answer("Произошла ошибка, попробуйте снова.", show_alert=True)
        else:
            await message_or_callback.answer("Произошла ошибка, попробуйте снова.")
        await state.clear()
        return

    prop, _, _ = await get_property_with_media_and_owner(property_id)
    if not prop:
        await message_or_callback.answer("Не удалось найти объект. Возможно, он был удален.")
        await state.clear()
        return

    # Формируем текст и клавиатуру для меню
    text = message_text or f"Редактирование объекта: **{prop.title}**\n\nЧто вы хотите изменить?"
    keyboard = get_edit_property_keyboard(property_id)

    # Отправляем или редактируем сообщение
    if isinstance(message_or_callback, Message):
        await message_or_callback.answer(text, reply_markup=keyboard)
    else:
        try:
            # Пытаемся отредактировать, чтобы не было "прыгающих" сообщений
            await message_or_callback.message.edit_text(text, reply_markup=keyboard)
        except Exception as e:
            # Если не получилось (например, текст не изменился), просто отвечаем на колбэк
            logging.warning(f"Не удалось отредактировать сообщение в show_edit_menu: {e}")
            await message_or_callback.answer()

    # Устанавливаем состояние ожидания выбора поля для редактирования
    await state.set_state(EditProperty.choosing_field)


async def start_media_management(callback_query: CallbackQuery, state: FSMContext):
    """
    Запускает интерфейс управления медиафайлами (фото и видео).
    """
    data = await state.get_data()
    property_id = data.get('property_id')
    prop, _, _ = await get_property_with_media_and_owner(property_id)

    # Удаляем предыдущее сообщение с меню, чтобы не было мусора
    await callback_query.message.delete()
    await callback_query.message.answer("Управление медиафайлами:")
    if not prop.media:
        await callback_query.message.answer("У этого объекта еще нет фото или видео.")
    else:
        # Выводим все текущие медиафайлы с кнопкой удаления под каждым
        await callback_query.message.answer("Текущие медиафайлы. Нажмите на 🗑️ под каждым, чтобы удалить.")
        for media in prop.media:
            if media.media_type == 'photo':
                await callback_query.message.answer_photo(media.file_id, reply_markup=get_delete_one_media_keyboard(media.id))
            elif media.media_type == 'video_note':
                await callback_query.message.answer_video_note(media.file_id, reply_markup=get_delete_one_media_keyboard(media.id))

    # Показываем клавиатуру с действиями: добавить еще или завершить
    await callback_query.message.answer("Выберите дальнейшее действие:", reply_markup=get_media_management_keyboard(property_id))
    await state.set_state(EditProperty.managing_media)

# --- Начало диалога редактирования ---

@router.callback_query(F.data.startswith("manage:edit:"))
async def start_property_edit(callback: CallbackQuery, state: FSMContext):
    """
    Точка входа в режим редактирования. Срабатывает по кнопке 'Редактировать'.
    """
    property_id = int(callback.data.split(":")[2])
    # Сохраняем ID объекта в FSM для дальнейшего использования
    await state.update_data(property_id=property_id)
    # Показываем главное меню редактирования
    await show_edit_menu(callback, state)
    await callback.answer()

# --- Главный диспетчер меню редактирования ---

@router.callback_query(EditProperty.choosing_field, F.data.startswith("edit_prop:"))
async def edit_field_prompt(callback: CallbackQuery, state: FSMContext):
    """
    Обрабатывает выбор поля для редактирования из главного меню.
    """
    parts = callback.data.split(":")
    field = parts[1]

    # Особые случаи для медиа и доступности, которые открывают свои интерфейсы
    if field == 'media':
        await start_media_management(callback, state)
        await callback.answer()
        return

    # Словарь с подсказками и состояниями для каждого поля
    prompts = {
        "title": ("Введите новое название:", EditProperty.editing_title),
        "description": ("Введите новое описание:", EditProperty.editing_description),
        "address": ("Введите новый адрес:", EditProperty.editing_address),
        "price": ("Введите новую цену за ночь (только цифры):", EditProperty.editing_price),
        "rooms": ("Выберите новое кол-во комнат:", EditProperty.editing_rooms),
        "guests": ("Выберите новое кол-во гостей:", EditProperty.editing_guests),
        "type": ("Выберите новый тип объекта:", EditProperty.editing_type),
    }

    if field in prompts:
        prompt_text, new_state = prompts[field]
        # Для некоторых полей нужна клавиатура выбора
        keyboard = None
        if field == 'rooms': keyboard = get_rooms_keyboard()
        if field == 'guests': keyboard = get_guests_keyboard()
        if field == 'type': keyboard = get_property_types_keyboard()

        await callback.message.edit_text(prompt_text, reply_markup=keyboard)
        await state.set_state(new_state)

    await callback.answer()

# --- Обработка новых значений от пользователя ---

@router.message(StateFilter(EditProperty.editing_title, EditProperty.editing_description, EditProperty.editing_address))
async def process_new_text_field(message: Message, state: FSMContext):
    """Обрабатывает ввод нового текстового значения (название, описание, адрес)."""
    current_state_str = await state.get_state()
    field_map = {
        EditProperty.editing_title.state: 'title',
        EditProperty.editing_description.state: 'description',
        EditProperty.editing_address.state: 'address',
    }
    field_to_update = field_map[current_state_str]

    data = await state.get_data()
    # Вызываем сервис для обновления поля в БД
    await update_property_field(data['property_id'], field_to_update, message.text)

    await message.answer(f"Поле '{field_to_update.replace('_', ' ').capitalize()}' успешно обновлено!")
    # Возвращаемся в главное меню редактирования
    await show_edit_menu(message, state)

@router.message(EditProperty.editing_price)
async def process_new_price(message: Message, state: FSMContext):
    """Обрабатывает ввод новой цены."""
    if not message.text.isdigit():
        await message.answer("Пожалуйста, введите цену цифрами.")
        return
    data = await state.get_data()
    await update_property_field(data['property_id'], 'price_per_night', int(message.text))
    await message.answer("Цена успешно обновлена!")
    await show_edit_menu(message, state)

@router.callback_query(StateFilter(EditProperty.editing_rooms, EditProperty.editing_guests, EditProperty.editing_type))
async def process_new_button_field(callback: CallbackQuery, state: FSMContext):
    """Обрабатывает выбор нового значения с инлайн-кнопок (комнаты, гости, тип)."""
    current_state_str = await state.get_state()
    field_map = {
        EditProperty.editing_rooms.state: ('rooms', 'add_property_rooms:'),
        EditProperty.editing_guests.state: ('max_guests', 'add_property_guests:'),
        EditProperty.editing_type.state: ('property_type', 'add_property_type:'),
    }
    field_to_update, prefix = field_map[current_state_str]
    value = callback.data.replace(prefix, '')

    # Преобразуем строковые значения в числовые для БД
    if field_to_update == 'rooms':
        value_to_save = 0 if value == 'Студия' else int(value.replace('+', ''))
    elif field_to_update == 'max_guests':
        value_to_save = int(value.replace('+', ''))
    else:
        value_to_save = value

    data = await state.get_data()
    await update_property_field(data['property_id'], field_to_update, value_to_save)

    await callback.message.answer(f"Поле '{field_to_update.replace('_', ' ').capitalize()}' успешно обновлено!")
    await show_edit_menu(callback, state)
    await callback.answer()

# --- Управление медиафайлами (в режиме редактирования) ---

@router.callback_query(EditProperty.managing_media, F.data.startswith("edit_media:delete:"))
async def delete_media_item_handler(callback: CallbackQuery):
    """Удаляет один медиафайл по кнопке под ним."""
    media_id = int(callback.data.split(":")[2])
    await delete_one_media_item(media_id)
    # Просто удаляем сообщение с этим медиа
    await callback.message.delete()
    await callback.answer("Медиафайл удален.", show_alert=True)

@router.callback_query(EditProperty.managing_media, F.data.startswith("edit_media:add:"))
async def add_more_media_prompt(callback: CallbackQuery, state: FSMContext):
    """Запускает процесс добавления новых медиафайлов."""
    await callback.message.answer(
        "Отправьте новые фото (до 10) или видео-кружочек. Когда закончите, нажмите кнопку.",
        reply_markup=get_finish_upload_keyboard()
    )
    await state.set_state(EditProperty.adding_photos)
    await callback.answer()

@router.message(StateFilter(EditProperty.adding_photos), F.photo)
async def handle_new_photos_in_edit(message: Message, state: FSMContext):
    """Ловит новые фотографии в режиме добавления."""
    photos = (await state.get_data()).get('photos_to_add', [])
    if len(photos) >= 10:
        await message.answer("Вы уже добавили 10 фото. Нажмите 'Завершить загрузку'.")
        return
    photos.append(message.photo[-1].file_id)
    await state.update_data(photos_to_add=photos)

@router.message(StateFilter(EditProperty.adding_photos), F.text == "Завершить загрузку")
async def finish_adding_photos_in_edit(message: Message, state: FSMContext):
    """Завершает процесс добавления новых фото, сохраняет их в БД."""
    data = await state.get_data()
    photos = data.get('photos_to_add')
    property_id = data.get('property_id')
    if not photos:
        await message.answer("Вы не отправили ни одного файла. Нажмите 'Отмена' для выхода.", reply_markup=ReplyKeyboardRemove())
        await show_edit_menu(message, state)
        return

    await add_photos_to_property(property_id, photos)
    
    await message.answer("Новые фото добавлены!", reply_markup=ReplyKeyboardRemove())
    # Очищаем временное хранилище фото и возвращаемся в меню
    await state.update_data(photos_to_add=[])
    await show_edit_menu(message, state)

# --- Выход и Отмена ---

@router.callback_query(StateFilter(EditProperty.managing_media), F.data.startswith("edit_media:done:"))
async def finish_media_management(callback: CallbackQuery, state: FSMContext):
    """Выход из режима управления медиа в главное меню редактирования."""
    await callback.message.delete()
    await show_edit_menu(callback, state)
    await callback.answer()

@router.callback_query(EditProperty.choosing_field, F.data == "back_to_my_properties")
async def back_to_list_from_edit(callback: CallbackQuery, state: FSMContext):
    """Выход из режима редактирования в общий список объектов /myproperties."""
    await state.clear()
    await callback.message.delete()
    # Вызываем хендлер команды /myproperties, чтобы показать актуальный список
    await my_properties_list(callback.message)
    await callback.answer("Вы вышли из режима редактирования.")

@router.message(StateFilter(EditProperty), Command("cancel"))
@router.message(StateFilter(EditProperty), F.text.casefold() == "отмена")
async def cancel_edit_handler(message: Message, state: FSMContext):
    """Отмена любого шага редактирования по команде /cancel или слову 'отмена'."""
    await state.clear()
    await message.answer("Редактирование отменено.", reply_markup=ReplyKeyboardRemove())

--------------------------------------------------------------------------------
--- FILE: src/handlers/owner/booking_management.py
--------------------------------------------------------------------------------
from aiogram import F, Router, Bot
from aiogram.types import CallbackQuery
from src.services.repository import update_booking_status, get_booking_with_details

router = Router()

@router.callback_query(F.data.startswith("booking:confirm:"))
async def confirm_booking(callback: CallbackQuery, bot: Bot):
    booking_id = int(callback.data.split(":")[2])
    
    # Обновляем статус в БД и получаем обновленную запись
    booking = await update_booking_status(booking_id, "confirmed")
    if not booking:
        await callback.answer("Бронирование не найдено.", show_alert=True)
        return

    # Убираем кнопки и пишем, что заявка принята
    await callback.message.edit_text(f"{callback.message.text}\n\n--- \n✅ ВЫ ПРИНЯЛИ ЭТУ ЗАЯВКУ ---")
    
    # Отправляем уведомление арендатору
    try:
        await bot.send_message(
            chat_id=booking.user.telegram_id,
            text=f"🎉 Ваша заявка на бронирование объекта «{booking.property.title}» была ОДОБРЕНА!\n\nВладелец скоро свяжется с вами для уточнения деталей."
        )
    except Exception as e:
        print(f"Не удалось отправить уведомление арендатору: {e}")
        
    await callback.answer("Вы успешно приняли заявку!")


@router.callback_query(F.data.startswith("booking:reject:"))
async def reject_booking(callback: CallbackQuery, bot: Bot):
    booking_id = int(callback.data.split(":")[2])
    
    booking = await update_booking_status(booking_id, "rejected")
    if not booking:
        await callback.answer("Бронирование не найдено.", show_alert=True)
        return

    await callback.message.edit_text(f"{callback.message.text}\n\n--- \n❌ ВЫ ОТКЛОНИЛИ ЭТУ ЗАЯВКУ ---")

    try:
        await bot.send_message(
            chat_id=booking.user.telegram_id,
            text=f"😔 К сожалению, ваша заявка на бронирование объекта «{booking.property.title}» была ОТКЛОНЕНА."
        )
    except Exception as e:
        print(f"Не удалось отправить уведомление арендатору: {e}")
        
    await callback.answer("Вы отклонили заявку.")

--------------------------------------------------------------------------------
--- FILE: src/handlers/owner/add_property.py
--------------------------------------------------------------------------------
import logging
from aiogram import F, Router
from aiogram.filters import Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery, ReplyKeyboardRemove

from src.utils.states import AddProperty
from src.services.user_service import get_user
from src.services.property_service import add_property
from src.services.media_service import add_photos_to_property, add_video_note_to_property

# --- ИСПРАВЛЕНИЕ ЗДЕСЬ: Указываем единственно верный файл с клавиатурами ---
from src.keyboards.inline_keyboards import (get_region_keyboard, get_district_keyboard, get_rooms_keyboard, 
                                           get_property_types_keyboard, get_guests_keyboard, 
                                           get_finish_upload_keyboard, get_skip_video_keyboard)
from src.core.constants import DISTRICTS

router = Router()

# --- Начало диалога ---
@router.callback_query(F.data == "main_menu:add_property")
async def add_property_callback(callback: CallbackQuery, state: FSMContext):
    user = await get_user(callback.from_user.id)
    if not user or user.role not in ['owner', 'admin']:
        await callback.answer("Эта функция доступна только владельцам объектов.", show_alert=True)
        return
        
    await callback.message.edit_text("Начинаем. Введите броское название вашего объекта (например, 'Лофт с видом на Кафедральный собор').")
    await state.set_state(AddProperty.title)
    await callback.answer()

@router.message(Command("addproperty"))
async def add_property_start(message: Message, state: FSMContext):
    user = await get_user(message.from_user.id)
    if not user or user.role not in ['owner', 'admin']:
        await message.answer("Эта функция доступна только владельцам объектов.")
        return
        
    await message.answer("Начинаем. Введите броское название вашего объекта (например, 'Лофт с видом на Кафедральный собор').")
    await state.set_state(AddProperty.title)


# --- Основная цепочка диалога ---

@router.message(AddProperty.title)
async def add_property_title(message: Message, state: FSMContext):
    await state.update_data(title=message.text)
    await message.answer("Отлично. Теперь добавьте яркое описание, расскажите о преимуществах.")
    await state.set_state(AddProperty.description)

@router.message(AddProperty.description)
async def add_property_description(message: Message, state: FSMContext):
    await state.update_data(description=message.text)
    await message.answer("Теперь выберите, где находится ваш объект:", reply_markup=get_region_keyboard())
    await state.set_state(AddProperty.region)

@router.callback_query(AddProperty.region, F.data.startswith("add_property_region:"))
async def add_property_region(callback: CallbackQuery, state: FSMContext):
    region = callback.data.split(":")[1]
    await state.update_data(region=region)
    if region == "Куршская коса":
        await state.update_data(district=region)
        await callback.message.edit_text("Принято. Теперь введите точный адрес (поселок, улица, дом).")
        await state.set_state(AddProperty.address)
    else:
        await callback.message.edit_text("Уточните локацию:", reply_markup=get_district_keyboard(region))
        await state.set_state(AddProperty.district)
    await callback.answer()

@router.callback_query(AddProperty.district, F.data == "back_to_regions")
async def back_to_regions(callback: CallbackQuery, state: FSMContext):
    await callback.message.edit_text("Выберите, где находится ваш объект:", reply_markup=get_region_keyboard())
    await state.set_state(AddProperty.region)
    await callback.answer()

@router.callback_query(AddProperty.district, F.data.startswith("add_prop_dist:"))
async def add_property_district(callback: CallbackQuery, state: FSMContext):
    _, region, district_index_str = callback.data.split(":")
    district_index = int(district_index_str)
    district_name = DISTRICTS[region][district_index]
    await state.update_data(district=district_name)
    await callback.message.edit_text("Принято. Теперь введите точный адрес (улица, дом).")
    await state.set_state(AddProperty.address)
    await callback.answer()

@router.message(AddProperty.address)
async def add_property_address(message: Message, state: FSMContext):
    await state.update_data(address=message.text)
    await message.answer("Укажите количество комнат:", reply_markup=get_rooms_keyboard())
    await state.set_state(AddProperty.rooms)
    
@router.callback_query(AddProperty.rooms, F.data.startswith("add_property_rooms:"))
async def add_property_rooms(callback: CallbackQuery, state: FSMContext):
    rooms = callback.data.split(":")[1]
    await state.update_data(rooms=rooms)
    await callback.message.edit_text("Супер. Укажите цену за ночь в рублях (только цифры).")
    await state.set_state(AddProperty.price_per_night)
    await callback.answer()

@router.message(AddProperty.price_per_night)
async def add_property_price(message: Message, state: FSMContext):
    if not message.text.isdigit():
        await message.answer("Пожалуйста, введите цену цифрами.")
        return
    await state.update_data(price_per_night=message.text)
    await message.answer("Хорошо. Теперь выберите максимальное количество гостей:", reply_markup=get_guests_keyboard())
    await state.set_state(AddProperty.max_guests)

@router.callback_query(AddProperty.max_guests, F.data.startswith("add_property_guests:"))
async def add_property_guests(callback: CallbackQuery, state: FSMContext):
    guests = callback.data.split(":")[1]
    await state.update_data(max_guests=guests)
    await callback.message.edit_text("И последнее: выберите тип объекта:", reply_markup=get_property_types_keyboard())
    await state.set_state(AddProperty.property_type)
    await callback.answer()

@router.callback_query(AddProperty.property_type, F.data.startswith("add_property_type:"))
async def add_property_type_final(callback: CallbackQuery, state: FSMContext):
    property_type = callback.data.split(":")[1]
    await state.update_data(property_type=property_type)
    data = await state.get_data()
    
    try:
        property_id = await add_property(data, owner_id=callback.from_user.id)
        await state.update_data(property_id=property_id)
        
        await callback.message.edit_text("Текстовая информация сохранена.")
        await callback.message.answer(
            "Теперь отправьте мне от 1 до 10 фотографий вашего объекта. "
            "Можно отправить их одним альбомом. Когда закончите, нажмите кнопку 'Завершить загрузку'.",
            reply_markup=get_finish_upload_keyboard()
        )
        await state.set_state(AddProperty.photos)
    except Exception as e:
        logging.error(f"Ошибка при добавлении объекта в БД: {e}")
        await callback.message.answer("К сожалению, при сохранении произошла ошибка.")
        await state.clear()
    finally:
        await callback.answer()

@router.message(AddProperty.photos, F.photo)
async def handle_photos(message: Message, state: FSMContext):
    photos = (await state.get_data()).get('photos', [])
    if len(photos) >= 10:
        await message.answer("Вы уже загрузили максимальное количество фотографий (10). Нажмите 'Завершить загрузку'.")
        return
    photos.append(message.photo[-1].file_id)
    await state.update_data(photos=photos)

@router.message(AddProperty.photos, F.text == "Завершить загрузку")
async def finish_photo_upload(message: Message, state: FSMContext):
    data = await state.get_data()
    photos = data.get('photos')
    property_id = data.get('property_id')

    if not photos:
        await message.answer("Вы не загрузили ни одной фотографии. Пожалуйста, отправьте хотя бы одну или отмените /cancel")
        return

    try:
        await add_photos_to_property(property_id, photos)
        await message.answer(
            "Фотографии сохранены. Теперь, если хотите, запишите и отправьте короткий видео-тур ('кружочек') по объекту. Это сильно повысит доверие. Или пропустите этот шаг.",
            reply_markup=get_skip_video_keyboard()
        )
        await state.set_state(AddProperty.video_note)
    except Exception as e:
        logging.error(f"Ошибка при сохранении фото в БД: {e}")
        await message.answer("Произошла ошибка при сохранении фотографий. Пожалуйста, попробуйте позже.", reply_markup=ReplyKeyboardRemove())
        await state.clear()
        
@router.message(AddProperty.video_note, F.video_note)
async def handle_video_note(message: Message, state: FSMContext):
    data = await state.get_data()
    property_id = data.get('property_id')
    
    try:
        await add_video_note_to_property(property_id, message.video_note.file_id)
        await message.answer(
            "<b>Отлично! Ваш объект с фото и видео-туром успешно добавлен!</b>",
            parse_mode="HTML",
            reply_markup=ReplyKeyboardRemove()
        )
    except Exception as e:
        logging.error(f"Ошибка при сохранении видео в БД: {e}")
        await message.answer("Произошла ошибка при сохранении видео. Пожалуйста, попробуйте позже.", reply_markup=ReplyKeyboardRemove())
    finally:
        await state.clear()

@router.message(AddProperty.video_note, F.text.in_({"Пропустить этот шаг", "Отмена"}))
async def skip_video_note(message: Message, state: FSMContext):
    await message.answer(
        "<b>Хорошо! Ваш объект с фотографиями успешно добавлен!</b>",
        parse_mode="HTML",
        reply_markup=ReplyKeyboardRemove()
    )
    await state.clear()
    
@router.message(AddProperty.photos)
async def incorrect_photo_upload(message: Message):
    await message.answer(
        "Пожалуйста, отправьте фотографию или нажмите кнопку 'Завершить загрузку' / 'Отмена'.",
        reply_markup=get_finish_upload_keyboard()
    )
    
@router.message(AddProperty.video_note)
async def incorrect_video_upload(message: Message):
    await message.answer(
        "Пожалуйста, отправьте видео-сообщение ('кружочек') или нажмите кнопку 'Пропустить этот шаг' / 'Отмена'.",
        reply_markup=get_skip_video_keyboard()
    )

@router.message(StateFilter(AddProperty), Command("cancel"))
@router.message(StateFilter(AddProperty), F.text.casefold() == "отмена")
async def cancel_add_handler(message: Message, state: FSMContext):
    await state.clear()
    await message.answer("Действие отменено.", reply_markup=ReplyKeyboardRemove())

--------------------------------------------------------------------------------
--- FILE: src/services/__init__.py
--------------------------------------------------------------------------------
# Этот файл нужен, чтобы Python считал папку 'services' пакетом.
# Мы можем использовать его для удобного импорта, но сейчас оставим его простым.

# --- ИЗМЕНЕНИЕ ЗДЕСЬ: Убираем импорт несуществующей функции ---
# и импортируем новую, если это потребуется в будущем.
# Пока что для чистоты можно оставить его пустым или импортировать нужные функции.

# from .availability_service import get_manual_blocks, set_availability_for_period
# from .booking_service import ...
# from .pricing_service import ...
# from .property_service import ...
# from .review_service import ...
# from .user_service import ...

# На данном этапе для чистоты оставим файл пустым, 
# так как все импорты происходят напрямую из модулей.

--------------------------------------------------------------------------------
--- FILE: src/services/booking_service.py
--------------------------------------------------------------------------------
from datetime import datetime, timedelta
from sqlalchemy import select, update, func, and_
from sqlalchemy.orm import selectinload

from src.models.models import Booking, Property
from .db import async_session_maker


async def create_booking(user_id: int, property_id: int, start_date: datetime, end_date: datetime) -> Booking:
    """Создает новую заявку на бронирование с датами и статусом 'pending'."""
    async with async_session_maker() as session:
        new_booking = Booking(
            user_id=user_id,
            property_id=property_id,
            start_date=start_date,
            end_date=end_date
        )
        session.add(new_booking)
        await session.commit()
        return new_booking

async def update_booking_status(booking_id: int, status: str) -> Booking | None:
    """Обновляет статус бронирования (pending, confirmed, rejected)."""
    async with async_session_maker() as session:
        booking = await session.get(Booking, booking_id)
        if booking:
            booking.status = status
            await session.commit()
        return booking

async def get_booking_with_details(booking_id: int):
    """Получает бронирование со связанными данными пользователя и объекта."""
    async with async_session_maker() as session:
        query = (
            select(Booking)
            .where(Booking.id == booking_id)
            .options(selectinload(Booking.user), selectinload(Booking.property))
        )
        result = await session.execute(query)
        return result.unique().scalar_one_or_none()


async def count_pending_bookings_for_owner(owner_id: int) -> int:
    """Подсчитывает количество необработанных заявок ('pending') для владельца."""
    async with async_session_maker() as session:
        query = (
            select(func.count(Booking.id))
            .join(Property, Booking.property_id == Property.id)
            .where(
                and_(
                    Property.owner_id == owner_id,
                    Booking.status == 'pending'
                )
            )
        )
        result = await session.execute(query)
        return result.scalar_one()

async def get_booked_dates_for_property(property_id: int) -> list[datetime.date]:
    """
    Возвращает список всех дат, занятых подтвержденными бронированиями ('confirmed').
    """
    async with async_session_maker() as session:
        query = select(Booking.start_date, Booking.end_date).where(
            and_(
                Booking.property_id == property_id,
                Booking.status == 'confirmed'
            )
        )
        result = await session.execute(query)
        booked_dates = []
        for start_date, end_date in result.all():
            current_date = start_date
            # Бронирование не включает день выезда, поэтому <
            while current_date < end_date:
                booked_dates.append(current_date.date())
                current_date += timedelta(days=1)
        return booked_dates


--------------------------------------------------------------------------------
--- FILE: src/services/user_service.py
--------------------------------------------------------------------------------
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import async_sessionmaker

from src.models.models import User
from .db import async_session_maker

async def add_user(telegram_id: int, username: str | None, first_name: str) -> User:
    async with async_session_maker() as session:
        result = await session.execute(select(User).where(User.telegram_id == telegram_id))
        user = result.scalar_one_or_none()
        if user is None:
            new_user = User(telegram_id=telegram_id, username=username, first_name=first_name)
            session.add(new_user)
            await session.commit()
            return new_user
        return user

async def get_user(user_id: int) -> User | None:
    async with async_session_maker() as session:
        return await session.get(User, user_id)

async def set_user_role(user_id: int, role: str):
    async with async_session_maker() as session:
        query = update(User).where(User.telegram_id == user_id).values(role=role)
        await session.execute(query)
        await session.commit()

--------------------------------------------------------------------------------
--- FILE: src/services/availability_service.py
--------------------------------------------------------------------------------
from datetime import date
from typing import List
from sqlalchemy import select, delete, and_
from sqlalchemy.dialects.postgresql import insert

from src.models.models import UnavailableDate
from src.services.db import async_session_maker

async def get_manual_blocks(property_id: int) -> List[UnavailableDate]:
    """Возвращает список дат, заблокированных владельцем вручную."""
    async with async_session_maker() as session:
        query = select(UnavailableDate).where(UnavailableDate.property_id == property_id)
        result = await session.execute(query)
        return result.scalars().all()

async def set_availability_for_period(property_id: int, dates: List[date], is_available: bool, comment: str | None):
    """
    Устанавливает статус доступности для списка дат.
    Если is_available=False, добавляет/обновляет блокировки.
    Если is_available=True, удаляет блокировки.
    """
    async with async_session_maker() as session:
        if not is_available:
            # Используем "ON CONFLICT DO UPDATE", чтобы обновить комментарий, если дата уже заблокирована
            stmt = insert(UnavailableDate).values(
                [
                    {"property_id": property_id, "date": d, "comment": comment}
                    for d in dates
                ]
            )
            update_stmt = stmt.on_conflict_do_update(
                index_elements=['property_id', 'date'], # Уникальный ключ
                set_={'comment': stmt.excluded.comment}
            )
            await session.execute(update_stmt)
        else:
            # Удаляем все блокировки для указанных дат
            stmt = delete(UnavailableDate).where(
                and_(
                    UnavailableDate.property_id == property_id,
                    UnavailableDate.date.in_(dates)
                )
            )
            await session.execute(stmt)
        
        await session.commit()

--------------------------------------------------------------------------------
--- FILE: src/services/property_service.py
--------------------------------------------------------------------------------
from sqlalchemy import select, update, delete, func, and_
from sqlalchemy.ext.asyncio import async_sessionmaker
from sqlalchemy.orm import selectinload

from src.models.models import Property, PropertyMedia
from .db import async_session_maker


async def add_property(data: dict, owner_id: int) -> int:
    async with async_session_maker() as session:
        rooms_str = data.get('rooms', '0')
        rooms_int = 0 if rooms_str == 'Студия' else int(rooms_str.replace('+', ''))
        guests_str = data.get('max_guests', '1')
        guests_int = int(guests_str.replace('+', ''))
        new_property = Property(
            owner_id=owner_id,
            title=data.get('title'),
            description=data.get('description'),
            district=data.get('district'),
            address=data.get('address'),
            rooms=rooms_int,
            price_per_night=int(data.get('price_per_night')),
            max_guests=guests_int,
            property_type=data.get('property_type')
        )
        session.add(new_property)
        await session.flush()
        property_id = new_property.id
        await session.commit()
        return property_id

async def get_all_properties(
    districts: list[str] | None = None, 
    max_price: int | None = None, 
    min_guests: int | None = None
):
    """
    Возвращает список всех активных объектов с учетом фильтров.
    """
    async with async_session_maker() as session:
        query = (
            select(Property)
            .where(Property.is_active == True)
            .options(selectinload(Property.media))
        )
        
        if districts:
            query = query.where(Property.district.in_(districts)) # Используем .in_ для списка
        if max_price:
            query = query.where(Property.price_per_night <= max_price)
        if min_guests:
            query = query.where(Property.max_guests >= min_guests)
            
        result = await session.execute(query)
        return result.unique().scalars().all()
# --- КОНЕЦ ИСПРАВЛЕНИЯ ---

async def get_property_with_media_and_owner(property_id: int):
    async with async_session_maker() as session:
        query = (
            select(Property)
            .where(Property.id == property_id)
            .options(selectinload(Property.owner), selectinload(Property.media))
        )
        result = await session.execute(query)
        prop = result.unique().scalar_one_or_none()
        if prop:
            photo_files = [media.file_id for media in prop.media if media.media_type == 'photo']
            video_file = next((media.file_id for media in prop.media if media.media_type == 'video_note'), None)
            return prop, photo_files, video_file
        return None, [], None

async def set_property_verified(property_id: int, status: bool = True):
    async with async_session_maker() as session:
        query = update(Property).where(Property.id == property_id).values(is_verified=status)
        await session.execute(query)
        await session.commit()

async def get_properties_by_owner(owner_id: int):
    async with async_session_maker() as session:
        query = select(Property).where(Property.owner_id == owner_id).order_by(Property.id)
        result = await session.execute(query)
        return result.scalars().all()

async def toggle_property_activity(property_id: int) -> bool:
    async with async_session_maker() as session:
        prop = await session.get(Property, property_id)
        if prop:
            prop.is_active = not prop.is_active
            await session.commit()
            return prop.is_active
    return False

async def delete_property(property_id: int):
    async with async_session_maker() as session:
        await session.execute(delete(Property).where(Property.id == property_id))
        await session.commit()

async def update_property_field(property_id: int, field: str, value):
    async with async_session_maker() as session:
        query = update(Property).where(Property.id == property_id).values({field: value})
        await session.execute(query)
        await session.commit()

# --- НОВАЯ ФУНКЦИЯ ---
async def get_owner_properties_summary(owner_id: int) -> tuple[int, int]:
    """
    Подсчитывает общее и активное количество объектов владельца.
    Возвращает кортеж (total_count, active_count).
    """
    async with async_session_maker() as session:
        # Считаем общее количество
        total_query = select(func.count(Property.id)).where(Property.owner_id == owner_id)
        total_result = await session.execute(total_query)
        total_count = total_result.scalar_one()

        # Считаем количество активных
        active_query = select(func.count(Property.id)).where(
            and_(Property.owner_id == owner_id, Property.is_active == True)
        )
        active_result = await session.execute(active_query)
        active_count = active_result.scalar_one()
        
        return total_count, active_count

--------------------------------------------------------------------------------
--- FILE: src/services/review_service.py
--------------------------------------------------------------------------------
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import async_sessionmaker

from src.models.models import Booking, Review
from .db import async_session_maker

async def add_review(booking_id: int, rating: int, text: str | None):
    async with async_session_maker() as session:
        booking = await session.get(Booking, booking_id)
        if not booking:
            return

        new_review = Review(
            property_id=booking.property_id,
            user_id=booking.user_id,
            booking_id=booking_id,
            rating=rating,
            text=text
        )
        session.add(new_review)
        await session.commit()

# --- НОВЫЕ ФУНКЦИИ ---

async def get_reviews_summary(property_id: int) -> tuple[float | None, int]:
    """
    Возвращает средний рейтинг и количество отзывов для объекта.
    """
    async with async_session_maker() as session:
        query = (
            select(
                func.avg(Review.rating),
                func.count(Review.id)
            )
            .where(Review.property_id == property_id)
        )
        result = await session.execute(query)
        # one_or_none() вернет (None, 0), если отзывов нет
        avg_rating, count = result.one_or_none() or (None, 0)
        return avg_rating, count

async def get_latest_reviews(property_id: int, limit: int = 5):
    """
    Возвращает последние N отзывов для объекта.
    """
    async with async_session_maker() as session:
        query = (
            select(Review)
            .where(Review.property_id == property_id)
            .order_by(Review.created_at.desc())
            .limit(limit)
        )
        result = await session.execute(query)
        return result.scalars().all()

--------------------------------------------------------------------------------
--- FILE: src/services/db.py
--------------------------------------------------------------------------------
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
from src.core.settings import settings

# echo=False, чтобы не засорять логи SQL-запросами в продакшене
engine = create_async_engine(settings.DATABASE_URL_asyncpg, echo=False) 
async_session_maker = async_sessionmaker(engine, expire_on_commit=False)

--------------------------------------------------------------------------------
--- FILE: src/services/pricing_service.py
--------------------------------------------------------------------------------
from datetime import date
from sqlalchemy import select, and_, delete
from sqlalchemy.orm import selectinload

from src.models.models import Property, PriceRule
from .db import async_session_maker

async def get_price_for_date(session, property_id: int, target_date: date, base_price: int) -> int:
    """
    Определяет цену для конкретной даты, учитывая правила.
    Правило, которое начинается позже, имеет приоритет.
    """
    query = (
        select(PriceRule.price)
        .where(
            and_(
                PriceRule.property_id == property_id,
                PriceRule.start_date <= target_date,
                PriceRule.end_date >= target_date
            )
        )
        .order_by(PriceRule.start_date.desc())
        .limit(1)
    )
    result = await session.execute(query)
    rule_price = result.scalar_one_or_none()

    return rule_price if rule_price is not None else base_price

async def get_property_with_price_rules(session, property_id: int):
    """Загружает объект со всеми его ценовыми правилами."""
    query = (
        select(Property)
        .where(Property.id == property_id)
        .options(selectinload(Property.price_rules))
    )
    result = await session.execute(query)
    return result.scalar_one_or_none()

async def add_price_rule(property_id: int, start_date: date, end_date: date, price: int) -> PriceRule:
    """Создает новое ценовое правило."""
    async with async_session_maker() as session:
        new_rule = PriceRule(
            property_id=property_id,
            start_date=start_date,
            end_date=end_date,
            price=price
        )
        session.add(new_rule)
        await session.commit()
        await session.refresh(new_rule)
        return new_rule

async def get_price_rules_for_property(property_id: int) -> list[PriceRule]:
    """Получает все ценовые правила для объекта."""
    async with async_session_maker() as session:
        query = select(PriceRule).where(PriceRule.property_id == property_id).order_by(PriceRule.start_date)
        result = await session.execute(query)
        return result.scalars().all()

async def delete_price_rule(rule_id: int) -> bool:
    """Удаляет ценовое правило по его ID."""
    async with async_session_maker() as session:
        result = await session.execute(delete(PriceRule).where(PriceRule.id == rule_id))
        await session.commit()
        return result.rowcount > 0


--------------------------------------------------------------------------------
--- FILE: src/services/media_service.py
--------------------------------------------------------------------------------
from sqlalchemy import delete
from sqlalchemy.ext.asyncio import async_sessionmaker

from src.models.models import PropertyMedia
from .db import async_session_maker

async def add_photos_to_property(property_id: int, photo_file_ids: list[str]):
    async with async_session_maker() as session:
        for file_id in photo_file_ids:
            new_photo = PropertyMedia(
                property_id=property_id,
                file_id=file_id,
                media_type='photo'
            )
            session.add(new_photo)
        await session.commit()
        
async def add_video_note_to_property(property_id: int, file_id: str):
    async with async_session_maker() as session:
        new_video_note = PropertyMedia(
            property_id=property_id,
            file_id=file_id,
            media_type='video_note'
        )
        session.add(new_video_note)
        await session.commit()

async def delete_all_media_for_property(property_id: int):
    async with async_session_maker() as session:
        await session.execute(delete(PropertyMedia).where(PropertyMedia.property_id == property_id))
        await session.commit()

async def delete_one_media_item(media_id: int):
    async with async_session_maker() as session:
        await session.execute(delete(PropertyMedia).where(PropertyMedia.id == media_id))
        await session.commit()

--------------------------------------------------------------------------------
--- FILE: src/web/routes.py
--------------------------------------------------------------------------------
import calendar
from datetime import date, datetime
from aiohttp import web
from aiogram.types import Update

from src.services import availability_service, booking_service, pricing_service
from src.services.db import async_session_maker

# --- ОБРАБОТЧИКИ ---

async def webhook_handler(request: web.Request) -> web.Response:
    if request.headers.get("X-Telegram-Bot-Api-Secret-Token") != request.app["webhook_secret"]:
        return web.json_response({"error": "Unauthorized"}, status=401)
    
    dp = request.app["dp"]
    bot = request.app["bot"]
    
    update = Update.model_validate(await request.json(), context={"bot": bot})
    await dp.feed_update(bot, update)
    
    return web.Response()

async def client_webapp_handler(request: web.Request) -> web.Response:
    return web.FileResponse('src/static/index.html')

# --- ИЗМЕНЕНИЕ: Возвращаем обработчик для Web App владельца ---
async def owner_webapp_handler(request: web.Request) -> web.Response:
    return web.FileResponse('src/static/owner.html')

async def get_calendar_data(request: web.Request) -> web.Response:
    try:
        property_id = int(request.match_info['property_id'])
        year = int(request.query.get('year', date.today().year))
        month = int(request.query.get('month', date.today().month))
    except (ValueError, KeyError):
        return web.json_response({'error': 'Invalid or missing parameters'}, status=400)

    async with async_session_maker() as session:
        prop = await pricing_service.get_property_with_price_rules(session, property_id)
        if not prop:
            return web.json_response({'error': 'Property not found'}, status=404)
        base_price = prop.price_per_night
        manual_blocks = await availability_service.get_manual_blocks(property_id)
        manual_block_map = {block.date: block.comment for block in manual_blocks}
        booked_dates = await booking_service.get_booked_dates_for_property(property_id)
        days_data = []
        days_in_month = calendar.monthrange(year, month)[1]
        for day_num in range(1, days_in_month + 1):
            current_date = date(year, month, day_num)
            status = 'available'
            comment = None
            if current_date < date.today():
                status = 'past'
            elif current_date in booked_dates:
                status = 'booked'
            elif current_date in manual_block_map:
                status = 'manual_block'
                comment = manual_block_map[current_date]
            price = None
            if status == 'available':
                price = await pricing_service.get_price_for_date(session, property_id, current_date, base_price)
            days_data.append({
                'date': current_date.strftime('%Y-%m-%d'),
                'status': status,
                'price': price,
                'comment': comment
            })
    return web.json_response(days_data)

# --- ИЗМЕНЕНИЕ: Возвращаем обработчик для установки доступности ---
async def set_availability(request: web.Request) -> web.Response:
    try:
        data = await request.json()
        property_id = int(data['property_id'])
        dates_str = data['dates']
        dates = [datetime.strptime(d, '%Y-%m-%d').date() for d in dates_str]
        is_available = bool(data['is_available'])
        comment = data.get('comment')
    except Exception:
        return web.json_response({'error': 'Invalid request body'}, status=400)
    
    await availability_service.set_availability_for_period(property_id, dates, is_available, comment)
    return web.json_response({'status': 'ok'})

async def add_price_rule(request: web.Request) -> web.Response:
    try:
        data = await request.json()
        property_id = int(data['property_id'])
        start_date = datetime.strptime(data['start_date'], '%Y-%m-%d').date()
        end_date = datetime.strptime(data['end_date'], '%Y-%m-%d').date()
        price = int(data['price'])
    except Exception:
        return web.json_response({'error': 'Invalid request body'}, status=400)
    await pricing_service.add_price_rule(property_id, start_date, end_date, price)
    return web.json_response({'status': 'ok'})

--------------------------------------------------------------------------------
--- FILE: src/web/__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--- FILE: src/keyboards/__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--- FILE: src/keyboards/inline_keyboards.py
--------------------------------------------------------------------------------
import time
from datetime import datetime, timedelta
from typing import List
from aiogram.types import (InlineKeyboardButton, ReplyKeyboardMarkup, 
                           KeyboardButton, InlineKeyboardMarkup, WebAppInfo)
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.filters.callback_data import CallbackData
from aiogram_calendar import SimpleCalendar

from src.core.constants import DISTRICTS, PROPERTY_TYPES, ROOM_OPTIONS, GUEST_OPTIONS
from src.core.settings import settings

def get_main_menu():
    """Возвращает главное меню бота."""
    builder = InlineKeyboardBuilder()
    builder.button(text="🔍 Найти жилье", callback_data="main_menu:search")
    builder.button(text="🏠 Добавить объект", callback_data="main_menu:add_property")
    builder.button(text="ℹ️ О сервисе", callback_data="main_menu:about")
    builder.adjust(1)
    return builder.as_markup()

def get_property_card_keyboard(property_id: int, photos_count: int = 0, has_video: bool = False, reviews_count: int = 0):
    """
    Возвращает клавиатуру для карточки объекта с кнопками просмотра медиа,
    отзывов и бронирования.
    """
    builder = InlineKeyboardBuilder()
    total_media_count = photos_count + (1 if has_video else 0)

    if has_video:
        builder.button(text=f"▶️ Видео и фото ({total_media_count})", callback_data=f"view_media:{property_id}")
    elif photos_count > 1:
        builder.button(text=f"📸 Все фото ({photos_count})", callback_data=f"view_photos:{property_id}")

    if reviews_count > 0:
        builder.button(text=f"💬 Читать отзывы ({reviews_count})", callback_data=f"view_reviews:{property_id}")
    
    # --- ИЗМЕНЕНИЕ ЗДЕСЬ: Добавляем параметр для сброса кэша ---
    # `v={int(time.time())}` добавит к URL текущее время в секундах,
    # делая каждую ссылку уникальной для кэширующей системы Telegram.
    # Это гарантирует, что пользователь всегда будет получать свежую версию Web App.
    web_app_url = f"{settings.WEB_APP_BASE_URL}/webapp/client?property_id={property_id}&v={int(time.time())}"

    builder.button(text="📅 Забронировать", web_app=WebAppInfo(url=web_app_url))
    
    builder.adjust(1)
    
    return builder.as_markup()

def get_rating_keyboard(booking_id: int):
    """Возвращает клавиатуру для оценки (звездочки)."""
    builder = InlineKeyboardBuilder()
    for i in range(1, 6):
        builder.button(text=f"⭐️ {i}", callback_data=f"review:{booking_id}:rating:{i}")
    builder.adjust(5)
    return builder.as_markup()

async def get_calendar():
    """Возвращает стандартный календарь."""
    calendar = SimpleCalendar()
    calendar.set_dates_range(datetime.now(), datetime.now() + timedelta(days=365))
    return await calendar.start_calendar()

def get_region_keyboard():
    """Возвращает клавиатуру для выбора региона."""
    builder = InlineKeyboardBuilder()
    for region in DISTRICTS.keys():
        builder.button(text=region, callback_data=f"add_property_region:{region}")
    builder.adjust(2)
    return builder.as_markup()

def get_district_keyboard(region: str):
    """Возвращает клавиатуру для выбора района внутри региона."""
    builder = InlineKeyboardBuilder()
    builder.button(text=f"➡️ Все варианты в '{region}'", callback_data=f"search_all_in_region:{region}")
    for index, district_name in enumerate(DISTRICTS[region]):
        builder.button(text=district_name, callback_data=f"add_prop_dist:{region}:{index}")
    builder.button(text="🔙 Назад", callback_data="back_to_regions")
    builder.adjust(1)
    return builder.as_markup()

def get_rooms_keyboard():
    """Возвращает клавиатуру для выбора количества комнат."""
    builder = InlineKeyboardBuilder()
    for option in ROOM_OPTIONS:
        builder.button(text=option, callback_data=f"add_property_rooms:{option}")
    builder.adjust(3)
    return builder.as_markup()

def get_guests_keyboard():
    """Возвращает клавиатуру для выбора количества гостей."""
    builder = InlineKeyboardBuilder()
    for option in GUEST_OPTIONS:
        builder.button(text=option, callback_data=f"add_property_guests:{option}")
    builder.adjust(4)
    return builder.as_markup()

def get_property_types_keyboard():
    """Возвращает клавиатуру для выбора типа объекта."""
    builder = InlineKeyboardBuilder()
    for prop_type in PROPERTY_TYPES:
        builder.button(text=prop_type, callback_data=f"add_property_type:{prop_type}")
    builder.adjust(2)
    return builder.as_markup()

def get_property_management_keyboard(property_id: int, is_active: bool):
    """Возвращает клавиатуру управления объектом для владельца."""
    builder = InlineKeyboardBuilder()
    if is_active:
        builder.button(text="🔴 Скрыть", callback_data=f"manage:toggle:{property_id}")
    else:
        builder.button(text="🟢 Активировать", callback_data=f"manage:toggle:{property_id}")
    builder.button(text="✏️ Редактировать", callback_data=f"manage:edit:{property_id}")
    builder.button(text="🗑️ Удалить", callback_data=f"manage:delete:{property_id}")
    builder.adjust(2, 1)
    return builder.as_markup()

def get_delete_confirmation_keyboard(property_id: int):
    """Возвращает клавиатуру подтверждения удаления."""
    builder = InlineKeyboardBuilder()
    builder.button(text="✅ Да, удалить", callback_data=f"manage:delete_confirm:{property_id}")
    builder.button(text="❌ Отмена", callback_data=f"manage:delete_cancel")
    return builder.as_markup()

def get_edit_property_keyboard(property_id: int):
    """Возвращает клавиатуру для меню редактирования объекта."""
    builder = InlineKeyboardBuilder()
    builder.button(text="Название", callback_data=f"edit_prop:title:{property_id}")
    builder.button(text="Описание", callback_data=f"edit_prop:description:{property_id}")
    builder.button(text="Адрес", callback_data=f"edit_prop:address:{property_id}")
    builder.button(text="Кол-во комнат", callback_data=f"edit_prop:rooms:{property_id}")
    builder.button(text="Цену", callback_data=f"edit_prop:price:{property_id}")
    builder.button(text="Кол-во гостей", callback_data=f"edit_prop:guests:{property_id}")
    builder.button(text="Тип объекта", callback_data=f"edit_prop:type:{property_id}")
    builder.button(text="📸 Управлять фото/видео", callback_data=f"edit_prop:media:{property_id}")
    
    # --- ИЗМЕНЕНИЕ ЗДЕСЬ: Формируем правильный URL для Web App владельца ---
    owner_web_app_url = f"{settings.WEB_APP_BASE_URL}/webapp/owner?property_id={property_id}&v={int(time.time())}"
    builder.button(text="🗓️ Управлять доступностью", web_app=WebAppInfo(url=owner_web_app_url))
    
    builder.button(text="🔙 Назад к списку", callback_data="back_to_my_properties")
    builder.adjust(2, 2, 2, 1, 1, 1)
    return builder.as_markup()

def get_delete_one_media_keyboard(media_id: int):
    """Возвращает кнопку удаления для одного медиафайла."""
    builder = InlineKeyboardBuilder()
    builder.button(text="🗑️ Удалить это медиа", callback_data=f"edit_media:delete:{media_id}")
    return builder.as_markup()

def get_media_management_keyboard(property_id: int):
    """Возвращает клавиатуру для управления медиа (добавить/готово)."""
    builder = InlineKeyboardBuilder()
    builder.button(text="➕ Добавить еще фото/видео", callback_data=f"edit_media:add:{property_id}")
    builder.button(text="✅ Готово", callback_data=f"edit_media:done:{property_id}")
    builder.adjust(1)
    return builder.as_markup()

def get_finish_upload_keyboard():
    """Возвращает Reply-клавиатуру для завершения загрузки фото."""
    return ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="Завершить загрузку")], [KeyboardButton(text="Отмена")]], resize_keyboard=True)

def get_skip_video_keyboard():
    """Возвращает Reply-клавиатуру для пропуска шага с видео."""
    return ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="Пропустить этот шаг")], [KeyboardButton(text="Отмена")]], resize_keyboard=True, one_time_keyboard=True)

def get_booking_management_keyboard(booking_id: int):
    """Возвращает клавиатуру для управления заявкой на бронь (принять/отклонить)."""
    builder = InlineKeyboardBuilder()
    builder.button(text="✅ Принять", callback_data=f"booking:confirm:{booking_id}")
    builder.button(text="❌ Отклонить", callback_data=f"booking:reject:{booking_id}")
    builder.adjust(2)
    return builder.as_markup()

--------------------------------------------------------------------------------
--- FILE: src/models/__init__.py
--------------------------------------------------------------------------------
# Этот файл собирает все модели из папки models
# Чтобы SQLAlchemy и Alembic могли их легко найти.

from .base import Base
from .models import User, Property, PropertyMedia, Booking

--------------------------------------------------------------------------------
--- FILE: src/models/base.py
--------------------------------------------------------------------------------
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    pass

--------------------------------------------------------------------------------
--- FILE: src/models/models.py
--------------------------------------------------------------------------------
from datetime import datetime
# --- ИЗМЕНЕНИЕ ЗДЕСЬ: Полный и правильный список импортов ---
from sqlalchemy import (BigInteger, Boolean, Column, DateTime, ForeignKey,
                        Integer, String, Text, func, Date, UniqueConstraint)
from sqlalchemy.orm import relationship, Mapped
from .base import Base

# Общая функция для временных меток
def now_on_update_now():
    return {
        'server_default': func.now(),
        'onupdate': func.now(),
        'nullable': False
    }

class User(Base):
    __tablename__ = 'users'
    telegram_id = Column(BigInteger, primary_key=True)
    username = Column(String(32), unique=True, nullable=True)
    first_name = Column(String(64), nullable=False)
    role = Column(String(20), default='user', nullable=False)
    created_at = Column(DateTime, server_default=func.now(), nullable=False)
    updated_at = Column(DateTime, **now_on_update_now())
    bookings = relationship('Booking', back_populates='user')
    properties = relationship('Property', back_populates='owner')
    reviews = relationship('Review', back_populates='user')
    __table_args__ = {'schema': 'public'}

class Property(Base):
    __tablename__ = 'properties'
    id = Column(Integer, primary_key=True)
    owner_id = Column(BigInteger, ForeignKey('public.users.telegram_id'), nullable=False)
    title = Column(String(100), nullable=False)
    description = Column(Text, nullable=True)
    address = Column(String(255), nullable=False)
    district = Column(String(50), nullable=False, index=True)
    price_per_night = Column(Integer, nullable=False, index=True) 
    rooms = Column(Integer, nullable=False)
    max_guests = Column(Integer, default=1, nullable=False)
    property_type = Column(String(50), nullable=False)
    is_verified = Column(Boolean, default=False, nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime, server_default=func.now(), nullable=False)
    updated_at = Column(DateTime, **now_on_update_now())
    owner = relationship('User', back_populates='properties')
    media = relationship('PropertyMedia', back_populates='property', cascade="all, delete-orphan")
    bookings = relationship('Booking', back_populates='property', cascade="all, delete-orphan")
    reviews = relationship('Review', back_populates='property', cascade="all, delete-orphan")
    unavailable_dates = relationship('UnavailableDate', back_populates='property', cascade="all, delete-orphan")
    price_rules = relationship('PriceRule', back_populates='property', cascade="all, delete-orphan")
    __table_args__ = {'schema': 'public'}

class PropertyMedia(Base):
    __tablename__ = 'property_media'
    id = Column(Integer, primary_key=True)
    property_id = Column(Integer, ForeignKey('public.properties.id'), nullable=False)
    file_id = Column(String(255), nullable=False)
    media_type = Column(String(10), nullable=False)
    created_at = Column(DateTime, server_default=func.now(), nullable=False)
    property = relationship('Property', back_populates='media')
    __table_args__ = {'schema': 'public'}

class Booking(Base):
    __tablename__ = 'bookings'
    id = Column(Integer, primary_key=True)
    property_id = Column(Integer, ForeignKey('public.properties.id'), nullable=False)
    user_id = Column(BigInteger, ForeignKey('public.users.telegram_id'), nullable=False)
    start_date = Column(DateTime, nullable=False)
    end_date = Column(DateTime, nullable=False)
    status = Column(String(20), default='pending', nullable=False)
    created_at = Column(DateTime, server_default=func.now(), nullable=False)
    updated_at = Column(DateTime, **now_on_update_now())
    user = relationship('User', back_populates='bookings')
    property = relationship('Property', back_populates='bookings')
    review = relationship('Review', back_populates='booking', uselist=False, cascade="all, delete-orphan")
    __table_args__ = {'schema': 'public'}

class Review(Base):
    __tablename__ = 'reviews'
    id = Column(Integer, primary_key=True)
    property_id = Column(Integer, ForeignKey('public.properties.id'), nullable=False)
    user_id = Column(BigInteger, ForeignKey('public.users.telegram_id'), nullable=False)
    booking_id = Column(Integer, ForeignKey('public.bookings.id'), unique=True, nullable=False)
    rating = Column(Integer, nullable=False)
    text = Column(Text, nullable=True)
    created_at = Column(DateTime, server_default=func.now(), nullable=False)
    updated_at = Column(DateTime, **now_on_update_now())
    property = relationship('Property', back_populates='reviews')
    user = relationship('User', back_populates='reviews')
    booking = relationship('Booking', back_populates='review')
    __table_args__ = {'schema': 'public'}

class UnavailableDate(Base):
    __tablename__ = 'unavailable_dates'
    id = Column(Integer, primary_key=True)
    property_id = Column(Integer, ForeignKey('public.properties.id'), nullable=False)
    date = Column(Date, nullable=False)
    comment = Column(String(100), nullable=True)
    created_at = Column(DateTime, server_default=func.now(), nullable=False)
    property = relationship('Property', back_populates='unavailable_dates')
    # --- ИЗМЕНЕНИЕ ЗДЕСЬ: Добавляем уникальное ограничение ---
    __table_args__ = (
        UniqueConstraint('property_id', 'date', name='uq_property_date'),
        {'schema': 'public'}
    )

class PriceRule(Base):
    __tablename__ = 'price_rules'
    id = Column(Integer, primary_key=True)
    property_id = Column(Integer, ForeignKey('public.properties.id'), nullable=False)
    start_date = Column(Date, nullable=False)
    end_date = Column(Date, nullable=False)
    price = Column(Integer, nullable=False)
    created_at = Column(DateTime, server_default=func.now(), nullable=False)
    property = relationship('Property', back_populates='price_rules')
    __table_args__ = {'schema': 'public'}

--------------------------------------------------------------------------------
--- FILE: src/utils/__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--- FILE: src/utils/states.py
--------------------------------------------------------------------------------
from aiogram.fsm.state import State, StatesGroup

class AddProperty(StatesGroup):
    title = State()
    description = State()
    region = State()
    district = State()
    address = State()
    rooms = State()
    price_per_night = State()
    max_guests = State()
    property_type = State()
    photos = State()
    video_note = State()
    
class SearchProperties(StatesGroup):
    region = State()
    district = State()
    price = State()
    guests = State()

class EditProperty(StatesGroup):
    choosing_field = State()
    editing_title = State()
    editing_description = State()
    editing_address = State()
    editing_region = State()
    editing_district = State()
    editing_rooms = State()
    editing_price = State()
    editing_guests = State()
    editing_type = State()
    managing_media = State()
    adding_photos = State()
    managing_availability = State() # Новое состояние

class LeaveReview(StatesGroup):
    waiting_for_rating = State()
    waiting_for_comment = State()

class BookingFlow(StatesGroup):
    choosing_checkin_date = State()
    choosing_checkout_date = State()

--------------------------------------------------------------------------------
--- FILE: src/middlewares/error_catcher.py
--------------------------------------------------------------------------------
import logging
from typing import Any, Awaitable, Callable, Dict
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject

class ErrorCatcherMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any]
    ) -> Any:
        try:
            # Пытаемся выполнить основной обработчик
            return await handler(event, data)
        except Exception as e:
            # Если произошла любая ошибка, логируем ее
            logging.exception("Критическая ошибка в обработчике: %s", e)
            # Мы не пробрасываем ошибку дальше, чтобы aiohttp
            # не вернул Telegram'у ошибку 500.
            # Это "проглатывает" ошибку и позволяет боту работать дальше.

--------------------------------------------------------------------------------
--- FILE: src/core/settings.py
--------------------------------------------------------------------------------
import os
from pydantic import SecretStr
from pydantic_settings import BaseSettings, SettingsConfigDict

# --- ИЗМЕНЕНИЕ ЗДЕСЬ: Определяем абсолютный путь к .env ---
# Наш рабочий каталог в Docker - /app
# Мы строим путь от текущего файла (settings.py) вверх по иерархии до корня проекта.
# Это самый надежный способ найти .env файл.
# dirname(__file__) -> /app/app/core
# dirname(dirname(__file__)) -> /app/app
# dirname(dirname(dirname(__file__))) -> /app
# os.path.join(...) -> /app/.env
env_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')


class Settings(BaseSettings):
    # --- ИЗМЕНЕНИЕ ЗДЕСЬ: Явно указываем путь к файлу ---
    model_config = SettingsConfigDict(env_file=env_path, env_file_encoding='utf-8')

    BOT_TOKEN: SecretStr
    ADMIN_IDS: list[int]

    POSTGRES_USER: str
    POSTGRES_PASSWORD: SecretStr
    POSTGRES_DB: str
    POSTGRES_HOST: str
    POSTGRES_PORT: int

    REDIS_HOST: str
    REDIS_PORT: int

    WEB_APP_BASE_URL: str
    WEBHOOK_SECRET: SecretStr

    @property
    def DATABASE_URL_asyncpg(self) -> str:
        return (f"postgresql+asyncpg://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD.get_secret_value()}"
                f"@{self.POSTGRES_HOST}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}")

    @property
    def DATABASE_URL_psycopg(self) -> str:
        return (f"postgresql+psycopg2://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD.get_secret_value()}"
                f"@{self.POSTGRES_HOST}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}")

settings = Settings()

# Не забудьте удалить этот блок после отладки!
print("="*50)
print(f"DEBUG: Trying to load .env from: {env_path}")
print("DEBUG: Loaded settings object:")
print(settings.model_dump())
print("="*50)

--------------------------------------------------------------------------------
--- FILE: src/core/__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
--- FILE: src/core/commands.py
--------------------------------------------------------------------------------
from aiogram import Bot
from aiogram.types import BotCommand, BotCommandScopeChat, BotCommandScopeDefault

from src.core.settings import settings

# Добавляем /help в список для всех пользователей
user_commands = [
    BotCommand(command="start", description="🚀 Перезапустить бота / Главное меню"),
    BotCommand(command="help", description="ℹ️ Справка по боту"),
    BotCommand(command="cancel", description="❌ Отменить текущее действие")
]

# Администраторы автоматически получат эту команду
admin_commands = user_commands + [
    BotCommand(command="myproperties", description="📋 Мои объекты"),
    BotCommand(command="addproperty", description="🏠 Добавить новый объект"),
    BotCommand(command="verify", description="✅ Верифицировать объект"),
    BotCommand(command="unverify", description="❌ Снять верификацию"),
    BotCommand(command="setrole", description="👤 Назначить роль")
]


async def set_commands(bot: Bot):
    await bot.set_my_commands(commands=user_commands, scope=BotCommandScopeDefault())
    
    # Убедимся, что у админов будет полный список
    for admin_id in settings.ADMIN_IDS:
        await bot.set_my_commands(commands=admin_commands, scope=BotCommandScopeChat(chat_id=admin_id))

--------------------------------------------------------------------------------
--- FILE: src/core/scheduler.py
--------------------------------------------------------------------------------
from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from aiogram import Bot
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode

from src.core.settings import settings
# --- ИСПРАВЛЕНИЕ ЗДЕСЬ: Указываем новый, правильный путь к файлу ---
from src.keyboards.inline_keyboards import get_rating_keyboard

jobstores = {
    'default': SQLAlchemyJobStore(url=settings.DATABASE_URL_psycopg)
}
scheduler = AsyncIOScheduler(jobstores=jobstores, timezone="Europe/Kaliningrad")


async def request_review(bot_token: str, chat_id: int, booking_id: int, property_title: str):
    """
    Запрашивает у пользователя отзыв о проживании.
    """
    temp_bot = Bot(token=bot_token, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
    try:
        await temp_bot.send_message(
            chat_id=chat_id,
            text=(
                f"Надеемся, вам понравилось проживание в «{property_title}»!\n\n"
                f"Пожалуйста, оцените ваш опыт по пятизвездочной шкале. Это поможет другим путешественникам сделать правильный выбор."
            ),
            reply_markup=get_rating_keyboard(booking_id)
        )
    finally:
        await temp_bot.session.close()

--------------------------------------------------------------------------------
--- FILE: src/core/constants.py
--------------------------------------------------------------------------------
DISTRICTS = {
    "Калининград": [
        'Центральный (весь)',
        'мкр. Сельма',
        'Амалиенау / Центр',
        'Ленинградский (весь)',
        'Верхнее Озеро',
        'Московский (весь)',
        'Остров Канта'
    ],
    "Побережье": ['Зеленоградск', 'Светлогорск', 'Янтарный', 'Пионерский', 'Балтийск'],
    "Куршская коса": ["Куршская коса"],
    "Другие города": ['Черняховск', 'Советск', 'Гусев', 'Другой']
}

PROPERTY_TYPES = ['Квартира', 'Апартаменты', 'Дом', 'Кемпинг']
ROOM_OPTIONS = ['Студия', '1', '2', '3', '4', '5+']
GUEST_OPTIONS = ['1', '2', '3', '4', '5', '6', '7', '8+']

--------------------------------------------------------------------------------
--- FILE: .pytest_cache/CACHEDIR.TAG
--------------------------------------------------------------------------------
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html


--------------------------------------------------------------------------------
--- FILE: .pytest_cache/README.md
--------------------------------------------------------------------------------
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.


--------------------------------------------------------------------------------
--- FILE: .pytest_cache/v/cache/lastfailed
--------------------------------------------------------------------------------
{
  "tests/unit/test_booking_service.py::test_update_booking_status": true,
  "tests/unit/test_property_service.py::test_add_and_get_property": true,
  "tests/unit/test_property_service.py::test_get_all_properties_filters": true,
  "tests/unit/test_property_service.py::TestPropertyService::test_add_and_get_property": true,
  "tests/unit/test_property_service.py::TestPropertyService::test_get_all_properties_filters": true
}

--------------------------------------------------------------------------------
--- FILE: .pytest_cache/v/cache/stepwise
--------------------------------------------------------------------------------
[]

--------------------------------------------------------------------------------
--- FILE: .pytest_cache/v/cache/nodeids
--------------------------------------------------------------------------------
[
  "tests/services/test_booking_service.py::test_create_and_count_pending_booking",
  "tests/services/test_booking_service.py::test_update_booking_status_and_dates",
  "tests/services/test_property_service.py::test_add_and_get_property",
  "tests/services/test_property_service.py::test_delete_property",
  "tests/services/test_property_service.py::test_toggle_property_activity",
  "tests/services/test_user_service.py::test_add_and_get_user",
  "tests/services/test_user_service.py::test_add_existing_user",
  "tests/unit/test_booking_service.py::TestBookingService::test_create_and_get_booking",
  "tests/unit/test_booking_service.py::TestBookingService::test_update_booking_status",
  "tests/unit/test_booking_service.py::test_create_and_get_booking",
  "tests/unit/test_booking_service.py::test_update_booking_status",
  "tests/unit/test_property_service.py::TestPropertyService::test_add_and_get_property",
  "tests/unit/test_property_service.py::TestPropertyService::test_get_all_properties_filters",
  "tests/unit/test_property_service.py::test_add_and_get_property",
  "tests/unit/test_property_service.py::test_get_all_properties_filters"
]

